package fabric.metrics;

import fabric.util.Arrays;
import fabric.util.Collections;
import fabric.util.Set;
import fabric.util.TreeSet;
import fabric.util.HashSet;
import fabric.util.Iterator;

import fabric.metrics.contracts.Bound;
import fabric.metrics.util.Observer;

import fabric.common.ConfigProperties;
import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.RunningMetricStats;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.MetricTreaty;
import fabric.worker.metrics.treaties.enforcement.DirectPolicy;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.enforcement.WitnessPolicy;
import fabric.worker.metrics.treaties.statements.EqualityStatement;
import fabric.worker.metrics.treaties.statements.TreatyStatement;
import fabric.worker.metrics.treaties.statements.ThresholdStatement;
import fabric.worker.transaction.TransactionManager;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import com.google.common.collect.Multimap;
import com.google.common.collect.HashMultimap;

import java.util.logging.Level;
import fabric.common.Logging;
import java.io.StringWriter;
import java.io.PrintWriter;

/**
 * General base class for {@link Metric}s built by computing over other
 * {@link Metrics}. Each {@link DerivedMetric} implementation is responsible for
 * defining how to
 * <ul>
 * <li>construct the {@link #value()}, {@link #velocity()}, and {@link #noise()}
 * from its terms</li>
 * <li>provide a {@link EnforcementPolicy} to enforce a
 * {@link MetricTreaty} on it given the {@link Bound}, typically using
 * a {@link WitnessPolicy} using {@link MetricTreaty}s on the terms it is
 * derived from.</li>
 * </ul>
 */
public abstract class DerivedMetric extends Metric implements Observer {

  /**
   * The {@link Metric} terms that this {@link DerivedMetric} is computed
   * from.
   */
  protected final ImmutableMetricsVector terms;

  /*
   * Cached update stats.
   */
  protected double cachedValue;
  protected double cachedVelocity;
  protected double cachedNoise;
  protected long cachedSamples;
  protected long cachedLastUpdate;
  protected double cachedUpdateInterval;

  private final ImmutableMetricsVector leafMetrics;
  private final boolean singleStore;

  /**
   * @param s
   *        the {@link Store} this {@link DerivedMetric} will be stored on
   * @param terms
   *        the {@link Metric}s that this {@link DerivedMetric} is
   *        computed from
   */
  public DerivedMetric fabric$metrics$DerivedMetric$(Metric native[] terms) {
    // Removed because expensive and we're going to assume for now it's not an
    // error if it happens...
    //if (new TreeSet[><><]().fabric$util$TreeSet$(Arrays.asList(terms)).size() != terms.length())
    //  throw new IllegalArgumentException(
    //          "DerivedMetric terms must not contain duplicates: "
    //                  + Arrays.deepToString(terms));
    boolean single = true;
    for (int i = 0; i < terms.length; i++) {
      if (!terms[i].isSingleStore()
            || !terms[i].$getStore().equals($getStore())) {
        single = false;
        break;
      }
    }
    this.singleStore = single;
    this.terms = ImmutableMetricsVector.createVector(terms);
    // Presets
    if (getUsePreset()) {
      this.presetR = computePresetR();
      this.presetB = computePresetB();
      this.presetV = computePresetV();
      this.presetN = computePresetN();
    } else {
      this.presetR = 0.0;
      this.presetB = 0.0;
      this.presetV = 0.0;
      this.presetN = 0.0;
    }
    fabric$metrics$Metric$();
    return this;
  }

  /*@Override*/
  public boolean getUsePreset() {
    return Worker.getWorker().config.usePreset;
  }

  public final double presetR;
  /*@Override*/
  public double getPresetR() {
    return presetR;
  }
  public abstract double computePresetR();

  public final double presetB;
  /*@Override*/
  public double getPresetB() {
    return presetB;
  }
  public abstract double computePresetB();

  public final double presetV;
  /*@Override*/
  public double getPresetV() {
    return presetV;
  }
  public abstract double computePresetV();

  public final double presetN;
  /*@Override*/
  public double getPresetN() {
    return presetN;
  }
  public abstract double computePresetN();

  /**
   * Method to be called at the end of a constructor for any subclass of
   * {@link DerivedMetric}. Ensures that the {@link getLeafSubjects()} result
   * is precomputed after the representation has been normalized.
   */
  protected void initialize() {
    java.util.Set leafMetricsTmp = new java.util.HashSet();
    for (int i = 0; i < terms.length(); i++) {
      if (terms.get(i) instanceof SampledMetric) {
        leafMetricsTmp.add(/*(SampledMetric)*/ terms.get(i));
      } else if (terms.get(i) instanceof DerivedMetric) {
        DerivedMetric termI = (DerivedMetric) terms.get(i);
        ImmutableMetricsVector/*<SampledMetric>*/ termILeaves = termI.getLeafSubjects();
        for (int j = 0; j < termILeaves.length(); j++)
          leafMetricsTmp.add(termILeaves.get(j));
      } else {
        throw new IllegalStateException(
            "This shouldn't happen, all metrics should either be a SampledMetric or a DerivedMetric!");
      }
    }
    Metric native [] leafMetricsArr = new Metric native [leafMetricsTmp.size()];
    int lmIdx = 0;
    for (java.util.Iterator it = leafMetricsTmp.iterator(); it.hasNext();) {
      leafMetricsArr[lmIdx++] = (SampledMetric) it.next();
    }
    leafMetrics = ImmutableMetricsVector.createVector(leafMetricsArr);
  }

  /*@Override*/
  public ImmutableObserverSet handleDirectUpdates() {
    ImmutableObserverSet affected = ImmutableObserverSet.emptySet();
    double newValue = computeValue(StatsMap.emptyStats());
    if (newValue != cachedValue) {
      //Logging.METRICS_LOGGER.log(Level.FINER, "UPDATE ON DERIVED METRIC");
      cachedValue = newValue;
      cachedVelocity = computeVelocity(StatsMap.emptyStats());
      cachedNoise = computeNoise(StatsMap.emptyStats());
      cachedSamples = computeSamples(StatsMap.emptyStats());
      cachedLastUpdate = System.currentTimeMillis();
      cachedUpdateInterval = computeUpdateInterval(StatsMap.emptyStats());
      affected = affected.addAll(getObservers());
    }
    return affected;
  }

  // XXX: note that the below assumes that if we're not using weakly cached
  // items, we're called from a transactional context!
  /*@Override*/
  public double value(StatsMap weakStats) {
    return static_value(this, weakStats);
  }

  private static double static_value(DerivedMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getValue(tmp);
    if (tmp.isObserved()) {
      if (TransactionManager.getInstance().inTxn()) {
        fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
        return tmp.cachedValue;
      } else {
        double rtn = 0;
        atomic {
          // No resolve here, we weren't in a transaction.
          rtn = tmp.cachedValue;
        }
        return rtn;
      }
    }
    // Not getting updated proactively, so compute it
    return tmp.computeValue(weakStats);
  }

  /*@Override*/
  public long samples(StatsMap weakStats) {
    return static_samples(this, weakStats);
  }

  private static long static_samples(DerivedMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getSamples(tmp);
    if (tmp.isObserved()) {
      if (TransactionManager.getInstance().inTxn()) {
        fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
        return tmp.cachedSamples;
      } else {
        long rtn = 0;
        atomic {
          // No resolve here, we weren't in a transaction.
          rtn = tmp.cachedSamples;
        }
        return rtn;
      }
    }
    return tmp.computeSamples(weakStats);
  }

  /*@Override*/
  protected long computeSamples(StatsMap weakStats) {
    long samples = 0;
    for (int i = 0; i < terms.length(); i++) {
      samples = samples + term(i).samples(weakStats);
    }
    return samples;
  }

  /*@Override*/
  public long lastUpdate(StatsMap weakStats) {
    return static_lastUpdate(this, weakStats);
  }

  private static long static_lastUpdate(DerivedMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getLastUpdate(tmp);
    if (tmp.isObserved()) {
      if (TransactionManager.getInstance().inTxn()) {
        fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
        return tmp.cachedLastUpdate;
      } else {
        long rtn = 0;
        atomic {
          // No resolve here, we weren't in a transaction.
          rtn = tmp.cachedLastUpdate;
        }
        return rtn;
      }
    }
    return tmp.computeLastUpdate(weakStats);
  }

  /*@Override*/
  protected long computeLastUpdate(StatsMap weakStats) {
    long lastUpdate = 0;
    for (int i = 0; i < terms.length(); i++) {
      lastUpdate = Math.max(lastUpdate, term(i).lastUpdate(weakStats));
    }
    return lastUpdate;
  }

  /*@Override*/
  public double updateInterval(StatsMap weakStats) {
    return static_updateInterval(this, weakStats);
  }

  private static double static_updateInterval(DerivedMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getUpdateInterval(tmp);
    if (tmp.isObserved()) {
      if (TransactionManager.getInstance().inTxn()) {
        fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
        return tmp.cachedUpdateInterval;
      } else {
        double rtn = 0;
        atomic {
          // No resolve here, we weren't in a transaction.
          rtn = tmp.cachedUpdateInterval;
        }
        return rtn;
      }
    }
    return tmp.computeUpdateInterval(weakStats);
  }

  /*@Override*/
  protected double computeUpdateInterval(StatsMap weakStats) {
    double updateInterval = Double.MAX_VALUE;
    // For now, assume update interval is min of update intervals of terms.
    for (int i = 0; i < terms.length(); i++) {
      updateInterval = Math.min(updateInterval, term(i).updateInterval(weakStats));
    }
    return updateInterval;
  }

  // XXX: note that the below assumes that if we're not using weakly cached
  // items, we're called from a transactional context!
  /*@Override*/
  public double velocity(StatsMap weakStats) {
    return static_velocity(this, weakStats);
  }

  private static double static_velocity(DerivedMetric tmp, StatsMap weakStats) {
    if (tmp.getUsePreset()) return tmp.presetV;
    if (weakStats.containsKey(tmp)) return weakStats.getVelocity(tmp);
    if (tmp.isObserved()) {
      // Separated here because we're not expecting regular updates unless
      // observing, the weak values don't try to account for time since the last
      // update.
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
      return RunningMetricStats.updatedVelocity(tmp.cachedVelocity,
          tmp.cachedUpdateInterval, tmp.cachedSamples, tmp.cachedLastUpdate,
          System.currentTimeMillis());
    }
    // Not getting updated proactively, so compute it
    return tmp.computeVelocity(weakStats);
  }

  // XXX: note that the below assumes that if we're not using weakly cached
  // items, we're called from a transactional context!
  /*@Override*/
  public double noise(StatsMap weakStats) {
    return static_noise(this, weakStats);
  }

  private static double static_noise(DerivedMetric tmp, StatsMap weakStats) {
    if (tmp.getUsePreset()) return tmp.presetN;
    if (weakStats.containsKey(tmp)) return weakStats.getNoise(tmp);
    if (tmp.isObserved()) {
      // Separated here because we're not expecting regular updates unless
      // observing, the weak values don't try to account for time since the last
      // update.
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
      return RunningMetricStats.updatedNoise(tmp.cachedVelocity,
          tmp.cachedNoise, tmp.cachedUpdateInterval, tmp.cachedSamples,
          tmp.cachedLastUpdate, System.currentTimeMillis());
    }
    // Not getting updated proactively, so compute it
    return tmp.computeNoise(weakStats);
  }

  /*@Override*/
  public boolean isSingleStore() {
    return singleStore;
  }

  /**
   * {@inheritDoc}
   *
   * If this is the first observer, then this metric is being monitored for
   * changes and so it stops computing on demand and instead caches the last
   * updated value (computed on checks). This metric then becomes an observer
   * of its terms.
   */
  /*@Override*/
  public void addObserver(Observer obs) {
    if (!isObserved()) {
      // Start tracking terms if this is now used by a treaty directly.
      for (int i = 0; i < terms.length(); i++) {
        term(i).addObserver(this);
      }
      cachedValue = computeValue(StatsMap.emptyStats());
      cachedVelocity = computeVelocity(StatsMap.emptyStats());
      cachedNoise = computeNoise(StatsMap.emptyStats());
      cachedSamples = computeSamples(StatsMap.emptyStats());
      cachedLastUpdate = System.currentTimeMillis();
      cachedUpdateInterval = computeUpdateInterval(StatsMap.emptyStats());
    }
    super.addObserver(obs);
  }

  /**
   * {@inheritDoc}
   *
   * If this is the first observer, then this metric is being monitored for
   * changes and so it stops computing on demand and instead caches the last
   * updated value (computed on checks). This metric then becomes an observer
   * of its terms.
   */
  /*@Override*/
  public void addObserver(Observer obs, long id) {
    if (!isObserved()) {
      // Start tracking terms if this is now used by a treaty directly.
      for (int i = 0; i < terms.length(); i++) {
        term(i).addObserver(this);
      }
      cachedValue = computeValue(StatsMap.emptyStats());
      cachedVelocity = computeVelocity(StatsMap.emptyStats());
      cachedNoise = computeNoise(StatsMap.emptyStats());
      cachedSamples = computeSamples(StatsMap.emptyStats());
      cachedLastUpdate = System.currentTimeMillis();
      cachedUpdateInterval = computeUpdateInterval(StatsMap.emptyStats());
    }
    super.addObserver(obs, id);
  }

  /**
   * {@inheritDoc}
   *
   * If there are no observers after removing the given one, this metric stops
   * acting as an observer of its terms (and goes back to computing on demand
   * rather than caching the last updated value).
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
    super.removeObserver(obs);
    if (!isObserved()) {
      // Don't observe subterms unless it's being tracked directly.
      for (int i = 0; i < terms.length(); i++) {
        term(i).removeObserver(this);
      }
    }
  }

  /**
   * @param i
   *        an index into the terms array
   * @return the ith term this {@link DerivedMetric} is defined over
   */
  protected Metric term(int i) {
    return terms.get(i);
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    return leafMetrics;
  }

  private static class Refresher implements Callable {
    final Metric t;
    final StatsMap weakStats;

    public Refresher fabric$metrics$DerivedMetric$Refresher$(Metric t, StatsMap weakStats) {
      this.t = t;
      this.weakStats = weakStats;
      fabric$lang$Object$();
      return this;
    }

    public java.lang.Object call() {
      if (!(t.$getStore().name().equals(Worker.getWorkerName()))) {
        RemoteWorker w = Worker.getWorker().getWorker(t.$getStore().name());
        return t.refreshWeakEstimates_remote@w(null, weakStats);
      }
      return t.refreshWeakEstimates(weakStats);
    }
  }

  private static final int POOL_SIZE = 32;
  private static final ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);

  /*@Override*/
  public StatsMap refreshWeakEstimates(final StatsMap weakStats) {
      Logging.METRICS_LOGGER.finest("REFRESHING" + this);
      StatsMap updated = weakStats;
      if (TransactionManager.getInstance().getCurrentLog() == null) {
        Future native[] futures = new Future native[terms.length() - 1];
        // First, refresh the subterm stats.
        for (int i = 1; i < terms.length(); i++) {
            final Metric t = term(i);
            Logging.METRICS_LOGGER.finest("(PARALLEL) CHILD " + t + " OF " +
                this);
            Callable c = null;
            atomic {
              c = new Refresher().fabric$metrics$DerivedMetric$Refresher$(t, weakStats);
            }
            futures[i - 1] = service.submit(c);
        }
        // Run the first term in this thread.
        Metric t = term(0);
        if (!(t.$getStore().name().equals(Worker.getWorkerName()))) {
          RemoteWorker w = Worker.getWorker().getWorker(t.$getStore().name());
          updated = updated.merge(t.refreshWeakEstimates_remote@w(null, updated));
        } else {
          updated = updated.merge(t.refreshWeakEstimates(updated));
        }
        for (int i = 0; i < futures.length; i++) {
          try {
            updated = updated.merge((StatsMap) futures[i].get());
          } catch (ExecutionException e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String sStackTrace = sw.toString();
            Logging.METRICS_LOGGER.warning("Failure of parallel child: " + e + " Stack\n" + sStackTrace);
          } catch (InterruptedException e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            String sStackTrace = sw.toString();
            Logging.METRICS_LOGGER.warning("Failure of parallel child: " + e + " Stack\n" + sStackTrace);
          }
        }
      } else {
        for (int i = 0; i < terms.length(); i++) {
          Logging.METRICS_LOGGER.finest("(SERIAL) CHILD " + term(i) + " OF "
              + this);
          updated = updated.merge(term(i).refreshWeakEstimates(weakStats));
        }
      }
      // Then update locally.
      return refreshLocally(updated);
  }

  /*@Override*/
  public StatsMap refreshWeakEstimates_remote(fabric.lang.security.Principal caller, StatsMap weakStats) {
    return refreshWeakEstimates(weakStats);
  }

  /*@Override*/
  public EnforcementPolicy equalityPolicy(double value, StatsMap weakStats, final Store s) {
    // TODO: There's a better policy to override this with in MinMetric.
    if (isSingleStore() || value != value()) {
      return DirectPolicy.singleton;
    } else {
      Multimap/*<Metric, TreatyStatement>*/ witnesses = HashMultimap/*<>*/.create();
      // Defend all rows against the bound individually, using the strictest
      // bounds across the rows for each term in this sum.
      for (int i = 0; i < terms.length(); i++) {
        witnesses.put(term(i), new EqualityStatement(term(i).value()));
      }
      return new WitnessPolicy(witnesses);
    }
  }
}

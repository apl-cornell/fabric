package fabric.metrics;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.HashMap;
import java.util.Iterator;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.Contract;
import fabric.metrics.contracts.enforcement.DirectPolicy;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Matrix;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.StatsMap;

//import java.util.logging.Level;
//import fabric.common.Logging;

/**
 * A {@link Metric} for the entries of Cm⃗ where m⃗ is a {@link Metric} and C is
 * a {@link Matrix} of coefficients.
 *
 * Currently deprecated since it's not as easy to generalize for more and more
 * operations.
 */
/*@Deprecated*/
public class LinearMetric extends DerivedMetric {
  /**
   * The {@link Matrix} that defines the transformation applied to this
   * {@link LinearMetric}s terms.
   */
  protected /*final*/ Matrix matrix;
  /**
   * The {@link Matrix} that defines the transformation applied to this
   * {@link LinearMetric}s terms's noise estimates.
   */
  protected /*final*/ Matrix varMatrix;

  /**
   * @param store
   *        the Store that holds this {@link Metric}
   * @param matrix
   *        The coefficients matrix as a double[][]
   * @param terms
   *        The {@link Metric}s this applies to
   */
  public LinearMetric fabric$metrics$LinearMetric$(Matrix matrix, Metric native[] terms) {
    fabric$metrics$DerivedMetric$(terms);
    if (matrix.rows() == 0)
      throw new IllegalArgumentException(
          "LinearMetric needs at least 1 coefficient row!");
    if (matrix.columns() != terms.length)
      throw new IllegalArgumentException(
          "LinearMetric coefficient columns size as the dimension of term: "
              + matrix.toString());

    // Ugh, this technically breaks the constructor protocol, but I need
    // terms initialized before we normalize.
    this.matrix = normalize(matrix).copy(getStore());
    this.varMatrix = this.matrix.elementMultiply(this.matrix).copy(getStore());
    initialize();
    return this;
  }

  /*@Override*/
  public double computePresetR() {
    // Dummy, this is deprecated.
    return 0.0;
  }

  /*@Override*/
  public double computePresetB() {
    // Dummy, this is deprecated.
    return 0.0;
  }

  /*@Override*/
  public double computePresetV() {
    // Dummy, this is deprecated.
    return 0.0;
  }

  /*@Override*/
  public double computePresetN() {
    // Dummy, this is deprecated.
    return 0.0;
  }

  /**
   * Utility to normalize the {@link Metric} terms and {@link Matrix}
   * associated with this {@link LinearMetric}.
   *
   * @param matrix
   *        the original matrix
   * @return the matrix rearranged for sorted terms, sorted rows, and
   *       deduplication of rows.
   */
  private Matrix normalize(Matrix matrix) {
    Metric native [] normTerms = new Metric native [terms.length()];
    System.arraycopy(terms.array(), 0, normTerms, 0, terms.length());
    Arrays.sort(normTerms);
    Matrix colNormed = new Matrix().fabric$metrics$util$Matrix$(matrix.rows(), terms.length());
    for (int i = 0; i < terms.length(); i++) {
      int oldIdx = Arrays.asList(terms.array()).indexOf(normTerms[i]);
      colNormed.setColumn(i, matrix.getColumn(oldIdx));
    }
    this.terms = ImmutableMetricsVector.createVector(normTerms);
    return normalizeRows(colNormed, 0, colNormed.rows());
  }

  /**
   * Utility for normalizing a coefficients {@link Matrix} by sorting rows and
   * eliminating duplicates.
   *
   * @param m
   *        the {@link Matrix} being normalized
   * @return the normalized {@link Matrix}
   */
  private static Matrix normalizeRows(Matrix m, int start, int end) {
    if (end - start > 1) {
      int mid = start + (end - start) / 2;
      Matrix sub1 = normalizeRows(m, start, mid);
      Matrix sub2 = normalizeRows(m, mid, end);
      Matrix merged = new Matrix().fabric$metrics$util$Matrix$(end - start, m.columns());
      int idx1 = 0;
      int idx2 = 0;
      for (int i = 0; i < merged.rows(); i++) {
        int comp = rowCompare(sub1.getRow(idx1), sub2.getRow(idx2));
        if (comp < 0) {
          merged.setRow(i, sub1.getRow(idx1++));
        } else if (comp > 0) {
          merged.setRow(i, sub2.getRow(idx2++));
        } else {
          idx2++;
          merged.removeRow(i--);
        }
      }
      return merged;
    } else if (start == end) {
      return new Matrix().fabric$metrics$util$Matrix$(0, 0);
    }
    return Matrix.singleRow(m.getRow(start));
  }

  /**
   * Utility for comparing two rows of a {@link Matrix} during
   * {@link #normalizeRows(Matrix)}.
   *
   * @param r1
   *        the first row as a double[]
   * @param r2
   *        the second row as a double[]
   * @return 0 if r1 == r2, 1 if r1 > r2 (lexicographically), and -1
   *       otherwise.
   */
  private static int rowCompare(double[] r1, double[] r2) {
    for (int i = 0; i < r1.length; i++) {
      if (r1[i] < r2[i])
        return -1;
      if (r1[i] > r2[i])
        return 1;
    }
    return 0;
  }

  /*@Override*/
  protected double computeValue(StatsMap weakStats) {
    //Logging.METRICS_LOGGER.log(Level.FINER, "RECOMPUTING LINEAR METRIC AT {0}",
    //    getStore().name());
    double[] values = new double[terms.length()];
    for (int i = 0; i < terms.length(); i++) {
      values[i] = term(i).value(weakStats);
    }
    double[] results = matrix.multiply(values);
    double result = Double.MAX_VALUE;
    for (int i = 0; i < results.length; i++) {
      result = Math.min(result, results[i]);
    }
    return result;
  }

  /**
   * @param i
   *            an index in the value vector
   * @return the freshly computed ith entry in the value vector
   */
  protected double computeValue(int i) {
    double[] values = new double[terms.length()];
    for (int j = 0; j < terms.length(); j++) {
      values[j] = term(j).value();
    }
    double[] results = matrix.multiply(values);
    return results[i];
  }

  /*@Override*/
  protected double computeVelocity(StatsMap weakStats) {
    double[] values = new double[terms.length()];
    for (int i = 0; i < terms.length(); i++) {
      values[i] = term(i).velocity(weakStats);
    }
    double[] results = matrix.multiply(values);
    double result = Double.MAX_VALUE;
    for (int i = 0; i < results.length; i++) {
      result = Math.min(result, results[i]);
    }
    return result;
  }

  /**
   * @param i
   *            an index in the value vector
   * @return the freshly estimated ith entry in the velocity vector
   */
  private double computeVelocity(int i) {
    double[] values = new double[terms.length()];
    for (int j = 0; j < terms.length(); j++) {
      values[j] = term(j).velocity();
    }
    double[] results = matrix.multiply(values);
    return results[i];
  }

  /*@Override*/
  protected double computeNoise(StatsMap weakStats) {
    double[] noises = new double[terms.length()];
    for (int i = 0; i < terms.length(); i++) {
      noises[i] = term(i).noise(weakStats);
    }
    double[] resultNoises = varMatrix.multiply(noises);
    double noise = 0;
    for (int i = 0; i < resultNoises.length; i++) {
      noise = Math.max(noise, resultNoises[i]);
    }
    return noise;
  }

  /**
   * @param i
   *            an index in the value vector
   * @return the freshly estimated ith entry in the noise vector
   */
  private double computeNoise(int i) {
    double[] noises = new double[terms.length()];
    for (int j = 0; j < terms.length(); j++) {
      noises[j] = term(j).noise();
    }
    double[] resultNoises = varMatrix.multiply(noises);
    return resultNoises[i];
  }

  /*@Override*/
  public String toString() {
    String str = "min(";
    boolean nonEmpty = false;
    for (int i = 0; i < matrix.rows(); i++) {
      boolean nonEmptyRow = false;
      for (int j = 0; j < terms.length(); j++) {
        if (matrix.get(i, j) == 0)
          continue;
        if (nonEmptyRow) {
          str += " + ";
        } else if (nonEmpty) {
          str += ", ";
        }
        nonEmptyRow = true;
        str += "(" + term(j) + " * " + matrix.get(i, j) + ")";
      }
      if (nonEmptyRow)
        nonEmpty = true;
    }
    return str + ")@" + getStore().name();
  }

  /*@Override*/
  public DerivedMetric times(double scalar) {
    Metric native[] termsCopy = new Metric native[terms.length()];
    for (int i = 0; i < terms.length(); i++)
      termsCopy[i] = term(i);
    final Store s = getStore();
    return Metric.findDerivedMetric(s,
        new LinearMetric@s().fabric$metrics$LinearMetric$(matrix.multiply(scalar), termsCopy));
  }

  /**
   * {@inheritDoc}
   * <p>
   * {@link LinearMetric}s try to consolidate local computations so that there
   * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
   * {@link #handleUpdates()}.
   */
  /*@Override*/
  public DerivedMetric plus(Metric other) {
    final Store s = getStore();
    if (other instanceof LinearMetric
        && other.$getStore().equals(s)) {
      LinearMetric that = (LinearMetric) other;

      // Get the combined sorted set of terms.
      Set/*<Metric>*/ termsBag = new TreeSet/*<>*/();
      termsBag.addAll(Arrays.asList(this.terms.array()));
      termsBag.addAll(Arrays.asList(that.terms.array()));

      // Expand both matrices to account for terms that metric didn't
      // include.
      Matrix thisExpanded = new Matrix().fabric$metrics$util$Matrix$(this.matrix.rows(),
          termsBag.size());
      Matrix thatExpanded = new Matrix().fabric$metrics$util$Matrix$(that.matrix.rows(),
          termsBag.size());
      Metric native[] newTerms = new Metric native[termsBag.size()];
      int aggIdx = 0;
      int thisIdx = 0;
      int thatIdx = 0;
      Iterator mIter = termsBag.iterator();
      while (mIter.hasNext()) {
        Metric m = (Metric) mIter.next();
        if (this.term(thisIdx).equals(m)) {
          thisExpanded.setColumn(aggIdx,
              this.matrix.getColumn(thisIdx++));
        }
        if (that.term(thatIdx).equals(m)) {
          thatExpanded.setColumn(aggIdx,
              that.matrix.getColumn(thatIdx++));
        }
        newTerms[aggIdx++] = m;
      }

      // Combined to include the sum of all pairs of rows between the two
      // expanded matrices
      Matrix combined = new Matrix().fabric$metrics$util$Matrix$(
          thisExpanded.rows() * thatExpanded.rows(), newTerms.length);
      for (int i = 0; i < thisExpanded.rows(); i++) {
        for (int j = 0; j < thatExpanded.rows(); j++) {
          int row = i * thatExpanded.rows() + j;
          for (int k = 0; k < newTerms.length; k++) {
            combined.set(row, k, thisExpanded.get(i, k)
                + thatExpanded.get(j, k));
          }
        }
      }

      return Metric.findDerivedMetric(s,
          new LinearMetric@s().fabric$metrics$LinearMetric$(combined, newTerms));
    } else if (Arrays.asList(terms.array()).indexOf(other) >= 0) {
      int idx = Arrays.asList(terms.array()).indexOf(other);
      Matrix newCs = matrix.copy();
      for (int i = 0; i < newCs.rows(); i++) {
        newCs.set(i, idx, newCs.get(i, idx) + 1);
      }
      Metric native[] termsCopy = new Metric native[terms.length()];
      for (int i = 0; i < terms.length(); i++)
        termsCopy[i] = term(i);
      return Metric.findDerivedMetric(s,
          new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, termsCopy));
    } else if (isSingleStore() && !other.$getStore().equals(s)) {
      return Metric.findDerivedMetric(s,
          new LinearMetric@s().fabric$metrics$LinearMetric$(Matrix.constant(1, 2, 1), new Metric native[] { this, other }));
    }

    Metric native[] newTerms = new Metric native[terms.length() + 1];
    for (int i = 0; i < terms.length(); i++)
      newTerms[i] = term(i);
    newTerms[terms.length()] = other;
    java.util.Arrays.sort(newTerms, 0, newTerms.length);
    int idx = java.util.Arrays.asList(newTerms).indexOf(other);
    double[] newCol = new double[matrix.rows()];
    for (int i = 0; i < newCol.length; i++) {
      newCol[i] = 1;
    }
    Matrix newCs = matrix.copy();
    newCs.insertColumn(idx, newCol);
    return Metric.findDerivedMetric(s,
        new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, newTerms));
  }

  /**
   * {@inheritDoc}
   * <p>
   * {@link LinearMetric}s try to consolidate local computations so that there
   * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
   * {@link #handleUpdates()}.
   */
  /*@Override*/
  public Metric min(Metric other) {
    final Store s = $getStore();
    if (other instanceof LinearMetric
        && other.$getStore().equals(s)) {
      LinearMetric that = (LinearMetric) other;

      // Get the combined sorted set of terms.
      Set/*<Metric>*/ termsBag = new TreeSet/*<>*/();
      termsBag.addAll(Arrays.asList(this.terms.array()));
      termsBag.addAll(Arrays.asList(that.terms.array()));

      // Expand both matrices to account for terms that metric didn't
      // include.
      Matrix thisExpanded = new Matrix().fabric$metrics$util$Matrix$(this.matrix.rows(), termsBag.size());
      Matrix thatExpanded = new Matrix().fabric$metrics$util$Matrix$(that.matrix.rows(), termsBag.size());
      Metric native[] newTerms = new Metric native[termsBag.size()];
      int aggIdx = 0;
      int thisIdx = 0;
      int thatIdx = 0;
      Iterator mIter = termsBag.iterator();
      while (mIter.hasNext()) {
        Metric m = (Metric) mIter.next();
        if (this.term(thisIdx).equals(m)) {
          thisExpanded.setColumn(aggIdx,
              this.matrix.getColumn(thisIdx++));
        }
        if (that.term(thatIdx).equals(m)) {
          thatExpanded.setColumn(aggIdx,
              that.matrix.getColumn(thatIdx++));
        }
        newTerms[aggIdx++] = m;
      }

      // Combined to include the sum of all pairs of rows between the two
      // expanded matrices
      Matrix combined = new Matrix().fabric$metrics$util$Matrix$(thisExpanded.rows() + thatExpanded.rows(), newTerms.length);
      for (int i = 0; i < thisExpanded.rows(); i++) {
        for (int j = 0; j < newTerms.length; j++) {
          combined.set(i, j, thisExpanded.get(i, j));
          combined.set(i + thisExpanded.rows(), j,
              thatExpanded.get(i, j));
        }
      }

      return Metric.findDerivedMetric(s,
          new LinearMetric@s().fabric$metrics$LinearMetric$(combined, newTerms));
    } else if (Arrays.asList(terms.array()).indexOf(other) >= 0) {
      int idx = Arrays.asList(terms.array()).indexOf(other);
      Matrix newCs = matrix.copy();
      double[] newRow = new double[terms.length()];
      newRow[idx] = 1;
      newCs.addRow(newRow);
      Metric native[] termsCopy = new Metric native[terms.length()];
      for (int i = 0; i < terms.length(); i++)
        termsCopy[i] = term(i);
      return Metric.findDerivedMetric(s,
          new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, termsCopy));
    } else if (isSingleStore() && !other.$getStore().equals(s)) {
      return Metric.findDerivedMetric(s,
          new LinearMetric@s().fabric$metrics$LinearMetric$(Matrix.identity(2), new Metric native[] { this, other }));
    }

    Metric native[] newTerms = new Metric native[terms.length() + 1];
    for (int i = 0; i < terms.length(); i++)
      newTerms[i] = term(i);
    newTerms[terms.length()] = other;
    java.util.Arrays.sort(newTerms, 0, newTerms.length);
    int idx = java.util.Arrays.asList(newTerms).indexOf(other);
    Matrix newCs = matrix.copy();
    newCs.addColumn(new double[matrix.rows()]);
    double[] newRow = new double[terms.length() + 1];
    newRow[idx] = 1;
    newCs.addRow(newRow);
    return Metric.findDerivedMetric(s,
        new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, newTerms));
  }

  /*@Override*/
  public DerivedMetric copyOn(final Store s) {
    Metric native[] termsCopy = new Metric native[terms.length()];
    for (int i = 0; i < terms.length(); i++)
      termsCopy[i] = term(i);
    return Metric.findDerivedMetric(s,
        new LinearMetric@s().fabric$metrics$LinearMetric$(matrix, termsCopy));
  }

  /**
   * XXX/TODO: This is not appropriately "low contention" and still uses
   * strong operations for model parameters.
   */
  /*@Override*/
  public EnforcementPolicy thresholdPolicy(double rate, double base, StatsMap weakStats, final Store str) {
    if (isSingleStore())
      return new DirectPolicy@str().fabric$metrics$contracts$enforcement$DirectPolicy$(this, rate, base);
    Map/*<Metric, Contract>*/ witnesses = new LinkedHashMap/*<>*/();

    long currentTime = System.currentTimeMillis();
    double baseNow = Bound.value(rate, base, currentTime);

    // Defend all rows against the bound individually, using the strictest
    // bounds across the rows for each term in this sum.
    for (int i = 0; i < matrix.rows(); i++) {
      double totalValue = computeValue(i);
      double totalVelocity = computeVelocity(i);
      double totalNoise = computeNoise(i);
      double numTerms = terms.length();

      // For each term, update the associated bounds to be the tightest
      // bound set across the rows
      for (int j = 0; j < numTerms; j++) {
        double c = matrix.get(i, j);
        Metric m = term(j);
        double scaledX = m.value() * c;
        double scaledV = m.velocity() * c;
        double scaledN = m.noise() * c * c;

        // Corrected for the way this metric is shifting relative to the
        // rest of the sum
        double r = scaledV - ((totalVelocity - rate) / numTerms);
        // De-scaled
        r = r / c;

        double b = scaledX
            - ((scaledN / totalNoise) * (totalValue - baseNow));
        // De-scaled
        b = b / c;

        if (c < 0) {
          m = m.times(-1);
          b = -b;
          r = -r;
        }
        double native[] normalized = Bound.createBound(r, b, currentTime);
        if (!witnesses.containsKey(m)
            || !((Contract) witnesses.get(m)).implies(m, normalized[0], normalized[1])) {
          witnesses.put(m, m.getThresholdContract(r, b, currentTime));
        }
      }
    }
    Contract native[] finalWitnesses = new Contract native[witnesses.size()];
    int i = 0;
    for (Iterator iter = witnesses.values().iterator(); iter.hasNext();) {
      finalWitnesses[i++] = (Contract) iter.next();
    }
    return new WitnessPolicy@str().fabric$metrics$contracts$enforcement$WitnessPolicy$(finalWitnesses);
  }

  /*@Override*/
  public int hashCode() {
    int hash = Arrays.hashCode(terms.array()) * 32 + matrix.hashCode();
    return hash * 32 + $getStore().hashCode();
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (other instanceof LinearMetric) {
      LinearMetric that = (LinearMetric) other;
      return this.matrix.equals(that.matrix)
          && Arrays.deepEquals(this.terms.array(), that.terms.array())
          && this.$getStore().equals(that.$getStore());
    }
    return false;
  }
}

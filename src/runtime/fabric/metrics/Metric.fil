package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.HashMap;
import fabric.util.List;
import fabric.util.Set;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.Contract;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.MetricEqualityContract;
import fabric.metrics.contracts.enforcement.DirectEqualityPolicy;
import fabric.metrics.contracts.enforcement.DirectPolicy;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.remote.RemoteWorker;
import fabric.worker.transaction.TransactionManager;
import fabric.lang.security.LabelUtil;

//import java.util.logging.Level;
//import fabric.common.Logging;

/**
 * Abstract class with base implementation of some {@link Metric} methods.
 */
public abstract class Metric extends AbstractSubject
        implements Comparable/*<Metric>*/ {

  ////////////////////////////////////////////////////////////////////////////
  // External (user-facing) API
  ////////////////////////////////////////////////////////////////////////////

  /** @return the current value of the {@link Metric}. */
  public double value() {
    return value(false);
  }

  /** Local cache of times results. */
  //protected transient final HashMap[><Double, DerivedMetric><] timesCache;
  //
  //protected HashMap[><Double, DerivedMetric><] getTimesCache() {
  //  final Store ls = Worker.getWorker().getLocalStore();
  //  if (timesCache == null) {
  //    if (TransactionManager.getInstance().getCurrentLog() == null) {
  //      atomic {
  //        timesCache = new HashMap[><><]@ls().fabric$util$HashMap$();
  //      }
  //    } else {
  //      timesCache = new HashMap[><><]@ls().fabric$util$HashMap$();
  //    }
  //  }
  //  return timesCache;
  //}

  /**
   * @param scalar
   *            a double scalar to scale this metric by
   * @return A {@link Metric} that tracks the scaled value of this
   *         {@link Metric}.
   */
  public DerivedMetric times(double scalar) {
    //Double s = Double.valueOf(scalar);
    //DerivedMetric result = (DerivedMetric) getTimesCache().get(s);
    //if (result == null) {
    //  result = static_times(this, scalar);
    //  if (TransactionManager.getInstance().inTxn()) {
    //    getTimesCache().put(s, result);
    //  } else {
    //    atomic {
    //      getTimesCache().put(s, result);
    //    }
    //  }
    //}
    //return result;
    return static_times(this, scalar);
  }

  private static DerivedMetric static_times(Metric tmp, double scalar) {
    final Store s = tmp.$getStore();
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(scalar, tmp);
    } else {
      atomic {
        val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(scalar, tmp);
      }
    }
    return findDerivedMetric(s, val);
  }

  /** Local cache of sum results. */
  //protected transient final HashMap[><DerivedMetric, DerivedMetric><] plusCache;
  //
  //protected HashMap[><DerivedMetric, DerivedMetric><] getPlusCache() {
  //  final Store ls = Worker.getWorker().getLocalStore();
  //  if (plusCache == null) {
  //    if (TransactionManager.getInstance().getCurrentLog() == null) {
  //      atomic {
  //        plusCache = new HashMap[><><]@ls().fabric$util$HashMap$();
  //      }
  //    } else {
  //      plusCache = new HashMap[><><]@ls().fabric$util$HashMap$();
  //    }
  //  }
  //  return plusCache;
  //}

  /**
   * @param other
   *            another {@link Metric} to add with this {@link Metric}.
   * @return a {@link Metric} that tracks the value of the sum of other and
   *         this.
   */
  public DerivedMetric plus(Metric other) {
    //DerivedMetric result = (DerivedMetric) getPlusCache().get(other);
    //if (result == null) {
    //  result = static_plus(this, other);
    //  if (TransactionManager.getInstance().inTxn()) {
    //    getPlusCache().put(other, result);
    //    other.getPlusCache().put(this, result);
    //  } else {
    //    atomic {
    //      getPlusCache().put(other, result);
    //      other.getPlusCache().put(this, result);
    //    }
    //  }
    //}
    //return result;
    return static_plus(this, other);
  }

  public static DerivedMetric static_plus(Metric tmp, Metric other) {
    // Ugh dumb hack
    if (other instanceof SumMetric)
      return other.plus(tmp);
    final Store s = tmp.$getStore();
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new SumMetric@s().fabric$metrics$SumMetric$(new Metric native[] { tmp, other });
    } else {
      atomic {
        val = new SumMetric@s().fabric$metrics$SumMetric$(new Metric native[] { tmp, other });
      }
    }
    return findDerivedMetric(s, val);
  }

  /** Local cache of min results. */
  //protected transient final HashMap[><DerivedMetric, DerivedMetric><] minCache;
  //
  //protected HashMap[><DerivedMetric, DerivedMetric><] getMinCache() {
  //  final Store ls = Worker.getWorker().getLocalStore();
  //  if (minCache == null) {
  //    if (TransactionManager.getInstance().getCurrentLog() == null) {
  //      atomic {
  //        minCache = new HashMap[><><]@ls().fabric$util$HashMap$();
  //      }
  //    } else {
  //      minCache = new HashMap[><><]@ls().fabric$util$HashMap$();
  //    }
  //  }
  //  return minCache;
  //}

  /**
   * @param other
   *            another {@link Metric} to take the minimum of along with this
   *            {@link Metric}.
   * @return a {@link Metric} that tracks the value of the minimum of this and
   *         the other {@link Metric}.
   */
  public Metric min(Metric other) {
    //Metric result = (Metric) getMinCache().get(other);
    //if (result == null) {
    //  result = static_min(this, other);
    //  if (TransactionManager.getInstance().inTxn()) {
    //    getMinCache().put(other, result);
    //    other.getMinCache().put(this, result);
    //  } else {
    //    atomic {
    //      getMinCache().put(other, result);
    //      other.getMinCache().put(this, result);
    //    }
    //  }
    //}
    //return result;
    return static_min(this, other);
  }

  private static Metric static_min(Metric tmp, Metric other) {
    // Ugh dumb hack
    if (tmp.equals(other))
      return tmp;
    if (other instanceof MinMetric)
      return other.min(tmp);
    final Store s = tmp.$getStore();
    DerivedMetric val = null;
    if (tmp.compareTo(other) > 0) {
      if (TransactionManager.getInstance().inTxn()) {
        val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { other, tmp });
      } else {
        atomic {
          val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { other, tmp });
        }
      }
    } else {
      if (TransactionManager.getInstance().inTxn()) {
        val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { tmp, other });
      } else {
        atomic {
          val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { tmp, other });
        }
      }
    }
    return findDerivedMetric(s, val);
  }

  /**
   * @param other
   *            another {@link Metric} to take the maximum of along with this
   *            {@link Metric}.
   * @return a {@link Metric} that tracks the value of the maximum of this and
   *         the other {@link Metric}.
   */
  public Metric max(Metric other) {
    // TODO: This is not the best approach to this.
    return (this.times(-1).min(other.times(-1))).times(-1);
  }

  /**
   * @param rate
   *            the rate parameter for the {@link Bound} on the resuling
   *            {@link Contract}
   * @param base
   *            the base parameter for the {@link Bound} on the resuling
   *            {@link Contract}
   * @param time
   *            the startTime parameter of the {@link Bound} on the resulting
   *            {@link Contract}
   * @return a {@link Contract} which enforces that the {@link Metric}
   *         satisfies a {@link Bound} with the given parameters at the given
   *         time. If such a {@link Contract} already exists, it is
   *         returned, otherwise a new one is created and returned
   *         (unactivated).
   *
   */
  public Contract getEqualityContract(double value) {
    return static_getEqualityContract(this, value);
  }

  private static Contract static_getEqualityContract(Metric tmp, double value) {
    Contract mc = null;
    if (TransactionManager.getInstance().inTxn()) {
      mc = tmp.createEqualityContract(value);
    } else {
      atomic {
        mc = tmp.createEqualityContract(value);
      }
    }
    return mc;
  }

  /**
   * @param rate
   *            the rate parameter for the {@link Bound} on the resuling
   *            {@link Contract}
   * @param base
   *            the base parameter for the {@link Bound} on the resuling
   *            {@link Contract}
   * @param time
   *            the startTime parameter of the {@link Bound} on the resulting
   *            {@link Contract}
   * @return a {@link Contract} which enforces that the {@link Metric}
   *         satisfies a {@link Bound} with the given parameters at the given
   *         time. If such a {@link Contract} already exists, it is
   *         returned, otherwise a new one is created and returned
   *         (unactivated).
   *
   */
  public Contract getThresholdContract(double rate, double base, long time) {
    return static_getThresholdContract(this, rate, base, time);
  }

  private static Contract static_getThresholdContract(Metric tmp, double rate, double base, long time) {
    Contract mc = null;
    if (TransactionManager.getInstance().inTxn()) {
      mc = tmp.createThresholdContract(rate, base, time);
    } else {
      atomic {
        mc = tmp.createThresholdContract(rate, base, time);
      }
    }
    return mc;
  }

  /**
   * @param rate
   *            the rate parameter for the {@link Bound} on the resuling
   *            {@link Contract}
   * @param base
   *            the base parameter for the {@link Bound} on the resuling
   *            {@link Contract}
   * @return a {@link Contract} which enforces that the {@link Metric}
   *         satisfies a {@link Bound} with the given parameters at the
   *         current time. If such a {@link Contract} already exists, it
   *         is returned, otherwise a new one is created and returned
   *         (unactivated).
   */
  protected Contract getThresholdContract(double rate, double base) {
    return getThresholdContract(rate, base, 0);
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes a scaled value
   * of another {@link Metric}.
   *
   * @param s
   *            the {@link Store} the returned {@link DerivedMetric} will be
   *            stored at
   * @param a
   *        the scaling factor
   * @param term
   *        the {@link Metric}
   * @return the locally tracked {@link DerivedMetric} for the scaled value of
   *       the given {@link Metric}.
   */
  public static Metric scaleAtStore(final Store s, double a, Metric term) {
    if (term.$getStore().equals(s))
      return findDerivedMetric(s, term.times(a));
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(a, term);
    } else {
      atomic {
        val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(a, term);
      }
    }
    return findDerivedMetric(s, val);
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes the sum of
   * other {@link Metric}s.
   *
   * @param s
   *            the {@link Store} the returned {@link DerivedMetric} will be
   *            stored at
   * @param terms
   *            the {@link Metric}s to sum
   * @return the locally tracked {@link DerivedMetric} for the sum of the
   *       terms.
   */
  public static Metric addAtStore(final Store s, Metric native[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Must have at least 1 term!");
    if (terms.length == 1)
      return scaleAtStore(s, 1.0, terms[0]);
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new SumMetric@s().fabric$metrics$SumMetric$(terms);
    } else {
      atomic {
        val = new SumMetric@s().fabric$metrics$SumMetric$(terms);
      }
    }
    return findDerivedMetric(s, val);
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes the minimum of
   * other {@link Metric}s.
   *
   * @param s
   *            the {@link Store} the returned {@link Metric} will be stored
   *            at
   * @param terms
   *        the {@link Metric}s to take the min of
   * @return the locally tracked {@link Metric} for the minimum of the terms.
   */
  public static Metric minAtStore(final Store s, Metric native[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Must have at least 1 term!");
    if (terms.length == 1)
      return scaleAtStore(s, 1.0, terms[0]);
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new MinMetric@s().fabric$metrics$MinMetric$(terms);
    } else {
      atomic {
        val = new MinMetric@s().fabric$metrics$MinMetric$(terms);
      }
    }
    return findDerivedMetric(s, val);
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes the maximum of
   * other {@link Metric}s.
   *
   * @param s
   *            the {@link Store} the returned {@link Metric} will be stored
   *            at
   * @param terms
   *        the {@link Metric}s to take the max of
   * @return the locally tracked {@link Metric} for the maximum of the terms.
   */
  public static Metric maxAtStore(final Store s, Metric native[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Must have at least 1 term!");
    if (terms.length == 1)
      return scaleAtStore(s, 1.0, terms[0]);
    for (int i = 0; i < terms.length; i++) {
      terms[i] = terms[i].times(-1);
    }
    return findDerivedMetric(s, minAtStore(s, terms).times(-1));
  }

  ////////////////////////////////////////////////////////////////////////////
  // Internal API
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Cache of DerivedMetrics using this Metric as a term (helps to break up
   * interning cache to avoid one big map.
   */
  //private final HashMap[><DerivedMetric, DerivedMetric><] transformations;

  // Stuff to allow for preset strategies.
  public abstract boolean getUsePreset();
  public abstract double getPresetR();
  public abstract double getPresetB();
  public abstract double getPresetV();
  public abstract double getPresetN();

  /**
   * @param store
   *            the Store that holds this {@link Metric}
   */
  protected Metric fabric$metrics$Metric$() {
    //contracts = new ArrayList/*<>*/().fabric$util$ArrayList$();
    Label lbl = LabelUtil.noComponents();
    Store s = $getStore();
    this.weakStats = new double[4] ~lbl @s;
    // Use default size since we don't expect most applications to use a ton of
    // different transformations on the same terms.
    //this.transformations = new HashMap().fabric$util$HashMap$(64);
    fabric$metrics$util$AbstractSubject$();
    return this;
  }

  //private final List/*<Contract>*/ contracts;

  /**
   * @param useWeakCache
   *            Flag to indicate if a weakly consistent value should be
   *            returned.  If false, a strongly consistent value is returned.
   * @return the current value of the {@link Metric}.
   */
  public abstract double value(boolean useWeakCache);

  /** @return the number of samples of the {@link Metric}. */
  public double samples() {
    return samples(false);
  }

  /**
   * @param useWeakCache
   *            Flag to indicate if a weakly consistent value should be
   *            returned.  If false, a strongly consistent value is returned.
   * @return the number of samples of the {@link Metric}.
   */
  public abstract double samples(boolean useWeakCache);

  /** @return the estimated velocity of the {@link Metric}. */
  public double velocity() {
    return velocity(false);
  }

  /**
   * @param useWeakCache
   *            Flag to indicate if a weakly consistent value should be
   *            returned.  If false, a strongly consistent value is returned.
   * @return the estimated velocity of the {@link Metric}.
   */
  public abstract double velocity(boolean useWeakCache);

  /** @return the estimated noise of the {@link Metric}. */
  public double noise() {
    return noise(false);
  }

  /**
   * @param useWeakCache
   *            Flag to indicate if a weakly consistent value should be
   *            returned.  If false, a strongly consistent value is returned.
   * @return the estimated velocity of the {@link Metric}.
   */
  public abstract double noise(boolean useWeakCache);

  /**
   * Used to construct and enforce {@link Contract}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param value
   *            the value we're asserting equality with.
   * @param useWeakCache
   *            flag indicating if weakly consistent cached values should be
   *            used
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy equalityPolicy(double value, boolean useWeakCache, final Store s) {
    return new DirectEqualityPolicy@s().fabric$metrics$contracts$enforcement$DirectEqualityPolicy$(this, value);
  }

  /**
   * Used to construct and enforce {@link Contract}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param value
   *            the value we're asserting equality with.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy equalityPolicy(double value, final Store s) {
    // This is only called if we're computing a new policy for a *pre-existing*
    // contract so this is when a coordination occurs in the protocol.
    return equalityPolicy(value, false, s);
  }

  /**
   * Used to construct and enforce {@link Contract}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param bound
   *            a {@link Bound} that the returned policy enforces.
   * @param useWeakCache
   *            flag indicating if weakly consistent cached values should be
   *            used
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy thresholdPolicy(double rate, double base, boolean useWeakCache, final Store s) {
    return new DirectPolicy@s().fabric$metrics$contracts$enforcement$DirectPolicy$(this, rate, base);
  }

  /**
   * Used to construct and enforce {@link Contract}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param bound
   *            a {@link Bound} that the returned policy enforces.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy thresholdPolicy(double rate, double base, final Store s) {
    // This is only called if we're computing a new policy for a *pre-existing*
    // contract so this is when a coordination occurs in the protocol.
    return thresholdPolicy(rate, base, false, s);
  }

  /*
   * Array of the most recently refreshed weak stats (using an Array so it's a
   * separate object for transactions).
   */
  protected final double[] weakStats;

  /**
   * Update the current "weak" estimates to be used by {@link #policy(Bound)}
   */
  public void refreshWeakEstimates() {
    //Logging.METRICS_LOGGER.finest("REFRESHING" + this);
    refreshLocally();
  }

  public void refreshWeakEstimates_remote(fabric.lang.security.Principal caller) {
    refreshWeakEstimates();
  }

  /**
   * Utility to allow for running updates as close to the metric as possible.
   *
   * Ugh, public because we don't allow remote calls for non public methods.
   */
  public void refreshLocally() {
    static_refreshLocally(this);
  }

  private static void static_refreshLocally(Metric tmp) {
    //Logging.METRICS_LOGGER.finest("REFRESHING LOCALLY " + tmp);
    if (TransactionManager.getInstance().inTxn()) {
      tmp.weakStats[0] = tmp.computeValue(true);
      tmp.weakStats[1] = tmp.computeVelocity(true);
      tmp.weakStats[2] = tmp.computeNoise(true);
      tmp.weakStats[3] = tmp.computeSamples(true);
    } else {
      atomic {
        tmp.weakStats[0] = tmp.computeValue(true);
        tmp.weakStats[1] = tmp.computeVelocity(true);
        tmp.weakStats[2] = tmp.computeNoise(true);
        tmp.weakStats[3] = tmp.computeSamples(true);
      }
    }
    //Logging.METRICS_LOGGER.finest("REFRESHED " + tmp + " to " + tmp.weakStats[0]
    //    + ", " + tmp.weakStats[1] + ", " + tmp.weakStats[2]);
  }

  public void refreshLocally_remote(fabric.lang.security.Principal caller) {
    refreshLocally();
  }


  /**
   * @return an estimated (not necessarily consistent) estimate of the
   *         {@link #value()} as captured in the last call to
   *         {@link #refreshWeakEstimates()}.
   */
  protected double weakValue() {
    return weakStats[0];
  }

  /**
   * @return an estimated (not necessarily consistent) estimate of the
   *         {@link #samples()} as captured in the last call to
   *         {@link #refreshWeakEstimates()}.
   */
  protected double weakSamples() {
    return weakStats[3];
  }

  /**
   * @return an estimated (not necessarily consistent) estimate of the
   *         {@link #velocity()} as captured in the last call to
   *         {@link #refreshWeakEstimates()}.
   */
  protected double weakVelocity() {
    return weakStats[1];
  }

  /**
   * @return an estimated (not necessarily consistent) estimate of the
   *         {@link #noise()} as captured in the last call to
   *         {@link #refreshWeakEstimates()}.
   */
  protected double weakNoise() {
    return weakStats[2];
  }

  /**
   * @param useWeakCache
   *            Flag to indicate if weak values should be used.
   * @return a freshly computed weak value for this {@link DerivedMetric}.
   */
  protected abstract double computeValue(boolean useWeakCache);

  /**
   * @param useWeakCache
   *            Flag to indicate if weak values should be used.
   * @return a freshly computed weak value for this {@link DerivedMetric}.
   */
  protected abstract double computeSamples(boolean useWeakCache);

  /**
   * @param useWeakCache
   *            Flag to indicate if weak values should be used.
   * @return a freshly computed weak velocity for this {@link DerivedMetric}.
   */
  protected abstract double computeVelocity(boolean useWeakCache);

  /**
   * @param useWeakCache
   *            Flag to indicate if weak values should be used.
   * @return a freshly computed noise for this {@link DerivedMetric}.
   */
  protected abstract double computeNoise(boolean useWeakCache);

  /**
   * @return true iff all the sampling and transformations on this metric are
   *         stored on a single store.
   */
  public abstract boolean isSingleStore();

  /**
   * @param contract
   *            a {@link Contract} to store with this {@link Metric}
   * @throws IllegalArgumentException
   *             if the {@link Contract} doesn't enforce a {@link Bound}
   *             on this {@link Metric}
   */
  public void addContract(Contract contract) {
    /*
    if (!contract.getMetric().equals(this))
      throw new IllegalArgumentException(
          "Adding a contract for a different metric!");
    if (!contracts.contains(contract))
      atomic {
        contracts.add(contract);
      }
    */
  }

  /**
   * @param bound
   *        the {@link Bound} that the contract will enforce on this
   *        {@link Metric}
   * @return a {@link Contract} asserting this metric satisfies the
   *       given {@link Bound}.
   */
  protected Contract createThresholdContract(double rate, double base, long time) {
    double native[] normalized = Bound.createBound(rate, base, time);
    return new MetricContract().fabric$metrics$contracts$MetricContract$(this, normalized[0], normalized[1]);
  }

  /**
   * @param bound
   *        the {@link Bound} that the contract will enforce on this
   *        {@link Metric}
   * @return a {@link Contract} asserting this metric satisfies the
   *       given {@link Bound}.
   */
  protected Contract createEqualityContract(double value) {
    return new MetricEqualityContract().fabric$metrics$contracts$MetricEqualityContract$(this, value);
  }

  /**
   * @param time
   *        the time we're searching for {@link Contract}s for this
   *        {@link Metric}
   * @return a {@link Set} of {@link Contract}s that are currently
   *       enforced for this {@link Metric}
   */
  //protected List[><Contract><] getContracts(long time) {
  //  atomic {
  //    for (int i = 0; i < contracts.size(); i++) {
  //      Contract c = (Contract) contracts.get(i);
  //      if (c.stale(time)) {
  //        removeObserver(c);
  //        // Contract's removed, shift the index to account (ugh)
  //        i--;
  //      }
  //    }
  //  }
  //  return contracts;
  //}

  /*@Override*/
  public int compareTo(java.lang.Object that) {
    if (!(that instanceof Metric))
      return 0;
    Metric other = (Metric) that;
    int thisHash = hashCode();
    int thatHash = other.hashCode();
    if (thisHash == thatHash) {
      if (other.equals(this)) {
        return 0;
      } else {
        return toString().compareTo(other.toString());
      }
    }
    return thisHash - thatHash;
  }

  /**
   * Utility for removing a contract if it's no longer observing and is now
   * stale.
   *
   * @param contract
   *            a {@link Contract} to stop storing with this
   *            {@link Metric} (if it is now invalid).
   * @throws IllegalArgumentException
   *             if contract isn't defined on this {@link Metric}
   */
  // TODO/XXX: I'm concerned this will cause problems if we are removing
  // when switching between policies?
  private void clearContract(Contract contract) {
    /*
      if (!contract.getMetric().equals(this))
          throw new IllegalArgumentException(
                  "clearing a contract for a different metric!");
      if (contract.stale())
        atomic {
          contracts.remove(contract);
        }
        */
  }

  /**
   * {@inheritDoc}
   *
   * If the {@link Observer} is a {@link Contract} and is now
   * {@link Contract#stale()}, this clears it out from the Metric's stored
   * contract set.
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
      super.removeObserver(obs);
      if (obs instanceof Contract) {
          Contract mc = (Contract) obs;
          clearContract(mc);
      }
  }

  /*
   * TODO: For the static "interning" we should try to avoid creating the
   * metric before looking it up, if possible?
   */

  /**
   * @param s
   *            the {@link Store} we're looking for the given {@link Metric}
   *            on
   * @param m
   *        the transformed metric we're looking up
   * @return the existing equivalent {@link DerivedMetric} tracked by this
   *       {@link Store}, if one exists. Otherwise, starts tracking
   *       <code>m</code> and returns it.
   */
  protected static DerivedMetric findDerivedMetric(final Store s,
      DerivedMetric m) {
    return m;
    //if (TransactionManager.getInstance().inTxn()) {
    //  DerivedMetric orig = (DerivedMetric) m.terms[0].transformations.get(m);
    //  if (orig == null) {
    //    // Probably could just do the first term since AFAIK no derived metrics
    //    // equate between differently ordered terms currently, but tabling that
    //    // for now.
    //    //for (int i = 0; i < m.terms.length; i++) {
    //    //  m.terms[i].transformations.put(m, m);
    //    //}
    //    orig = m;
    //  }
    //  return orig;
    //} else {
    //  DerivedMetric orig = null;
    //  atomic {
    //    orig = (DerivedMetric) m.terms[0].transformations.get(m);
    //    if (orig == null) {
    //      // Probably could just do the first term since AFAIK no derived metrics
    //      // equate between differently ordered terms currently, but tabling that
    //      // for now.
    //      //for (int i = 0; i < m.terms.length; i++) {
    //      //  m.terms[i].transformations.put(m, m);
    //      //}
    //      orig = m;
    //    }
    //  }
    //  return orig;
    //}
  }
}

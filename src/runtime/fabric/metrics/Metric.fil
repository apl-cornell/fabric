package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.HashMap;
import fabric.util.List;
import fabric.util.Set;

import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.metrics.util.TreatiesBox;
import fabric.metrics.treaties.Treaty;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.remote.RemoteWorker;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.metrics.ImmutableObjectSet;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.RunningMetricStats;
import fabric.worker.metrics.proxies.ProxyMap;
import fabric.worker.metrics.treaties.TreatySet;
import fabric.worker.metrics.treaties.enforcement.DirectPolicy;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.statements.EqualityStatement;
import fabric.worker.metrics.treaties.statements.TreatyStatement;
import fabric.worker.metrics.treaties.statements.ThresholdStatement;
import fabric.lang.security.LabelUtil;

import java.util.logging.Level;
import java.util.Iterator;
import java.util.SortedSet;
import java.util.TreeSet;
import fabric.common.Logging;
import fabric.common.util.Pair;

/**
 * Abstract class with base implementation of some {@link Metric} methods.
 */
public abstract class Metric extends AbstractSubject
        implements Comparable/*<Metric>*/ {

  ////////////////////////////////////////////////////////////////////////////
  // External (user-facing) API
  ////////////////////////////////////////////////////////////////////////////

  /** @return the current value of the {@link Metric}. */
  public double value() {
    return value(StatsMap.emptyStats());
  }

  /**
   * @param scalar
   *            a double scalar to scale this metric by
   * @return A {@link Metric} that tracks the scaled value of this
   *         {@link Metric}.
   */
  public DerivedMetric times(double scalar) {
    return static_times(this, scalar);
  }

  private static DerivedMetric static_times(Metric tmp, double scalar) {
    final Store s = tmp.$getStore();
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(scalar, tmp);
    } else {
      atomic {
        val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(scalar, tmp);
      }
    }
    return val;
  }

  /**
   * @param other
   *            another {@link Metric} to add with this {@link Metric}.
   * @return a {@link Metric} that tracks the value of the sum of other and
   *         this.
   */
  public DerivedMetric plus(Metric other) {
    return static_plus(this, other);
  }

  public static DerivedMetric static_plus(Metric tmp, Metric other) {
    // Ugh dumb hack
    if (other instanceof SumMetric)
      return other.plus(tmp);
    final Store s = tmp.$getStore();
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new SumMetric@s().fabric$metrics$SumMetric$(new Metric native[] { tmp, other });
    } else {
      atomic {
        val = new SumMetric@s().fabric$metrics$SumMetric$(new Metric native[] { tmp, other });
      }
    }
    return val;
  }

  /**
   * @param other
   *            another {@link Metric} to take the minimum of along with this
   *            {@link Metric}.
   * @return a {@link Metric} that tracks the value of the minimum of this and
   *         the other {@link Metric}.
   */
  public Metric min(Metric other) {
    return static_min(this, other);
  }

  private static Metric static_min(Metric tmp, Metric other) {
    // Ugh dumb hack
    if (tmp.equals(other))
      return tmp;
    if (other instanceof MinMetric)
      return other.min(tmp);
    final Store s = tmp.$getStore();
    DerivedMetric val = null;
    if (tmp.compareTo(other) > 0) {
      if (TransactionManager.getInstance().inTxn()) {
        val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { other, tmp });
      } else {
        atomic {
          val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { other, tmp });
        }
      }
    } else {
      if (TransactionManager.getInstance().inTxn()) {
        val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { tmp, other });
      } else {
        atomic {
          val = new MinMetric@s().fabric$metrics$MinMetric$(new Metric native[] { tmp, other });
        }
      }
    }
    return val;
  }

  /**
   * @param other
   *            another {@link Metric} to take the maximum of along with this
   *            {@link Metric}.
   * @return a {@link Metric} that tracks the value of the maximum of this and
   *         the other {@link Metric}.
   */
  public Metric max(Metric other) {
    // TODO: This is not the best approach to this.
    return (this.times(-1).min(other.times(-1))).times(-1);
  }

  /**
   * @param rate
   *            the rate parameter for the bound on the resulting
   *            {@link Treaty}
   * @param base
   *            the base parameter for the bound on the resulting
   *            {@link Treaty}
   * @param time
   *            the startTime parameter of the bound on the resulting
   *            {@link Treaty}
   * @return a {@link Treaty} which enforces that the {@link Metric}
   *         satisfies a bound with the given parameters at the given time. If
   *         such a {@link Treaty} already exists, it is returned,
   *         otherwise a new one is created and returned (unactivated).
   */
  public Treaty getEqualityTreaty(double value) {
    return static_getEqualityTreaty(this, value);
  }

  private static Treaty static_getEqualityTreaty(Metric tmp, double value) {
    Treaty mc = null;
    if (TransactionManager.getInstance().inTxn()) {
      mc = tmp.createEqualityTreaty(value);
    } else {
      atomic {
        mc = tmp.createEqualityTreaty(value);
      }
    }
    return mc;
  }

  /**
   * @param rate
   *            the rate parameter for the bound on the resulting
   *            {@link Treaty}
   * @param base
   *            the base parameter for the bound on the resulting
   *            {@link Treaty}
   * @param time
   *            the startTime parameter of the bound on the resulting
   *            {@link Treaty}
   * @return a {@link Treaty} which enforces that the {@link Metric}
   *         satisfies a bound with the given parameters at the given
   *         time. If such a {@link Treaty} already exists, it is
   *         returned, otherwise a new one is created and returned
   *         (unactivated).
   *
   */
  public Treaty getThresholdTreaty(double rate, double base, long time) {
    return static_getThresholdTreaty(this, rate, base, time);
  }

  private static Treaty static_getThresholdTreaty(Metric tmp, double rate, double base, long time) {
    Treaty mc = null;
    if (TransactionManager.getInstance().inTxn()) {
      mc = tmp.createThresholdTreaty(rate, base, time);
    } else {
      atomic {
        mc = tmp.createThresholdTreaty(rate, base, time);
      }
    }
    return mc;
  }

  /**
   * @param rate
   *            the rate parameter for the bound on the resulting
   *            {@link Treaty}
   * @param base
   *            the base parameter for the bound on the resulting
   *            {@link Treaty}
   * @return a {@link Treaty} which enforces that the {@link Metric}
   *         satisfies a bound with the given parameters at the
   *         current time. If such a {@link Treaty} already exists, it
   *         is returned, otherwise a new one is created and returned
   *         (unactivated).
   */
  protected Treaty getThresholdTreaty(double rate, double base) {
    return getThresholdTreaty(rate, base, 0);
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes a scaled value
   * of another {@link Metric}.
   *
   * @param s
   *            the {@link Store} the returned {@link DerivedMetric} will be
   *            stored at
   * @param a
   *        the scaling factor
   * @param term
   *        the {@link Metric}
   * @return the locally tracked {@link DerivedMetric} for the scaled value of
   *       the given {@link Metric}.
   */
  public static Metric scaleAtStore(final Store s, double a, Metric term) {
    if (term.$getStore().equals(s))
      return term.times(a);
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(a, term);
    } else {
      atomic {
        val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(a, term);
      }
    }
    return val;
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes the sum of
   * other {@link Metric}s.
   *
   * @param s
   *            the {@link Store} the returned {@link DerivedMetric} will be
   *            stored at
   * @param terms
   *            the {@link Metric}s to sum
   * @return the locally tracked {@link DerivedMetric} for the sum of the
   *       terms.
   */
  public static Metric addAtStore(final Store s, Metric native[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Must have at least 1 term!");
    if (terms.length == 1)
      return scaleAtStore(s, 1.0, terms[0]);
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new SumMetric@s().fabric$metrics$SumMetric$(terms);
    } else {
      atomic {
        val = new SumMetric@s().fabric$metrics$SumMetric$(terms);
      }
    }
    return val;
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes the minimum of
   * other {@link Metric}s.
   *
   * @param s
   *            the {@link Store} the returned {@link Metric} will be stored
   *            at
   * @param terms
   *        the {@link Metric}s to take the min of
   * @return the locally tracked {@link Metric} for the minimum of the terms.
   */
  public static Metric minAtStore(final Store s, Metric native[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Must have at least 1 term!");
    if (terms.length == 1)
      return scaleAtStore(s, 1.0, terms[0]);
    DerivedMetric val = null;
    if (TransactionManager.getInstance().inTxn()) {
      val = new MinMetric@s().fabric$metrics$MinMetric$(terms);
    } else {
      atomic {
        val = new MinMetric@s().fabric$metrics$MinMetric$(terms);
      }
    }
    return val;
  }

  /**
   * Create a locally tracked {@link DerivedMetric} that takes the maximum of
   * other {@link Metric}s.
   *
   * @param s
   *            the {@link Store} the returned {@link Metric} will be stored
   *            at
   * @param terms
   *        the {@link Metric}s to take the max of
   * @return the locally tracked {@link Metric} for the maximum of the terms.
   */
  public static Metric maxAtStore(final Store s, Metric native[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Must have at least 1 term!");
    if (terms.length == 1)
      return scaleAtStore(s, 1.0, terms[0]);
    for (int i = 0; i < terms.length; i++) {
      terms[i] = terms[i].times(-1);
    }
    return minAtStore(s, terms).times(-1);
  }

  ////////////////////////////////////////////////////////////////////////////
  // Internal API
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Cache of DerivedMetrics using this Metric as a term (helps to break up
   * interning cache to avoid one big map.
   */
  //private final HashMap[><DerivedMetric, DerivedMetric><] transformations;

  // Stuff to allow for preset strategies.
  public abstract boolean getUsePreset();
  public abstract double getPresetR();
  public abstract double getPresetB();
  public abstract double getPresetV();
  public abstract double getPresetN();

  protected ProxyMap/*<Metric>*/ proxies;

  /**
   * @param store
   *            the Store that holds this {@link Metric}
   */
  protected Metric fabric$metrics$Metric$() {
    this.treatiesBox = new TreatiesBox().fabric$metrics$util$TreatiesBox$(this);
    fabric$metrics$util$AbstractSubject$();
    this.proxies = ProxyMap.emptyMap();
    this.$associates = ImmutableObjectSet.emptySet().add(this.treatiesBox);
    return this;
  }

  /**
   * Get a proxy metric for this metric (returns this if the store is the same).
   */
  public Metric getProxy(Store s) {
    if ($getStore().equals(s))
      return this;
    if (this.proxies.containsKey(s))
      return (Metric) this.proxies.get(s);
    Metric result = new ProxyMetric@s().fabric$metrics$ProxyMetric$(this);
    proxies = proxies.put(s, result);
    this.$associates = this.$associates.add(result);
    return result;
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return the current value of the {@link Metric}.
   */
  public abstract double value(StatsMap weakStats);

  /** @return the number of samples of the {@link Metric}. */
  public long samples() {
    return samples(StatsMap.emptyStats());
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return the number of samples of the {@link Metric}.
   */
  public abstract long samples(StatsMap weakStats);

  /** @return the time of the last update of the {@link Metric}. */
  public long lastUpdate() {
    return lastUpdate(StatsMap.emptyStats());
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return the time of the last update of the {@link Metric}.
   */
  public abstract long lastUpdate(StatsMap weakStats);

  /** @return the current updateInterval estimate for updates of {@link Metric}. */
  public double updateInterval() {
    return updateInterval(StatsMap.emptyStats());
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return the updateInterval estimated for updates of the {@link Metric}.
   */
  public abstract double updateInterval(StatsMap weakStats);

  /** @return the estimated velocity of the {@link Metric}. */
  public double velocity() {
    return velocity(StatsMap.emptyStats());
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return the estimated velocity of the {@link Metric}.
   */
  public abstract double velocity(StatsMap weakStats);

  /** @return the estimated noise of the {@link Metric}. */
  public double noise() {
    return noise(StatsMap.emptyStats());
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return the estimated velocity of the {@link Metric}.
   */
  public abstract double noise(StatsMap weakStats);

  /**
   * Used to construct and enforce {@link Treaty}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param value
   *            the value we're asserting equality with.
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy equalityPolicy(double value, StatsMap weakStats, final Store s) {
    return DirectPolicy.singleton;
  }

  /**
   * Used to construct and enforce {@link Treaty}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param value
   *            the value we're asserting equality with.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy equalityPolicy(double value, final Store s) {
    // This is only called if we're computing a new policy for a *pre-existing*
    // treaty so this is when a coordination occurs in the protocol.
    return equalityPolicy(value, StatsMap.emptyStats(), s);
  }

  /**
   * Used to construct and enforce {@link Treaty}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param bound
   *            a bound that the returned policy enforces.
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy thresholdPolicy(double rate, double base, StatsMap weakStats, final Store s) {
    return DirectPolicy.singleton;
  }

  /**
   * Used to construct and enforce {@link Treaty}s bounding this
   * {@link Metric}s value.
   * <p>
   * Implementations of this method should use "weak" estimates of value,
   * velocity, and noise to avoid contention issues. The internal
   * implementation is expected to have refreshed these estimates recently
   * prior to the call.
   *
   * @param bound
   *            a bound that the returned policy enforces.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *         being above bound.
   */
  public EnforcementPolicy thresholdPolicy(double rate, double base, final Store s) {
    // This is only called if we're computing a new policy for a *pre-existing*
    // treaty so this is when a coordination occurs in the protocol.
    return thresholdPolicy(rate, base, StatsMap.emptyStats(), s);
  }

  /**
   * Update the current "weak" estimates to be used by {@link #policy(Bound)}
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   */
  public StatsMap refreshWeakEstimates(StatsMap weakStats) {
    return refreshLocally(weakStats);
  }

  public StatsMap refreshWeakEstimates_remote(fabric.lang.security.Principal caller, StatsMap weakStats) {
    return refreshWeakEstimates(weakStats);
  }

  /**
   * Utility to allow for running updates as close to the metric as possible.
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   *
   * Ugh, public because we don't allow remote calls for non public methods.
   */
  public StatsMap refreshLocally(StatsMap weakStats) {
    return static_refreshLocally(this, weakStats);
  }

  private static StatsMap static_refreshLocally(Metric tmp, StatsMap weakStats) {
    Logging.METRICS_LOGGER.finest("REFRESHING LOCALLY " + tmp + " IN " + TransactionManager.getInstance().getCurrentLog() + " " + Thread.currentThread());
    if (TransactionManager.getInstance().inTxn()) {
      return weakStats.put(tmp,
          tmp.computeValue(weakStats),
          tmp.computeSamples(weakStats),
          tmp.computeLastUpdate(weakStats),
          tmp.computeUpdateInterval(weakStats),
          tmp.computeVelocity(weakStats),
          tmp.computeNoise(weakStats));
    } else {
      StatsMap result = null;
      atomic {
        result = weakStats.put(tmp,
            tmp.computeValue(weakStats),
            tmp.computeSamples(weakStats),
            tmp.computeLastUpdate(weakStats),
            tmp.computeUpdateInterval(weakStats),
            tmp.computeVelocity(weakStats),
            tmp.computeNoise(weakStats));
      }
      return result;
    }
  }

  public StatsMap refreshLocally_remote(fabric.lang.security.Principal caller, StatsMap weakStats) {
    return refreshLocally(weakStats);
  }

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a freshly computed weak value for this {@link DerivedMetric}.
   */
  protected abstract double computeValue(StatsMap weakStats);

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a freshly computed weak value for this {@link DerivedMetric}.
   */
  protected abstract long computeSamples(StatsMap weakStats);

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a freshly computed weak value for this {@link DerivedMetric}.
   */
  protected abstract long computeLastUpdate(StatsMap weakStats);

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a freshly computed weak value for this {@link DerivedMetric}.
   */
  protected abstract double computeUpdateInterval(StatsMap weakStats);

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a freshly computed weak velocity for this {@link DerivedMetric}.
   */
  protected abstract double computeVelocity(StatsMap weakStats);

  /**
   * @param weakStats
   *            StatsMap for mapping metrics to weakly consistent values to use
   *            for metric stats.
   * @return a freshly computed noise for this {@link DerivedMetric}.
   */
  protected abstract double computeNoise(StatsMap weakStats);

  /**
   * @return true iff all the sampling and transformations on this metric are
   *         stored on a single store.
   */
  public abstract boolean isSingleStore();

  public final TreatiesBox treatiesBox;

  /**
   * @return a {@link Treaty} asserting this metric satisfies the
   *       given statement.
   */
  public Treaty createTreaty(TreatyStatement stmt) {
    return createTreaty(stmt, StatsMap.emptyStats());
  }

  public Treaty createTreaty_remote(fabric.lang.security.Principal p, TreatyStatement stmt) {
    return createTreaty(stmt);
  }

  /**
   * @return a {@link Treaty} asserting this metric satisfies the
   *       given statement.
   */
  public Treaty createTreaty(TreatyStatement stmt, StatsMap stats) {
    return createTreaty_static(this, stmt, stats);
  }

  public Treaty createTreaty_remote(fabric.lang.security.Principal p, TreatyStatement stmt, StatsMap stats) {
    return createTreaty(stmt, stats);
  }

  public static Treaty createTreaty_static(Metric tmp, TreatyStatement stmt, StatsMap stats) {
    if (stmt instanceof ThresholdStatement) {
      return createThresholdTreaty_static(tmp, ((ThresholdStatement) stmt).rate(), ((ThresholdStatement) stmt).base(), 0, stats);
    } else if (stmt instanceof EqualityStatement) {
      return createEqualityTreaty_static(tmp, ((EqualityStatement) stmt).value(), stats);
    } else {
      throw new InternalError("Unknown statement type.");
    }
  }

  /**
   * @param bound
   *        the bound that the treaty will enforce on this
   *        {@link Metric}
   * @return a {@link Treaty} asserting this metric satisfies the
   *       given bound.
   */
  public Treaty createThresholdTreaty(double rate, double base, long time) {
    return createThresholdTreaty_static(this, rate, base, time, StatsMap.emptyStats());
  }

  public Treaty createThresholdTreaty_remote(fabric.lang.security.Principal p, double rate, double base, long time) {
    return createThresholdTreaty(rate, base, time);
  }

  /**
   * @param bound
   *        the bound that the treaty will enforce on this
   *        {@link Metric}
   * @return a {@link Treaty} asserting this metric satisfies the
   *       given bound.
   */
  public Treaty createThresholdTreaty(double rate, double base, long time, StatsMap weakStats) {
    return createThresholdTreaty_static(this, rate, base, time, weakStats);
  }

  public Treaty createThresholdTreaty_remote(fabric.lang.security.Principal p, double rate, double base, long time, StatsMap weakStats) {
    return createThresholdTreaty(rate, base, time, weakStats);
  }

  public static Treaty createThresholdTreaty_static(Metric tmp, double rate, double base, long time, StatsMap weakStats) {
    Treaty t = null;
    if (TransactionManager.getInstance().inTxn()) {
      t = tmp.treatiesBox.treaties.create(ThresholdStatement.create(rate, base, time), weakStats);
    } else {
      atomic {
        t = tmp.treatiesBox.treaties.create(ThresholdStatement.create(rate, base, time), weakStats);
      }
    }
    return t;
  }

  /**
   * @param bound
   *        the bound that the treaty will enforce on this
   *        {@link Metric}
   * @return a {@link Treaty} asserting this metric satisfies the
   *       given bound.
   */
  public Treaty createEqualityTreaty(double value) {
    return createEqualityTreaty_static(this, value, StatsMap.emptyStats());
  }

  public Treaty createEqualityTreaty_remote(fabric.lang.security.Principal p, double value) {
    return createEqualityTreaty(value);
  }

  /**
   * @param bound
   *        the bound that the treaty will enforce on this
   *        {@link Metric}
   * @return a {@link Treaty} asserting this metric satisfies the
   *       given bound.
   */
  public Treaty createEqualityTreaty(double value, StatsMap weakStats) {
    return createEqualityTreaty_static(this, value, weakStats);
  }

  public Treaty createEqualityTreaty_remote(fabric.lang.security.Principal p, double value, StatsMap weakStats) {
    return createEqualityTreaty(value, weakStats);
  }

  public static Treaty createEqualityTreaty_static(Metric tmp, double value, StatsMap weakStats) {
    Treaty t = null;
    if (TransactionManager.getInstance().inTxn()) {
      t = tmp.treatiesBox.treaties.create(EqualityStatement.create(value), weakStats);
    } else {
      atomic {
        t = tmp.treatiesBox.treaties.create(EqualityStatement.create(value), weakStats);
      }
    }
    return t;
  }

  /*@Override*/
  public int compareTo(java.lang.Object that) {
    if (!(that instanceof Metric))
      return 0;
    Metric other = (Metric) that;
    int thisHash = hashCode();
    int thatHash = other.hashCode();
    if (thisHash == thatHash) {
      if (other.equals(this)) {
        return 0;
      } else {
        return toString().compareTo(other.toString());
      }
    }
    return thisHash - thatHash;
  }

  /**
   * Create and activate a threshold treaty (purely for
   * updateWithPostcondition), possibly across all proxies of this metric.
   *
   * @param proactive
   *        flag indicating if the treaty should also be proactively established
   *        across all proxies of the metric.
   */
  public void createAndActivateTreaty(TreatyStatement stmt, boolean proactive) {
    if (stmt instanceof ThresholdStatement) {
      double rate = ((ThresholdStatement) stmt).rate();
      double base = ((ThresholdStatement) stmt).base();
      createThresholdTreaty(rate, base, 0);
      if (proactive) {
        for (java.util.Iterator/*<Store, Metric>*/ iter = proxies.entrySet().iterator(); iter.hasNext();) {
          java.util.Map.Entry/*<Store, Metric>*/ entry = (java.util.Map.Entry) iter.next();
          ((Metric) entry.getValue()).createThresholdTreaty(rate, base, 0);
        }
      }
    } else if (stmt instanceof EqualityStatement) {
      double value = ((EqualityStatement) stmt).value();
      createEqualityTreaty(value);
      if (proactive) {
        for (java.util.Iterator/*<Store, Metric>*/ iter = proxies.entrySet().iterator(); iter.hasNext();) {
          java.util.Map.Entry/*<Store, Metric>*/ entry = (java.util.Map.Entry) iter.next();
          ((Metric) entry.getValue()).createEqualityTreaty(value);
        }
      }
    }
  }

  public void assertPostcondition(TreatyStatement stmt) {
    Treaty existing = treatiesBox.treaties.get(stmt);
    if (existing != null  && !existing.invalid()) {
      TransactionManager.getInstance().addTreatiedPostcondition(existing);
    } else {
      TransactionManager.getInstance().addUntreatiedPostcondition(this, stmt);
    }
  }
}

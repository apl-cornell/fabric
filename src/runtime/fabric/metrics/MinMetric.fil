package fabric.metrics;

import java.util.Arrays;
import fabric.util.Set;
import fabric.util.TreeSet;
import fabric.util.Iterator;
import fabric.util.LinkedHashMap;
import fabric.util.Map;

import fabric.metrics.contracts.Bound;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.MetricTreaty;
import fabric.worker.metrics.treaties.enforcement.DirectPolicy;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.enforcement.WitnessPolicy;
import fabric.worker.transaction.TransactionManager;

/**
 * A {@link DerivedMetric} for the minimum of a group of other {@link Metric}s.
 */
public class MinMetric extends DerivedMetric {

    /**
     * @param store
     *            the {@link Store} that holds this {@link Metric}
     * @param terms
     *            The {@link Metric}s this applies to
     */
    public MinMetric fabric$metrics$MinMetric$(Metric native[] terms) {
        fabric$metrics$DerivedMetric$(terms);
        java.util.Set/*<Metric>*/ termsBag = new java.util.TreeSet/*<Metric>*/(Arrays.asList(terms));
        Metric native [] termsA = new Metric native [termsBag.size()];
        int tIdx = 0;
        for (java.util.Iterator it = termsBag.iterator(); it.hasNext();) {
          termsA[tIdx++] = (Metric) it.next();
        }
        this.terms = ImmutableMetricsVector.createVector(termsA);
        initialize();
        return this;
    }

    /*@Override*/
    public double computePresetR() {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length(); i++) {
            result = Math.max(result, term(i).getPresetR());
        }
        return result;
    }

    /*@Override*/
    public double computePresetB() {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length(); i++) {
            result = Math.max(result, term(i).getPresetB());
        }
        return result;
    }

    /*@Override*/
    public double computePresetV() {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length(); i++) {
            result = Math.min(result, term(i).getPresetV());
        }
        return result;
    }

    /*@Override*/
    public double computePresetN() {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length(); i++) {
            result = Math.max(result, term(i).getPresetN());
        }
        return result;
    }

    /*@Override*/
    protected double computeValue(StatsMap weakStats) {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length(); i++) {
          result = Math.min(result, term(i).value(weakStats));
        }
        return result;
    }

    /*@Override*/
    protected double computeVelocity(StatsMap weakStats) {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length(); i++) {
          result = Math.min(result, term(i).velocity(weakStats));
        }
        return result;
    }

    /*@Override*/
    protected double computeNoise(StatsMap weakStats) {
        double noise = 0;
        for (int i = 0; i < terms.length(); i++) {
          noise = Math.max(noise, term(i).noise(weakStats));
        }
        return noise;
    }

    /*@Override*/
    public String toString() {
      String str = "min(";
      boolean nonEmpty = false;
      for (int i = 0; i < terms.length(); i++) {
        if (nonEmpty) {
            str += ", ";
        }
        nonEmpty = true;
        str += term(i);
      }
      return str + ")@" + $getStore();
    }

    /*@Override*/
    public DerivedMetric times(double scalar) {
      //Double s = Double.valueOf(scalar);
      //DerivedMetric result = (DerivedMetric) getTimesCache().get(s);
      //if (result == null) {
      //  result = static_times(this, scalar);
      //  if (TransactionManager.getInstance().inTxn()) {
      //    getTimesCache().put(s, result);
      //  } else {
      //    atomic {
      //      getTimesCache().put(s, result);
      //    }
      //  }
      //}
      //return result;
      return static_times(this, scalar);
    }

    private static DerivedMetric static_times(MinMetric tmp, double scalar) {
        Metric native[] newTerms = new Metric native[tmp.terms.length()];
        for (int i = 0; i < tmp.terms.length(); i++) {
          newTerms[i] = tmp.term(i).times(scalar);
        }
        final Store s = tmp.$getStore();
        DerivedMetric val = null;
        if (TransactionManager.getInstance().inTxn()) {
          val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
        } else {
          atomic {
            val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
          }
        }
        return val;
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link MinMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public DerivedMetric plus(Metric other) {
      //DerivedMetric result = (DerivedMetric) getPlusCache().get(other);
      //if (result == null) {
      //  result = static_plus(this, other);
      //  if (TransactionManager.getInstance().inTxn()) {
      //    getPlusCache().put(other, result);
      //    other.getPlusCache().put(this, result);
      //  } else {
      //    atomic {
      //      getPlusCache().put(other, result);
      //      other.getPlusCache().put(this, result);
      //    }
      //  }
      //}
      //return result;
      return static_plus(this, other);
    }

    private static DerivedMetric static_plus(MinMetric tmp, Metric other) {
        Metric native[] newTerms = new Metric native[tmp.terms.length()];
        for (int i = 0; i < newTerms.length; i++) {
            newTerms[i] = other.plus(tmp.term(i));
        }
        final Store s = tmp.$getStore();
        DerivedMetric val = null;
        if (TransactionManager.getInstance().inTxn()) {
          val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
        } else {
          atomic {
            val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
          }
        }
        return val;
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link MinMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public Metric min(Metric other) {
      //Metric result = (Metric) getMinCache().get(other);
      //if (result == null) {
      //  result = static_min(this, other);
      //  if (TransactionManager.getInstance().inTxn()) {
      //    getMinCache().put(other, result);
      //    other.getMinCache().put(this, result);
      //  } else {
      //    atomic {
      //      getMinCache().put(other, result);
      //      other.getMinCache().put(this, result);
      //    }
      //  }
      //}
      //return result;
      return static_min(this, other);
    }

    private static Metric static_min(MinMetric tmp, Metric other) {
        final Store s = tmp.$getStore();
        DerivedMetric val = null;
        if (other instanceof MinMetric && other.$getStore().equals(s)) {
            MinMetric that = (MinMetric) other;

            // Get the combined sorted set of terms.
            java.util.Set/*<Metric>*/ termsBag = new java.util.TreeSet/*<>*/();
            for (int i = 0; i < tmp.terms.length(); i++) {
              termsBag.add(tmp.term(i));
            }
            for (int i = 0; i < that.terms.length(); i++) {
              termsBag.add(that.term(i));
            }

            Metric native[] newTerms = new Metric native[termsBag.size()];
            int aggIdx = 0;
            for (java.util.Iterator iter = termsBag.iterator(); iter.hasNext();) {
                Metric m = (Metric) iter.next();
                newTerms[aggIdx++] = m;
            }

            if (TransactionManager.getInstance().inTxn()) {
              val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
            } else {
              atomic {
                val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
              }
            }
            return val;
        } else if (Arrays.asList(tmp.terms.array()).indexOf(other) >= 0) {
            return tmp;
        }

        Metric native[] newTerms = new Metric native[tmp.terms.length() + 1];
        for (int i = 0; i < tmp.terms.length(); i++) {
          newTerms[i] = tmp.term(i);
        }
        newTerms[tmp.terms.length()] = other;
        Arrays.sort(newTerms, 0, newTerms.length);
        if (TransactionManager.getInstance().inTxn()) {
          val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
        } else {
          atomic {
            val = new MinMetric@s().fabric$metrics$MinMetric$(newTerms);
          }
        }
        return val;
    }

    /*@Override*/
    public EnforcementPolicy thresholdPolicy(double rate, double base, StatsMap weakStats, final Store s) {
        // Don't do this if we want to avoid conflicts between local concurrent
        // operations on different metrics in a derived metric...
        //if (isSingleStore())
        //    return new DirectPolicy();
        MetricTreaty native[] witnesses = new MetricTreaty native[terms.length()];
        // Defend all rows against the bound individually, using the strictest
        // bounds across the rows for each term in this sum.
        for (int i = 0; i < terms.length(); i++) {
            witnesses[i] = term(i).getThresholdTreaty(rate, base);
        }
        return new WitnessPolicy(witnesses);
    }

    /*@Override*/
    public int hashCode() {
        return Arrays.hashCode(terms.array()) * 32 + $getStore().hashCode();
    }

    /*@Override*/
    public boolean equals(Object other) {
        if (other instanceof MinMetric) {
            MinMetric that = (MinMetric) other;
            return Arrays.deepEquals(this.terms.array(), that.terms.array())
                    && this.$getStore().equals(that.$getStore());
        }
        return false;
    }
}

package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.List;

import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.RunningMetricStats;
import fabric.worker.metrics.StatsMap;

import fabric.common.ConfigProperties;
import fabric.common.exceptions.InternalError;
import fabric.worker.Worker;
import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A {@link Metric} that is directly updated by applications with new sample
 * values to use for its value.
 * <p>
 * In a transaction which has written the value being measured,
 * {@link #takeSample(double,long)} must be called to ensure that
 * {@link Observer}s of this {@link Metric} are aware of the change and the
 * transaction context performs the proper book-keeping.
 */
public class SampledMetric extends Metric {

  private final String name;

  /**
   * @param store
   *            the {@link Store} that holds this {@link Metric}
   * @param name
   *            the name the {@link Store} associates with this
   *            {@link SampledMetric}, so it can be easily retrieved later
   * @param init
   *        the initial value of this {@link Metric}
   */
  public SampledMetric fabric$metrics$SampledMetric$(String name, double init) {
    Label lbl = LabelUtil.noComponents();
    Store s = $getStore();
    this.name = name;
    // TODO: hack, using 1 for initial interval to avoid initial update being
    // very high and leading to high initial variance estimates.
    this.stats = RunningMetricStats.createRunningMetricStats(init, 0, 1);

    // Presets
    ConfigProperties config = Worker.getWorker().config;
    if (getUsePreset()) {
      String key = name + "@" + s.name();
      // XXX Ugh, a hack but to avoid needing to specify all elements for a
      // static-equal run, let's just default for keys that don't exist.
      //if (!config.rates.containsKey(key))
      //  throw new InternalError("Unspecified preset rate for " + key);
      this.presetR = config.rates.containsKey(key) ?
        ((Double) config.rates.get(key)).doubleValue() :
        0.0;
      //if (!config.bounds.containsKey(key))
      //  throw new InternalError("Unspecified preset bound for " + key);
      this.presetB = config.bounds.containsKey(key) ?
        ((Double) config.bounds.get(key)).doubleValue() :
        1.0;
      //if (!config.velocities.containsKey(key))
      //  throw new InternalError("Unspecified preset velocity for " + key);
      this.presetV = config.velocities.containsKey(key) ?
        ((Double) config.velocities.get(key)).doubleValue() :
        0.0;
      //if (!config.noises.containsKey(key))
      //  throw new InternalError("Unspecified preset noise for " + key);
      this.presetN = config.noises.containsKey(key) ?
        ((Double) config.noises.get(key)).doubleValue() :
        0.0;
    } else {
      this.presetR = 0.0;
      this.presetB = 0.0;
      this.presetV = 0.0;
      this.presetN = 0.0;
    }
    fabric$metrics$Metric$();
    return this;
  }

  /*@Override*/
  public boolean getUsePreset() {
    return Worker.getWorker().config.usePreset;
  }

  public final double presetR;
  /*@Override*/
  public double getPresetR() {
    return presetR;
  }

  public final double presetB;
  /*@Override*/
  public double getPresetB() {
    return presetB;
  }

  public final double presetV;
  /*@Override*/
  public double getPresetV() {
    return presetV;
  }

  public final double presetN;
  /*@Override*/
  public double getPresetN() {
    return presetN;
  }

  /**
   * Update to a new value of the metric. The sample is assumed to be taken at
   * the time of the call.
   *
   * @param sample
   *        the value the metric is updating to.
   */
  public void takeSample(double sample) {
    takeSample(sample, System.currentTimeMillis());
  }

  /**
   * Alias for takeSample.
   */
  public void setValue(double value) {
    takeSample(value);
  }

  /**
   * Update to a new value of the metric.
   *
   * @param sample
   *        the value the metric is updating to.
   * @param time
   *        the time the sample occurred.
   */
  public void takeSample(double sample, long time) {
    if (stats.getValue() != sample) {
      updateEstimates(sample, time);
      TransactionManager.getInstance().registerSample(this);
    }
  }

  /*@Override*/
  protected double computeValue(StatsMap weakStats) {
    return static_computeValue(this, weakStats);
  }

  private static double static_computeValue(SampledMetric tmp, StatsMap weakStats) {
    double result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
      if (preloaded != tmp.stats) tmp.stats = preloaded;
      result = tmp.stats.getValue();
    } else {
      atomic {
        RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
        if (preloaded != tmp.stats) tmp.stats = preloaded;
        result = tmp.stats.getValue();
      }
    }
    return result;
  }

  /*@Override*/
  protected long computeSamples(StatsMap weakStats) {
    return static_computeSamples(this, weakStats);
  }

  private static long static_computeSamples(SampledMetric tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.getUsePreset()) {
        return 0;
      } else {
        RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
        if (preloaded != tmp.stats) tmp.stats = preloaded;
        return tmp.stats.getSamples();
      }
    } else {
      long rtn = 0;
      atomic {
        if (tmp.getUsePreset()) {
          rtn = 0;
        } else {
          RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
          if (preloaded != tmp.stats) tmp.stats = preloaded;
          rtn = tmp.stats.getSamples();
        }
      }
      return rtn;
    }
  }

  /*@Override*/
  protected long computeLastUpdate(StatsMap weakStats) {
    return static_computeLastUpdate(this, weakStats);
  }

  private static long static_computeLastUpdate(SampledMetric tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.getUsePreset()) {
        return 0;
      } else {
        RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
        if (preloaded != tmp.stats) tmp.stats = preloaded;
        return tmp.stats.getLastUpdate();
      }
    } else {
      long rtn = 0;
      atomic {
        if (tmp.getUsePreset()) {
          rtn = 0;
        } else {
          RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
          if (preloaded != tmp.stats) tmp.stats = preloaded;
          rtn = tmp.stats.getLastUpdate();
        }
      }
      return rtn;
    }
  }

  /*@Override*/
  protected double computeUpdateInterval(StatsMap weakStats) {
    return static_computeUpdateInterval(this, weakStats);
  }

  private static double static_computeUpdateInterval(SampledMetric tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.getUsePreset()) {
        return 0;
      } else {
        RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
        if (preloaded != tmp.stats) tmp.stats = preloaded;
        return tmp.stats.getIntervalEstimate();
      }
    } else {
      double rtn = 0;
      atomic {
        if (tmp.getUsePreset()) {
          rtn = 0;
        } else {
          RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
          if (preloaded != tmp.stats) tmp.stats = preloaded;
          rtn = tmp.stats.getIntervalEstimate();
        }
      }
      return rtn;
    }
  }

  /*@Override*/
  protected double computeVelocity(StatsMap weakStats) {
    return static_computeVelocity(this, weakStats);
  }

  private static double static_computeVelocity(SampledMetric tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.getUsePreset()) {
        return tmp.presetV;
      } else {
        RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
        if (preloaded != tmp.stats) tmp.stats = preloaded;
        return tmp.stats.getVelocityEstimate();
      }
    } else {
      double rtn = 0;
      atomic {
        if (tmp.getUsePreset()) {
          rtn = tmp.presetV;
        } else {
          RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
          if (preloaded != tmp.stats) tmp.stats = preloaded;
          rtn = tmp.stats.getVelocityEstimate();
        }
      }
      return rtn;
    }
  }

  /*@Override*/
  protected double computeNoise(StatsMap weakStats) {
    return static_computeNoise(this, weakStats);
  }

  private static double static_computeNoise(SampledMetric tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.getUsePreset()) {
        return tmp.presetN;
      } else {
        RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
        if (preloaded != tmp.stats) tmp.stats = preloaded;
        return tmp.stats.getNoiseEstimate();
      }
    } else {
      double rtn = 0;
      atomic {
        if (tmp.getUsePreset()) {
          rtn = tmp.presetN;
        } else {
          RunningMetricStats preloaded = tmp.stats.preload(tmp.name);
          if (preloaded != tmp.stats) tmp.stats = preloaded;
          rtn = tmp.stats.getNoiseEstimate();
        }
      }
      return rtn;
    }
  }

  /*@Override*/
  public String toString() {
    return "SampledMetric(" + name + ")@" + getStore().name();
  }

  /*@Override*/
  public boolean isSingleStore() {
    return true;
  }

  /**
   * The statistics for this metric.
   */
  protected RunningMetricStats stats;

  /**
   * Updates the velocity and interval estimates with the given observation.
   *
   * @param newVal
   *        the new value of the measured quantity
   * @param eventTime
   *        the time, in milliseconds, this update happened
   */
  protected void updateEstimates(double newVal, long eventTime) {
    RunningMetricStats preloaded = stats.preload(name);
    if (preloaded != stats) stats = preloaded;
    stats = stats.update(newVal);
    // Every 1000 samples, print stats in log.
    if (stats.getSamples() % Worker.getWorker().config.metricStatsLogInterval == 0) {
      Logging.METRICS_LOGGER.log(Level.INFO, "STATS {0} {1}",
        new java.lang.Object native[] {
          this,
          this.stats
        });
    }
  }

  /*@Override*/
  public double value(StatsMap weakStats) {
    return static_value(this, weakStats);
  }

  private static double static_value(SampledMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getValue(tmp);
    double result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.computeValue(weakStats);
    } else {
      atomic {
        result = tmp.computeValue(weakStats);
      }
    }
    return result;
  }

  /*@Override*/
  public long samples(StatsMap weakStats) {
    return static_samples(this, weakStats);
  }

  private static long static_samples(SampledMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getSamples(tmp);
    long result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.computeSamples(weakStats);
    } else {
      atomic {
        result = tmp.computeSamples(weakStats);
      }
    }
    return result;
  }

  /*@Override*/
  public long lastUpdate(StatsMap weakStats) {
    return static_lastUpdate(this, weakStats);
  }

  private static long static_lastUpdate(SampledMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getLastUpdate(tmp);
    long result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.computeLastUpdate(weakStats);
    } else {
      atomic {
        result = tmp.computeLastUpdate(weakStats);
      }
    }
    return result;
  }

  /*@Override*/
  public double updateInterval(StatsMap weakStats) {
    return static_updateInterval(this, weakStats);
  }

  private static double static_updateInterval(SampledMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getUpdateInterval(tmp);
    double result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.computeUpdateInterval(weakStats);
    } else {
      atomic {
        result = tmp.computeUpdateInterval(weakStats);
      }
    }
    return result;
  }

  /*@Override*/
  public double velocity(StatsMap weakStats) {
    return static_velocity(this, weakStats);
  }

  private static double static_velocity(SampledMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getVelocity(tmp);
    double result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.computeVelocity(weakStats);
    } else {
      atomic {
        result = tmp.computeVelocity(weakStats);
      }
    }
    return result;
  }

  /*@Override*/
  public double noise(StatsMap weakStats) {
    return static_noise(this, weakStats);
  }

  private static double static_noise(SampledMetric tmp, StatsMap weakStats) {
    if (weakStats.containsKey(tmp)) return weakStats.getNoise(tmp);
    double result = 0;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.computeNoise(weakStats);
    } else {
      atomic {
        result = tmp.computeNoise(weakStats);
      }
    }
    return result;
  }

  /*@Override*/
  public ImmutableObserverSet handleDirectUpdates() {
    // XXX: Does this ever happen?
    throw new InternalError("This should never happen, sampled metrics don't observe anything.");
  }

  /*@Override*/
  public ImmutableMetricsVector getLeafSubjects() {
    return ImmutableMetricsVector.createVector(new Metric native [] { this });
  }
}

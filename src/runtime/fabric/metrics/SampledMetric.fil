package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.List;

import fabric.metrics.util.Observer;
import fabric.metrics.util.RunningStats;

import fabric.common.ConfigProperties;
import fabric.common.exceptions.InternalError;
import fabric.worker.Worker;
import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;

/**
 * A {@link Metric} that is directly updated by applications with new sample
 * values to use for its value.
 * <p>
 * In a transaction which has written the value being measured,
 * {@link #takeSample(double,long)} must be called to ensure that
 * {@link Observer}s of this {@link Metric} are aware of the change and the
 * transaction context performs the proper book-keeping.
 */
public class SampledMetric extends Metric {

  private final String name;

  /**
   * @param store
   *            the {@link Store} that holds this {@link Metric}
   * @param name
   *            the name the {@link Store} associates with this
   *            {@link SampledMetric}, so it can be easily retrieved later
   * @param init
   *        the initial value of this {@link Metric}
   */
  public SampledMetric fabric$metrics$SampledMetric$(String name, double init) {
    Label lbl = LabelUtil.noComponents();
    Store s = $getStore();
    this.name = name;
    this.value = new double[1] ~lbl @s;
    this.value[0] = init;
    this.samples = new long[1] ~lbl @s;
    this.samples[0] = 1;
    this.lastUpdate = new long[1] ~lbl @s;
    this.lastUpdate[0] = System.currentTimeMillis() - 1;
    this.biasStats = new RunningStats().fabric$metrics$util$RunningStats$(0);
    // TODO: hack, to avoid initial update being very high and leading to high
    // initial variance estimates.
    this.updateIntervalStats = new RunningStats().fabric$metrics$util$RunningStats$(1);
    //this.allStats = new RunningStats().fabric$metrics$util$RunningStats$(0);

    // Presets
    ConfigProperties config = Worker.getWorker().config;
    this.usePreset = config.usePreset;
    if (this.usePreset) {
      String key = name + "@" + s.name();
      if (!config.rates.containsKey(key))
        throw new InternalError("Unspecified preset rate for " + key);
      this.presetR = ((Double) config.rates.get(key)).doubleValue();
      if (!config.bounds.containsKey(key))
        throw new InternalError("Unspecified preset bound for " + key);
      this.presetB = ((Double) config.bounds.get(key)).doubleValue();
      if (!config.velocities.containsKey(key))
        throw new InternalError("Unspecified preset velocity for " + key);
      this.presetV = ((Double) config.velocities.get(key)).doubleValue();
      if (!config.noises.containsKey(key))
        throw new InternalError("Unspecified preset noise for " + key);
      this.presetN = ((Double) config.noises.get(key)).doubleValue();
    } else {
      this.presetR = 0.0;
      this.presetB = 0.0;
      this.presetV = 0.0;
      this.presetN = 0.0;
    }
    fabric$metrics$Metric$();
    return this;
  }

  // Stuff to allow for preset strategies.
  public final boolean usePreset;
  /*@Override*/
  public boolean getUsePreset() {
    return usePreset;
  }

  public final double presetR;
  /*@Override*/
  public double getPresetR() {
    return presetR;
  }

  public final double presetB;
  /*@Override*/
  public double getPresetB() {
    return presetB;
  }

  public final double presetV;
  /*@Override*/
  public double getPresetV() {
    return presetV;
  }

  public final double presetN;
  /*@Override*/
  public double getPresetN() {
    return presetN;
  }

  /**
   * Update to a new value of the metric. The sample is assumed to be taken at
   * the time of the call.
   *
   * @param sample
   *        the value the metric is updating to.
   */
  public void takeSample(double sample) {
    takeSample(sample, System.currentTimeMillis());
  }

  /**
   * Update to a new value of the metric.
   *
   * @param sample
   *        the value the metric is updating to.
   * @param time
   *        the time the sample occurred.
   */
  public void takeSample(double sample, long time) {
    if (value[0] != sample) {
      updateEstimates(sample, time);
      TransactionManager.getInstance().registerSample(this);
    }
  }

  /*@Override*/
  protected double computeValue(boolean useWeakCache) {
    return static_computeValue(this, useWeakCache);
  }

  private static double static_computeValue(SampledMetric tmp, boolean useWeakCache) {
    double result = 0;
    atomic {
      tmp.value[0] = tmp.value[0];
      result = tmp.value[0];
    }
    return result;
  }

  /*@Override*/
  protected double computeSamples(boolean useWeakCache) {
    return static_computeSamples(this, useWeakCache);
  }

  private static double static_computeSamples(SampledMetric tmp, boolean useWeakCache) {
    atomic {
      if (tmp.usePreset) {
        return 0;
      } else {
        return tmp.samples[0];
      }
    }
  }

  /*@Override*/
  protected double computeVelocity(boolean useWeakCache) {
    return static_computeVelocity(this, useWeakCache);
  }

  private static double static_computeVelocity(SampledMetric tmp, boolean useWeakCache) {
    atomic {
      if (tmp.usePreset) {
        return tmp.presetV;
      } else {
        // Account for time that's passed since last observation.
        long intervalSince = (System.currentTimeMillis() - tmp.lastUpdate[0]);
        double curInterval = tmp.updateIntervalStats.getMean();
        double curBias = tmp.biasStats.getMean();
        double newInterval = curInterval;
        double newBias = curBias;
        if (intervalSince > 0) {
            newInterval = (curInterval + RunningStats.ALPHA * (intervalSince - curInterval));
            newBias = (curBias * (1.0 - RunningStats.ALPHA));
        }
        // return allStats.getMean();
        //return biasStats.getMean() / updateIntervalStats.getMean();
        return newBias / newInterval;
      }
    }
  }

  /*@Override*/
  protected double computeNoise(boolean useWeakCache) {
    return static_computeNoise(this, useWeakCache);
  }

  private static double static_computeNoise(SampledMetric tmp, boolean useWeakCache) {
    atomic {
      if (tmp.usePreset) {
        return tmp.presetN;
      } else {
        // Based on ratio estimator approach and assuming that there's 0
        // covariance between update intervals and update values
        // Account for time that's passed since last observation.
        long intervalSince = (System.currentTimeMillis() - tmp.lastUpdate[0]);
        double curInterval = tmp.updateIntervalStats.getMean();
        double curBias = tmp.biasStats.getMean();
        double curBiasVar = tmp.biasStats.getVar();
        double newInterval = curInterval;
        double newBias = curBias;
        double newBiasVar = curBiasVar;
        if (intervalSince > 0) {
          newInterval = (curInterval + RunningStats.ALPHA * (intervalSince - curInterval));
          newBias = (curBias * (1.0 - RunningStats.ALPHA));
          newBiasVar = (1.0 - RunningStats.ALPHA) * curBiasVar + RunningStats.ALPHA * (curBias * newBias);
        }
        //double tSqrd = updateIntervalStats.getMean() * updateIntervalStats.getMean();
        double tSqrd = newInterval * newInterval;
        // We're assuming exponential distribution of the times and here we get
        // the variance of the product of independent poisson (1/exp) and
        // normally distributed variables.
        // return allStats.getVar();
        //return (1 / updateIntervalStats.getMean() + biasStats.getVar() / tSqrd);
        return (1 / newInterval + newBiasVar / tSqrd);
      }
    }
  }

  /*@Override*/
  public String toString() {
    return "SampledMetric(" + name + ")@" + getStore().name();
  }

  /*@Override*/
  public boolean isSingleStore() {
    return true;
  }

  /**
   * The current measurement. (Stored as an array to avoid unnecessary
   * conflicts.)
   */
  protected final double[] value;

  /**
   * The current number of samples. (Stored as an array to avoid unnecessary
   * conflicts.)
   */
  protected final long[] samples;

  /**
   * The time of the last update to this measure, in milliseconds since the
   * UNIX epoch. (Stored as an array to avoid unnecessary conflicts.)
   */
  protected final long[] lastUpdate;

  /**
   * The statistics of update magnitudes for this measure. This is computed as
   * an exponentially weighted moving average.
   */
  protected final RunningStats biasStats;

  /**
   * The estimated time interval between updates, in milliseconds. This is
   * computed as an exponentially weighted moving average.
   */
  protected final RunningStats updateIntervalStats;

  /**
   * Updates the velocity and interval estimates with the given observation.
   *
   * @param newVal
   *        the new value of the measured quantity
   * @param eventTime
   *        the time, in milliseconds, this update happened
   */
  protected void updateEstimates(double newVal, long eventTime) {
    biasStats.update(newVal - value[0]);
    updateIntervalStats.update(eventTime - lastUpdate[0]);
    lastUpdate[0] = eventTime;
    value[0] = newVal;
  }

  /*@Override*/
  public double value(boolean useWeakCache) {
    return static_value(this, useWeakCache);
  }

  private static double static_value(SampledMetric tmp, boolean useWeakCache) {
    double result = 0;
    atomic {
      if (useWeakCache) result = tmp.weakStats[0];
      else result = tmp.computeValue(false);
    }
    return result;
  }

  /*@Override*/
  public double samples(boolean useWeakCache) {
    return static_samples(this, useWeakCache);
  }

  private static double static_samples(SampledMetric tmp, boolean useWeakCache) {
    double result = 0;
    atomic {
      if (useWeakCache) result = tmp.weakStats[3];
      else result = tmp.computeSamples(false);
    }
    return result;
  }

  /*@Override*/
  public double velocity(boolean useWeakCache) {
    return static_velocity(this, useWeakCache);
  }

  private static double static_velocity(SampledMetric tmp, boolean useWeakCache) {
    double result = 0;
    atomic {
      if (useWeakCache) result = tmp.weakStats[1];
      else result = tmp.computeVelocity(false);
    }
    return result;
  }

  /*@Override*/
  public double noise(boolean useWeakCache) {
    return static_noise(this, useWeakCache);
  }

  private static double static_noise(SampledMetric tmp, boolean useWeakCache) {
    double result = 0;
    atomic {
      if (useWeakCache) result = tmp.weakStats[2];
      else result = tmp.computeNoise(false);
    }
    return result;
  }
}

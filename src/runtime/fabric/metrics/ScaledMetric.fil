package fabric.metrics;

import fabric.util.Arrays;
import fabric.util.Iterator;
import fabric.util.LinkedHashMap;
import fabric.util.Map;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.DirectPolicy;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;

/**
 * A {@link DerivedMetric} for the scaled value of a given metric.
 */
public class ScaledMetric extends DerivedMetric {

    /** The scalar coefficient */
    protected final double scalar;

    /**
     * @param store
     *            the {@link Store} that holds this {@link Metric}
     * @param scalar
     *            The coefficient as a double
     * @param term
     *            The {@link Metric} this applies to
     */
    public ScaledMetric fabric$metrics$ScaledMetric$(double scalar, Metric term) {
        this.scalar = scalar;
        fabric$metrics$DerivedMetric$(new Metric native[] { term });
        initialize();
        return this;
    }

    /*@Override*/
    public double computePresetR() {
        return scalar * terms[0].getPresetR();
    }

    /*@Override*/
    public double computePresetB() {
        return scalar * terms[0].getPresetB();
    }

    /*@Override*/
    public double computePresetV() {
        return scalar * terms[0].getPresetV();
    }

    /*@Override*/
    public double computePresetN() {
        return scalar * scalar * terms[0].getPresetN();
    }

    /*@Override*/
    protected double computeValue(boolean useWeakCache) {
        return scalar * terms[0].value(useWeakCache);
    }

    /*@Override*/
    protected double computeVelocity(boolean useWeakCache) {
        return scalar * terms[0].velocity(useWeakCache);
    }

    /*@Override*/
    protected double computeNoise(boolean useWeakCache) {
        return scalar * scalar * terms[0].noise(useWeakCache);
    }

    /*@Override*/
    public String toString() {
        return "(" + scalar + "*" + terms[0] + ")@" + getStore();
    }

    /*@Override*/
    public DerivedMetric times(double otherScalar) {
      return static_times(this, otherScalar);
    }

    private static DerivedMetric static_times(ScaledMetric tmp, double otherScalar) {
        final Store s = tmp.$getStore();
        DerivedMetric val = null;
        atomic {
          val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(otherScalar * tmp.scalar, tmp.terms[0]);
        }
        return Metric.findDerivedMetric(s, val);
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link ScaledMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public DerivedMetric plus(Metric other) {
      return static_plus(this, other);
    }

    private static DerivedMetric static_plus(ScaledMetric tmp, Metric other) {
        final Store s = tmp.$getStore();
        if (other instanceof ScaledMetric && other.$getStore().equals(s)
                && ((ScaledMetric) other).terms[0].equals(tmp.terms[0])) {
            ScaledMetric that = (ScaledMetric) other;

            DerivedMetric val = null;
            atomic {
              val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(
                  that.scalar + tmp.scalar, tmp.terms[0]);
            }
            return Metric.findDerivedMetric(s, val);
        }
        return Metric.static_plus(tmp, other);
    }

    /*@Override*/
    public EnforcementPolicy policy(Bound bound, boolean useWeakCache) {
        if (isSingleStore())
            return new DirectPolicy().fabric$metrics$contracts$enforcement$DirectPolicy$(this, bound);

        MetricContract witness = null;

        long currentTime = System.currentTimeMillis();
        double base = bound.value(currentTime);
        double rate = bound.rate;

        // Defend all rows against the bound individually, using the strictest
        // bounds across the rows for each term in this sum.
        Metric m = term(0);

        // De-scaled
        rate = rate / scalar;

        // De-scaled
        base = base / scalar;

        if (scalar < 0) {
            // TODO: this doesn't behave well and typically will create an
            // infinite loop.
            m = m.times(-1);
            base = -base;
            rate = -rate;
        }
        Bound witnessBound = new Bound().fabric$metrics$contracts$Bound$(rate, base, currentTime);
        witness = m.getContract(witnessBound);
        final Store bndStore = bound.getStore();
        return new WitnessPolicy@bndStore().fabric$metrics$contracts$enforcement$WitnessPolicy$(new MetricContract native[] { witness });
    }

    /*@Override*/
    public int hashCode() {
        return Arrays.hashCode(terms) * 32 + Double.hashCode(scalar);
    }

    /*@Override*/
    public boolean equals(Object other) {
        if (other instanceof ScaledMetric) {
            ScaledMetric that = (ScaledMetric) other;
            return this.scalar == that.scalar
                    && Arrays.deepEquals(this.terms, that.terms)
                    && this.$getStore().equals(that.$getStore());
        }
        return false;
    }
}

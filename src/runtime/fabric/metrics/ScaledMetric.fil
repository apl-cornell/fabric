package fabric.metrics;

import fabric.util.Arrays;
import fabric.util.Iterator;
import fabric.util.LinkedHashMap;
import fabric.util.Map;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.DirectPolicy;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;

/**
 * A {@link DerivedMetric} for the scaled value of a given metric.
 */
public class ScaledMetric extends DerivedMetric {

    /** The scalar coefficient */
    protected final double scalar;

    /**
     * @param store
     *            the {@link Store} that holds this {@link Metric}
     * @param scalar
     *            The coefficient as a double
     * @param term
     *            The {@link Metric} this applies to
     */
    public ScaledMetric fabric$metrics$ScaledMetric$(double scalar, Metric term) {
        this.scalar = scalar;
        fabric$metrics$DerivedMetric$(new Metric native[] { term });
        initialize();
        return this;
    }

    /*@Override*/
    public double computePresetR() {
        return scalar * terms[0].getPresetR();
    }

    /*@Override*/
    public double computePresetB() {
        return scalar * terms[0].getPresetB();
    }

    /*@Override*/
    public double computePresetV() {
        return scalar * terms[0].getPresetV();
    }

    /*@Override*/
    public double computePresetN() {
        return scalar * scalar * terms[0].getPresetN();
    }

    /*@Override*/
    protected double computeValue(boolean useWeakCache) {
        return scalar * terms[0].value(useWeakCache);
    }

    /*@Override*/
    protected double computeVelocity(boolean useWeakCache) {
        return scalar * terms[0].velocity(useWeakCache);
    }

    /*@Override*/
    protected double computeNoise(boolean useWeakCache) {
        return scalar * scalar * terms[0].noise(useWeakCache);
    }

    /*@Override*/
    public String toString() {
        return "(" + scalar + "*" + terms[0] + ")@" + getStore();
    }

    /*@Override*/
    public DerivedMetric times(double otherScalar) {
      Double s = Double.valueOf(otherScalar);
      DerivedMetric result = (DerivedMetric) getTimesCache().get(s);
      if (result == null) {
        result = static_times(this, otherScalar);
        if (TransactionManager.getInstance().inTxn()) {
          getTimesCache().put(s, result);
        } else {
          atomic {
            getTimesCache().put(s, result);
          }
        }
      }
      return result;
    }

    private static DerivedMetric static_times(ScaledMetric tmp, double otherScalar) {
        final Store s = tmp.$getStore();
        DerivedMetric val = null;
        if (TransactionManager.getInstance().inTxn()) {
          val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(otherScalar * tmp.scalar, tmp.terms[0]);
        } else {
          atomic {
            val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(otherScalar * tmp.scalar, tmp.terms[0]);
          }
        }
        return Metric.findDerivedMetric(s, val);
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link ScaledMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public DerivedMetric plus(Metric other) {
      DerivedMetric result = (DerivedMetric) getPlusCache().get(other);
      if (result == null) {
        result = static_plus(this, other);
        if (TransactionManager.getInstance().inTxn()) {
          getPlusCache().put(other, result);
          other.getPlusCache().put(this, result);
        } else {
          atomic {
            getPlusCache().put(other, result);
            other.getPlusCache().put(this, result);
          }
        }
      }
      return result;
    }

    private static DerivedMetric static_plus(ScaledMetric tmp, Metric other) {
        final Store s = tmp.$getStore();
        if (other instanceof ScaledMetric && other.$getStore().equals(s)
                && ((ScaledMetric) other).terms[0].equals(tmp.terms[0])) {
            ScaledMetric that = (ScaledMetric) other;

            DerivedMetric val = null;
            if (TransactionManager.getInstance().inTxn()) {
              val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(
                  that.scalar + tmp.scalar, tmp.terms[0]);
            } else {
              atomic {
                val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(
                    that.scalar + tmp.scalar, tmp.terms[0]);
              }
            }
            return Metric.findDerivedMetric(s, val);
        }
        return Metric.static_plus(tmp, other);
    }

    /*@Override*/
    public EnforcementPolicy policy(Bound bound, boolean useWeakCache) {
        // Don't do this if we want to avoid conflicts between local concurrent
        // operations on different metrics in a derived metric...
        //if (isSingleStore())
        //    return new DirectPolicy().fabric$metrics$contracts$enforcement$DirectPolicy$(this, bound);

        // However, we don't want the infinite loop referred to below, so we
        // don't use a witness if the metric this transforms is a sampled
        // metric.
        if (term(0) instanceof SampledMetric)
            return new DirectPolicy().fabric$metrics$contracts$enforcement$DirectPolicy$(this, bound);

        MetricContract witness = null;

        long currentTime = System.currentTimeMillis();
        double base = bound.value(currentTime);
        double rate = bound.rate;

        // Defend all rows against the bound individually, using the strictest
        // bounds across the rows for each term in this sum.
        Metric m = term(0);

        // De-scaled
        rate = rate / scalar;

        // De-scaled
        base = base / scalar;

        if (scalar < 0) {
            // TODO: this doesn't behave well and typically will create an
            // infinite loop.
            m = m.times(-1);
            base = -base;
            rate = -rate;
        }
        Bound witnessBound = new Bound().fabric$metrics$contracts$Bound$(rate, base, currentTime);
        witness = m.getContract(witnessBound);
        final Store bndStore = bound.getStore();
        return new WitnessPolicy@bndStore().fabric$metrics$contracts$enforcement$WitnessPolicy$(new MetricContract native[] { witness });
    }

    /*@Override*/
    public int hashCode() {
        return Arrays.hashCode(terms) * 32 + Double.hashCode(scalar);
    }

    /*@Override*/
    public boolean equals(Object other) {
        if (other instanceof ScaledMetric) {
            ScaledMetric that = (ScaledMetric) other;
            return this.scalar == that.scalar
                    && Arrays.deepEquals(this.terms, that.terms)
                    && this.$getStore().equals(that.$getStore());
        }
        return false;
    }
}

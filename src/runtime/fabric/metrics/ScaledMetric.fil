package fabric.metrics;

import java.util.Arrays;
import fabric.util.Iterator;
import fabric.util.LinkedHashMap;
import fabric.util.Map;

import fabric.metrics.contracts.Bound;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.MetricTreaty;
import fabric.worker.metrics.treaties.enforcement.DirectPolicy;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.enforcement.WitnessPolicy;

/**
 * A {@link DerivedMetric} for the scaled value of a given metric.
 */
public class ScaledMetric extends DerivedMetric {

    /** The scalar coefficient */
    protected final double scalar;

    /**
     * @param store
     *            the {@link Store} that holds this {@link Metric}
     * @param scalar
     *            The coefficient as a double
     * @param term
     *            The {@link Metric} this applies to
     */
    public ScaledMetric fabric$metrics$ScaledMetric$(double scalar, Metric term) {
        this.scalar = scalar;
        fabric$metrics$DerivedMetric$(new Metric native[] { term });
        initialize();
        return this;
    }

    /*@Override*/
    public double computePresetR() {
        return scalar * term(0).getPresetR();
    }

    /*@Override*/
    public double computePresetB() {
        return scalar * term(0).getPresetB();
    }

    /*@Override*/
    public double computePresetV() {
        return scalar * term(0).getPresetV();
    }

    /*@Override*/
    public double computePresetN() {
        return scalar * scalar * term(0).getPresetN();
    }

    /*@Override*/
    protected double computeValue(StatsMap weakStats) {
      return scalar * term(0).value(weakStats);
    }

    /*@Override*/
    protected double computeVelocity(StatsMap weakStats) {
      return scalar * term(0).velocity(weakStats);
    }

    /*@Override*/
    protected double computeNoise(StatsMap weakStats) {
      return scalar * scalar * term(0).noise(weakStats);
    }

    /*@Override*/
    public String toString() {
        return "(" + scalar + "*" + term(0) + ")@" + getStore();
    }

    /*@Override*/
    public DerivedMetric times(double otherScalar) {
      //Double s = Double.valueOf(otherScalar);
      //DerivedMetric result = (DerivedMetric) getTimesCache().get(s);
      //if (result == null) {
      //  result = static_times(this, otherScalar);
      //  if (TransactionManager.getInstance().inTxn()) {
      //    getTimesCache().put(s, result);
      //  } else {
      //    atomic {
      //      getTimesCache().put(s, result);
      //    }
      //  }
      //}
      //return result;
      return static_times(this, otherScalar);
    }

    private static DerivedMetric static_times(ScaledMetric tmp, double otherScalar) {
        final Store s = tmp.$getStore();
        DerivedMetric val = null;
        if (TransactionManager.getInstance().inTxn()) {
          val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(otherScalar * tmp.scalar, tmp.term(0));
        } else {
          atomic {
            val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(otherScalar * tmp.scalar, tmp.term(0));
          }
        }
        return val;
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link ScaledMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public DerivedMetric plus(Metric other) {
      //DerivedMetric result = (DerivedMetric) getPlusCache().get(other);
      //if (result == null) {
      //  result = static_plus(this, other);
      //  if (TransactionManager.getInstance().inTxn()) {
      //    getPlusCache().put(other, result);
      //    other.getPlusCache().put(this, result);
      //  } else {
      //    atomic {
      //      getPlusCache().put(other, result);
      //      other.getPlusCache().put(this, result);
      //    }
      //  }
      //}
      //return result;
      return static_plus(this, other);
    }

    private static DerivedMetric static_plus(ScaledMetric tmp, Metric other) {
        final Store s = tmp.$getStore();
        if (other instanceof ScaledMetric && other.$getStore().equals(s)
                && ((ScaledMetric) other).term(0).equals(tmp.term(0))) {
            ScaledMetric that = (ScaledMetric) other;

            DerivedMetric val = null;
            if (TransactionManager.getInstance().inTxn()) {
              val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(
                  that.scalar + tmp.scalar, tmp.term(0));
            } else {
              atomic {
                val = new ScaledMetric@s().fabric$metrics$ScaledMetric$(
                    that.scalar + tmp.scalar, tmp.term(0));
              }
            }
            return val;
        }
        return Metric.static_plus(tmp, other);
    }

    /*@Override*/
    public EnforcementPolicy thresholdPolicy(double rate, double base, StatsMap weakStats, final Store s) {
        // Don't do this if we want to avoid conflicts between local concurrent
        // operations on different metrics in a derived metric...
        //if (isSingleStore())
        //    return DirectPolicy.singleton;

        // However, we don't want the infinite loop referred to below, so we
        // don't use a witness if the metric this transforms is a sampled
        // metric.
        if (term(0) instanceof SampledMetric)
            return DirectPolicy.singleton;

        MetricTreaty witness = null;

        long currentTime = System.currentTimeMillis();
        double baseNow = Bound.value(rate, base, currentTime);

        // Defend all rows against the bound individually, using the strictest
        // bounds across the rows for each term in this sum.
        Metric m = term(0);

        // De-scaled
        rate = rate / scalar;

        // De-scaled
        baseNow = baseNow / scalar;

        if (scalar < 0) {
            // TODO: this doesn't behave well and typically will create an
            // infinite loop.
            m = m.times(-1);
            baseNow = -baseNow;
            rate = -rate;
        }
        witness = m.getThresholdTreaty(rate, baseNow, currentTime);
        return new WitnessPolicy(new MetricTreaty native[] { witness });
    }

    /*@Override*/
    public int hashCode() {
        return Arrays.hashCode(terms.array()) * 32 + Double.hashCode(scalar);
    }

    /*@Override*/
    public boolean equals(Object other) {
        if (other instanceof ScaledMetric) {
            ScaledMetric that = (ScaledMetric) other;
            return this.scalar == that.scalar
                    && Arrays.deepEquals(this.terms.array(), that.terms.array())
                    && this.$getStore().equals(that.$getStore());
        }
        return false;
    }
}

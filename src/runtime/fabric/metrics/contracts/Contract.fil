package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.contracts.warranties.WarrantyComp;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.metrics.util.ReconfigLock;
import fabric.metrics.util.Subject;
import fabric.util.ArrayList;
import java.util.Iterator;
import fabric.util.List;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A {@link Contract} represents an assertion that is enforced until an
 * expiration time, once {@link #refresh()}ed. If the current time is earlier
 * than the expiration time and the {@link Contract} {@link #isActivated()},
 * then the {@link Contract} is <i>valid</i>: the enforcement protocol
 * implemented by the API will ensure the assertion holds.
 * <p>
 * This class follows the {@link Subject}-{@link Observer} pattern. An instance
 * can be an observer of a {@link Metric} or other {@link Contract}s, and can be
 * observed by {@link WarrantyComp}s or other {@link Contract}s.
 * <p>
 * TODO: right now all the uses of expiry assume that the check is for a time
 * after the time the {@link Contract} was created. Some of these operations
 * will not be correct if the times being compared with are prior to creation.
 */
public abstract class Contract extends AbstractSubject implements Observer {

  // Lock to be acquired for reconfiguring after being activated.
  //protected final ReconfigLock lock;

  // Currently used enforcement policy.
  protected EnforcementPolicy currentPolicy;

  /**
   * @param store
   *            the {@link Store} this {@link Contract} is stored at
   */
  protected Contract fabric$metrics$contracts$Contract$() {
    //this.lock = new ReconfigLock().fabric$metrics$util$ReconfigLock$();
    fabric$metrics$util$AbstractSubject$();
    this.$expiry = -1;
    return this;
  }

  // The drift tolerance factor we'll subtract from times we advertise to
  // others.
  public static final long DRIFT_FACTOR = 0;

  public static final long EXTENSION_WINDOW = 1000;

  /**
   * Extends the expiration time (queued to be extended later if the current
   * time is much earlier than the current expiration).
   *
   * @param newExpiry
   *        the new expiration time (computed at the current node) for
   *        this {@link Contract} given in milliseconds.
   */
  protected void extendTo(long newExpiry, boolean isAsyncExtension) {
    TransactionManager tm = TransactionManager.getInstance();
    long currentTime = System.currentTimeMillis();
    // Only bother advertising if we're close to the current expiration.
    if (getExpiry() - currentTime <= EXTENSION_WINDOW || isAsyncExtension) {
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        Observer parent = (Observer) iter.next();
        if (parent instanceof Contract) {
          tm.registerDelayedExtension(parent, this);
        }
      }
      Logging.METRICS_LOGGER.log(Level.FINE, "SYNCH EXTENSION OF {0} TO {2} IN {1}", new java.lang.Object native[] { this, TransactionManager.getInstance().getCurrentLog(), Long.valueOf(newExpiry) });
      $expiry = newExpiry;
    } else {
      // Wait until later to extend, we don't want to get too eager.
      Logging.METRICS_LOGGER.log(Level.FINE, "DELAYED EXTENSION OF {0} IN {1}", new java.lang.Object native[] { this, TransactionManager.getInstance().getCurrentLog() });
      tm.registerDelayedExtension(this);
    }
  }

  public void refresh_remote(fabric.lang.security.Principal p, boolean asyncExtension, StatsMap weakStats) {
    this.refresh(asyncExtension, weakStats);
  }

  /**
   * {@inheritDoc}
   *
   * If there are no {@link Observer}s of this {@link Contract} left, mark as
   * stale (to avoid unnecessary enforcement overhead) and stop observing any
   * enforcement evidence.
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
    static_removeObserver(this, obs);
  }

  private static void static_removeObserver(Contract tmp, Observer obs) {
    if (TransactionManager.getInstance().inTxn()) {
      AbstractSubject.static_removeObserver(tmp, obs);
      if (!tmp.isObserved()) {
        tmp.$expiry = -1;
        if (tmp.currentPolicy != null) {
          tmp.currentPolicy.unapply(tmp);
          tmp.currentPolicy = null;
          tmp.$associated = null;
        }
      }
    } else {
      atomic {
        AbstractSubject.static_removeObserver(tmp, obs);
        if (!tmp.isObserved()) {
          tmp.$expiry = -1;
          if (tmp.currentPolicy != null) {
            tmp.currentPolicy.unapply(tmp);
            tmp.currentPolicy = null;
            tmp.$associated = null;
          }
        }
      }
    }
  }

  /**
   * Updates the expiration time of this contract, either extending or
   * retracting as needed.
   *
   * @param newExpiry
   *            the new expiration time that could be associated with this
   *            {@link Contract} (if it's past the current expiry, it may not
   *            be immediately used to avoid unnecessary extension overhead).
   * @return true iff the contract was retracted by this update.
   */
  public boolean update(long newExpiry, boolean isAsyncExtension) {
    Worker localW = Worker.getWorker();
    // Account for possible drift between current location and the store.
    if (!localW.getStore(localW.getName()).equals(getStore()))
      newExpiry = newExpiry - DRIFT_FACTOR;
    if (getExpiry() < newExpiry - DRIFT_FACTOR) {
      // Only extend if everyone will see something better.
      extendTo(newExpiry, isAsyncExtension);
      //Logging.METRICS_LOGGER.finer("EXPIRY OF " + this + " IS NOW " + $expiry);
    } else if (getExpiry() > newExpiry) {
      // Revoke if doing worse than what anyone else would see.
      retract(newExpiry);
      //Logging.METRICS_LOGGER.finer("EXPIRY OF " + this + " IS NOW " + $expiry);
      return true;
    }
    return false;
  }

  /**
   * Called to retract this contract's expiry to an earlier time (applied in
   * the current transaction context).
   *
   * @param newExpiry
   *        time to set the expiry back to.
   */
  protected void retract(long newExpiry) {
    // Mark this as modified, which needs to be resolved in this
    // transaction.
    Logging.METRICS_LOGGER.log(Level.FINE, "RETRACTION OF {0} TO {2} IN {1}", new java.lang.Object native[] { this, TransactionManager.getInstance().getCurrentLog(), Long.valueOf(newExpiry) });
    $expiry = newExpiry;
  }

  /**
   * @param time
   *        the time we're checking validity against.
   * @return true iff the contract is valid at the given time in the current
   *       transaction context.
   */
  public boolean valid(long time) {
    boolean rtn = /*isActivated() &&*/ getExpiry() >= time;
    if (rtn)
      TransactionManager.getInstance().registerExpiryUse(getExpiry());
    return rtn;
  }

  /**
   * @return true iff the contract is valid at the given time in the current
   *         transaction context.
   */
  public boolean valid() {
    boolean rtn = /*isActivated() && */getExpiry() >= System.currentTimeMillis();
    if (rtn)
      TransactionManager.getInstance().registerExpiryUse(getExpiry());
    return rtn;
  }

  /**
   * @param time
   *            the time we're checking against.
   * @return true iff the contract is stale (no longer enforced) according to
   *         the local time.
   */
  public boolean stale(long time) {
    return /*isActivated() && */getExpiry() < time;
  }

  /**
   * Use this instead of valid() if you're checking something that doesn't need
   * to stay true by the end of the transaction.
   * @return true iff the contract is stale (no longer enforced) according to
   *         the local time.
   */
  public boolean stale() {
    return /*isActivated() && */getExpiry() < System.currentTimeMillis();
  }

  /**
   * @return The expiration time for this {@link Contract} (shifted to account
   *         for a constant "max" clock drift between the node that last set
   *         the expiration time and other nodes checking it.)
   */
  public long getExpiry() {
    TransactionManager.getInstance().resolveObservations();
    return $expiry - DRIFT_FACTOR;
  }

  /**
   * Update the state used to enforce this contract's expiration time (and
   * possibly update the expiration time) in response to a change in the value
   * of the current evidence ({@link Subject}s) used to enforce this
   * {@link Contract}. Revokes, extends, and updates the enforcement evidence
   * as needed.
   *
   * @return true iff the contract's expiration was retracted as a result of
   *         this operation.
   */
  public boolean refresh(boolean asyncExtension) {
    return refresh(asyncExtension, StatsMap.emptyStats());
  }

  /**
   * Update the state used to enforce this contract's expiration time (and
   * possibly update the expiration time) in response to a change in the value
   * of the current evidence ({@link Subject}s) used to enforce this
   * {@link Contract}. Revokes, extends, and updates the enforcement evidence
   * as needed.
   *
   * @return true iff the contract's expiration was retracted as a result of
   *         this operation.
   */
  public boolean refresh(boolean asyncExtension, StatsMap weakStats) {
    // Either update using the current policy or, if the expiry is stale and
    // we're not doing an async extension, update to a new policy.
    switch (static_updateWithCurPolicy(this, asyncExtension, weakStats)) {
      case 0: // NO_POLICY
      case 1: // POLICY_BAD
        // TODO: can the policy be originally in the future and retract into the
        // past on an async extension?
        return !asyncExtension &&
          updateToNewPolicy(this, asyncExtension, weakStats);
      case 2: // POLICY_GOOD_EXTENDED
        return false;
      case 3: // POLICY_GOOD_RETRACTED
      default:
        return true;
    }
  }

  /* Ugh, fabric doesn't support enums. */
  protected static final byte NO_POLICY = 0;
  protected static final byte POLICY_BAD = 1;
  protected static final byte POLICY_GOOD_EXTENDED = 2;
  protected static final byte POLICY_GOOD_RETRACTED = 3;

  /**
   * Try to update the expiration time using the current policy.
   *
   * @return true iff this contract's expiry was retracted.
   */
  protected static byte static_updateWithCurPolicy(Contract tmp,
      boolean asyncExtension, StatsMap weakStats) {
    byte result = NO_POLICY;
    if (TransactionManager.getInstance().inTxn()) {
      result = tmp.updateWithCurPolicy(asyncExtension, weakStats);
    } else {
      atomic {
        result = tmp.updateWithCurPolicy(asyncExtension, weakStats);
      }
    }
    return result;
  }

  /**
   * Inner implementation of static_updateWithCurPolicy, to be run within a
   * transaction.
   *
   * Try to update the expiration time using the current policy.
   *
   * @return true iff this contract's expiry was retracted.
   */
  protected byte updateWithCurPolicy(boolean asyncExtension, StatsMap weakStats) {
    if (this.currentPolicy != null) {
      long updatedExpiry = this.currentPolicy.expiry(weakStats);
      if (updatedExpiry >= System.currentTimeMillis()) {
        if (this.update(updatedExpiry, asyncExtension)) {
          this.currentPolicy.apply(this);
          return POLICY_GOOD_RETRACTED;
        } else {
          this.currentPolicy.apply(this);
          return POLICY_GOOD_EXTENDED;
        }
      } else {
        return POLICY_BAD;
      }
    }
    return NO_POLICY;
  }

  /**
   * Update the treaty to use a new policy (or none if the treaty is no longer
   * valid).
   *
   * @return true iff the updated expiry is a retraction from the preexisting
   * expiry.
   */
  protected static boolean updateToNewPolicy(Contract tmp,
      boolean asyncExtension, StatsMap weakStats) {
    // If we're moving to a new policy we need to be holding the reconfig locks.
    TransactionManager tm = TransactionManager.getInstance();
    //tmp.acquireReconfigLocks();

    // Otherwise we're finding a new policy, so we're coordinating.
    //Logging.METRICS_LOGGER.log(Level.FINER, "COORDINATING FOR {0} IN {1}",
    //    new java.lang.Object native[] { this, tm.getCurrentTid() });
    tm.markCoordination();

    if (tm.inTxn()) {
      EnforcementPolicy newPolicy = tmp.getNewPolicy(weakStats);

      newPolicy.activate(weakStats);

      return tmp.switchToNewPolicy(newPolicy, asyncExtension, weakStats);
    } else {
      EnforcementPolicy newPolicy = null;
      atomic {
        newPolicy = tmp.getNewPolicy(weakStats);
      }

      newPolicy.activate(weakStats);

      boolean result = false;
      atomic {
        result = tmp.switchToNewPolicy(newPolicy, asyncExtension, weakStats);
      }
      return result;
    }
  }

  /**
   * @return a new policy to enforce this treaty.
   */
  protected abstract EnforcementPolicy getNewPolicy(StatsMap weakStats);

  /**
   * Attempt switching to a new policy (only switching if the policy enables the
   * treaty to be valid).
   *
   * @return true iff the updated expiry is a retraction of the preexisting
   * expiry.
   */
  protected boolean switchToNewPolicy(EnforcementPolicy newPolicy, boolean asyncExtension, StatsMap weakStats) {
    EnforcementPolicy oldPolicy = this.currentPolicy;
    // Don't apply if the new policy is already expired.
    long newExpiry = newPolicy.expiry(weakStats);

    if (oldPolicy != null)
      oldPolicy.unapply(this);

    boolean result = this.update(newExpiry, asyncExtension);
    if (newExpiry >= System.currentTimeMillis()) {
      this.currentPolicy = newPolicy;
      this.$associated = ImmutableSet.emptySet().add(this.currentPolicy);
      this.currentPolicy.apply(this);
    } else {
      // Unapply so that the treaties that aren't going to be used are now
      // cleaned up.
      newPolicy.unapply(this);
      this.currentPolicy = null;
      this.$associated = null;
    }
    return result;
  }

  /*@Override*/
  public boolean handleUpdates() {
    //Logging.METRICS_LOGGER.log(Level.FINER, "CHECKING CONTRACT CHANGE");
    // Funny implication of this is that if something goes stale before it's
    // checked, it stays stale. Probably the right behavior?
    if (!stale()) {
      // Check first that we aren't going to conflict with a reconfiguration.
      //this.lock.checkForRead();
      return refresh(false);
    }

    // Otherwise, we need to make sure we're not stuck observing anything.
    if (currentPolicy != null) {
      currentPolicy.unapply(this);
      currentPolicy = null;
      $associated = null;
      return true; // Might need to clear out parents.
    }

    //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INVALID");
    return false;
  }

  /**
   * Check if this implies another {@link Contract} being considered.
   *
   * @param otherMetric
   *        the {@link Metric} the other {@link Contract} would
   *        assert a bound on
   * @param otherRate
   *        the rate of the bound that would be used by the other
   *        {@link Contract}
   * @param otherBase
   *        the base of the bound that would be used by the other
   *        {@link Contract}
   * @return true iff this would imply (and therefore) can enforce another
   *       {@link Contract} with the given metric and bound.
   */
  public abstract boolean implies(Metric otherMetric, double otherRate, double otherBase);

  /**
   * Attempt to extend this {@link Contract}'s expiration time. (Invoked to
   * perform asynchronous extensions close to the current expiration time).
   */
  public void attemptExtension_remote(fabric.lang.security.Principal caller) {
    // Ugh, need to add _remote suffix because it's expected by remote call
    // messages and is added by the fabric compiler.
    this.attemptExtension();
  }

  /**
   * Attempt to extend this {@link Contract}'s expiration time. (Invoked to
   * perform asynchronous extensions close to the current expiration time).
   */
  public void attemptExtension() {
    static_attemptExtension(this);
  }

  private static void static_attemptExtension(Contract tmp) {
    Logging.METRICS_LOGGER.log(Level.FINE, "ASYNC EXTENSION OF " + tmp + " IN "
        + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.valid()) {
        // Check first that we aren't going to conflict with a
        // reconfiguration.
        //tmp.lock.checkForRead();
        tmp.refresh(true);
      } else if (tmp.currentPolicy != null) {
        // Otherwise, we need to make sure we're not stuck observing anything.
        tmp.currentPolicy.unapply(tmp);
        tmp.currentPolicy = null;
        tmp.$associated = null;
      }
    } else {
      atomic {
        if (tmp.valid()) {
          // Check first that we aren't going to conflict with a
          // reconfiguration.
          //tmp.lock.checkForRead();
          tmp.refresh(true);
        } else if (tmp.currentPolicy != null) {
          // Otherwise, we need to make sure we're not stuck observing anything.
          tmp.currentPolicy.unapply(tmp);
          tmp.currentPolicy = null;
          tmp.$associated = null;
        }
      }
    }
  }

  /**
   * Acquire reconfig locks starting from this contract.
   */
  public void acquireReconfigLocks() {
    //Logging.METRICS_LOGGER.finer("ACQUIRING LOCK AT " + this + " IN " +
    //    TransactionManager.getInstance().getCurrentLog());
    //this.lock.acquireOptimistic();
    //if (this.currentPolicy != null)
    //  this.currentPolicy.acquireReconfigLocks();
  }

  /**
   * Create a {@link ConjunctionContract} with this and another contract.
   */
  public Contract and(Contract other) {
    if (other instanceof ProxyContract)
      other = ((ProxyContract) other).target;
    return new ConjunctionContract().fabric$metrics$contracts$ConjunctionContract$(new Contract native[] { this, other });
  }

  /**
   * Create a proxy for this contract on the given store.
   */
  public Contract getProxyContract(final Store proxyStore) {
    return static_getProxyContract(this, proxyStore);
  }

  private static Contract static_getProxyContract(Contract tmp, final Store proxyStore) {
    Contract proxy = null;
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.$getStore().equals(proxyStore)) {
        proxy = tmp;
      } else if (tmp instanceof ProxyContract && ((ProxyContract) tmp).target.$getStore().equals(proxyStore)) {
        proxy = ((ProxyContract) tmp).target;
      } else {
        proxy = new ProxyContract@proxyStore().fabric$metrics$contracts$Contract$ProxyContract$(tmp);
        proxy.refresh(false);
      }
    } else {
      atomic {
        if (tmp.$getStore().equals(proxyStore)) {
          proxy = tmp;
        } else if (tmp instanceof ProxyContract && ((ProxyContract) tmp).target.$getStore().equals(proxyStore)) {
          proxy = ((ProxyContract) tmp).target;
        } else {
          proxy = new ProxyContract@proxyStore().fabric$metrics$contracts$Contract$ProxyContract$(tmp);
          proxy.refresh(false);
        }
      }
    }
    return proxy;
  }

  /**
   * A Contract which basically acts as a proxy for another Contract
   * to allow local access on another store while the contract is valid.
   *
   * Basically operates by using the original Contract as the only witness
   * of this metric contract.
   */
  protected static class ProxyContract extends Contract {

    // The Contract this acts as a proxy for.
    protected final Contract target;

    /**
     * @param target
     *        the {@link Contract} this proxies
     */
    public ProxyContract fabric$metrics$contracts$Contract$ProxyContract$(Contract target) {
      if (target instanceof ProxyContract) {
        this.target = ((ProxyContract) target).target;
      } else {
        this.target = target;
      }
      fabric$metrics$contracts$Contract$();
      this.currentPolicy = new WitnessPolicy().fabric$metrics$contracts$enforcement$WitnessPolicy$(new Contract native[] { this.target });
      this.$associated = ImmutableSet.emptySet().add(this.currentPolicy);
      return this;
    }

    /*@Override*/
    protected EnforcementPolicy getNewPolicy(StatsMap weakStats) {
      // TODO: is this right?
      return new WitnessPolicy().fabric$metrics$contracts$enforcement$WitnessPolicy$(new Contract native[] { this.target });
    }

    /*@Override*/
    public boolean implies(Metric otherMetric, double otherRate, double otherBase) {
      return target.implies(otherMetric, otherRate, otherBase);
    }

    /*@Override*/
    public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
      final Store local = Worker.getWorker().getLocalStore();
      if (currentPolicy == null)
        return ImmutableMetricsVector.emptyVector();
      return target.getLeafSubjects();
    }

    /*@Override*/
    public Contract and(Contract other) {
      return target.and(other);
    }

    /*@Override*/
    public String toString() {
      return "Proxy @ " + $getStore() + " for " + target + " until " + $expiry;
    }
  }
}

package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.contracts.warranties.WarrantyComp;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.metrics.util.ReconfigLock;
import fabric.metrics.util.Subject;
import fabric.util.ArrayList;
import java.util.Iterator;
import fabric.util.List;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableSet;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A {@link Contract} represents an assertion that is enforced until an
 * expiration time, once {@link #activate()}d. If the current time is earlier
 * than the expiration time and the {@link Contract} {@link #isActivated()},
 * then the {@link Contract} is <i>valid</i>: the enforcement protocol
 * implemented by the API will ensure the assertion holds.
 * <p>
 * This class follows the {@link Subject}-{@link Observer} pattern. An instance
 * can be an observer of a {@link Metric} or other {@link Contract}s, and can be
 * observed by {@link WarrantyComp}s or other {@link Contract}s.
 * <p>
 * TODO: right now all the uses of expiry assume that the check is for a time
 * after the time the {@link Contract} was created. Some of these operations
 * will not be correct if the times being compared with are prior to creation.
 */
public abstract class Contract extends AbstractSubject implements Observer {

  // Lock to be acquired for reconfiguring after being activated.
  //protected final ReconfigLock lock;

  // Currently used enforcement policy.
  protected EnforcementPolicy currentPolicy;

  /**
   * @param store
   *            the {@link Store} this {@link Contract} is stored at
   */
  protected Contract fabric$metrics$contracts$Contract$() {
    //this.lock = new ReconfigLock().fabric$metrics$util$ReconfigLock$();
    fabric$metrics$util$AbstractSubject$();
    this.$expiry = -1;
    return this;
  }

  // The proportional amount of time an extension has to improve over the
  // current expiry for us to bother advertising it.
  // Note: larger value => less aggressive extensions => lower overhead
  // Note: smaller value => more aggressive extensions => less chance of a
  // warranty going stale unecessarily.
  public static final double MIN_EXTENSION_FACTOR = 1.05;
  // The drift tolerance factor we'll subtract from times we advertise to
  // others.
  //public static final long DRIFT_FACTOR = 100;
  public static final long DRIFT_FACTOR = 0;

  public static final long EXTENSION_WINDOW = 1000;

  /**
   * Extends the expiration time (queued to be extended later if the current
   * time is much earlier than the current expiration).
   *
   * @param newExpiry
   *        the new expiration time (computed at the current node) for
   *        this {@link Contract} given in milliseconds.
   */
  protected void extendTo(long newExpiry, boolean isAsyncExtension) {
    TransactionManager tm = TransactionManager.getInstance();
    long currentTime = System.currentTimeMillis();
    // Only bother advertising if it's better than our current expiry
    // by the buffer amount or if we're close to the current expiration.
    //if (newExpiry > currentTime
    //        + (MIN_EXTENSION_FACTOR * (getExpiry() - currentTime))
    //            || getExpiry() - currentTime <= EXTENSION_WINDOW) {
    if (getExpiry() - currentTime <= EXTENSION_WINDOW || isAsyncExtension) {
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        Observer parent = (Observer) iter.next();
        if (parent instanceof Contract) {
          tm.registerDelayedExtension(parent, this);
        }
      }
      Logging.METRICS_LOGGER.log(Level.FINE, "SYNCH EXTENSION OF {0} TO {2} IN {1}", new java.lang.Object native[] { this, TransactionManager.getInstance().getCurrentLog(), Long.valueOf(newExpiry) });
      $expiry = newExpiry;
    } else {
      // Wait until later to extend, we don't want to get too eager.
      Logging.METRICS_LOGGER.log(Level.FINE, "DELAYED EXTENSION OF {0} IN {1}", new java.lang.Object native[] { this, TransactionManager.getInstance().getCurrentLog() });
      tm.registerDelayedExtension(this);
    }
  }

  /**
   * Has the {@link Contract} been activated (the System has started enforcing
   * and maintaining the expiration time)?
   */
  //private boolean activated = false;

  /**
   * @return true iff this contract has been activated (the System is
   *         enforcing it).
   */
  //protected boolean isActivated() {
  //  return activated;
  //}

  /**
   * Activate and start enforcing this {@link Contract} in the System.
   */
  public void activate() {
    //Contract.static_activate(this);
    refresh(false);
  }

  public void activate_remote(fabric.lang.security.Principal p) {
    // Changed to avoid using deprecated activation procedure.
    this.refresh(false);
  }

  public void refresh_remote(fabric.lang.security.Principal p, boolean asyncExtension) {
    this.refresh(asyncExtension);
  }

  public static void static_activate(Contract tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      //if (!tmp.activated) {
        if (tmp.currentPolicy != null) {
          tmp.currentPolicy.activate();
        }
        //tmp.activated = true;
        if (tmp.currentPolicy != null && tmp.currentPolicy.expiry() > System.currentTimeMillis()) {
          tmp.$expiry = tmp.currentPolicy.expiry();
          tmp.currentPolicy.apply(tmp);
        } else {
          tmp.currentPolicy = null;
          tmp.$associated = null;
        }
        Logging.METRICS_LOGGER.log(Level.FINE, "ACTIVATED {0} IN {1}", new java.lang.Object native[] { tmp, TransactionManager.getInstance().getCurrentLog() });
      //}
    } else {
      //boolean unactivated = false;
      //atomic {
      //  unactivated = !tmp.activated;
      //}
      //if (unactivated) {
        if (tmp.currentPolicy != null) {
          tmp.currentPolicy.activate();
        }
        atomic {
          //tmp.activated = true;
          if (tmp.currentPolicy != null && tmp.currentPolicy.expiry() > System.currentTimeMillis()) {
            tmp.$expiry = tmp.currentPolicy.expiry();
            tmp.currentPolicy.apply(tmp);
          } else {
            tmp.currentPolicy = null;
            tmp.$associated = null;
          }
          Logging.METRICS_LOGGER.log(Level.FINE, "ACTIVATED {0} IN {1}", new java.lang.Object native[] { tmp, TransactionManager.getInstance().getCurrentLog() });
        }
      //}
    }
  }

  /**
   * {@inheritDoc}
   *
   * If there are no {@link Observer}s of this {@link Contract} left, mark as
   * stale (to avoid unnecessary enforcement overhead) and stop observing any
   * enforcement evidence.
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
    static_removeObserver(this, obs);
  }

  private static void static_removeObserver(Contract tmp, Observer obs) {
    if (TransactionManager.getInstance().inTxn()) {
      AbstractSubject.static_removeObserver(tmp, obs);
      if (!tmp.isObserved()) {
        tmp.$expiry = -1;
        if (tmp.currentPolicy != null) {
          tmp.currentPolicy.unapply(tmp);
          tmp.currentPolicy = null;
          tmp.$associated = null;
        }
      }
    } else {
      atomic {
        AbstractSubject.static_removeObserver(tmp, obs);
        if (!tmp.isObserved()) {
          tmp.$expiry = -1;
          if (tmp.currentPolicy != null) {
            tmp.currentPolicy.unapply(tmp);
            tmp.currentPolicy = null;
            tmp.$associated = null;
          }
        }
      }
    }
  }

  /**
   * Updates the expiration time of this contract, either extending or
   * retracting as needed.
   *
   * @param newExpiry
   *            the new expiration time that could be associated with this
   *            {@link Contract} (if it's past the current expiry, it may not
   *            be immediately used to avoid unnecessary extension overhead).
   * @return true iff the contract was retracted by this update.
   */
  public boolean update(long newExpiry, boolean isAsyncExtension) {
    Worker localW = Worker.getWorker();
    // Account for possible drift between current location and the store.
    if (!localW.getStore(localW.getName()).equals(getStore()))
      newExpiry = newExpiry - DRIFT_FACTOR;
    if (getExpiry() < newExpiry - DRIFT_FACTOR) {
      // Only extend if everyone will see something better.
      extendTo(newExpiry, isAsyncExtension);
      //Logging.METRICS_LOGGER.finer("EXPIRY OF " + this + " IS NOW " + $expiry);
    } else if (getExpiry() > newExpiry) {
      // Revoke if doing worse than what anyone else would see.
      retract(newExpiry);
      //Logging.METRICS_LOGGER.finer("EXPIRY OF " + this + " IS NOW " + $expiry);
      return true;
    }
    return false;
  }

  /**
   * Called to retract this contract's expiry to an earlier time (applied in
   * the current transaction context).
   *
   * @param newExpiry
   *        time to set the expiry back to.
   */
  protected void retract(long newExpiry) {
    // Mark this as modified, which needs to be resolved in this
    // transaction.
    // TODO: Maybe indicate which contract's being retracted?
    Logging.METRICS_LOGGER.log(Level.FINE, "RETRACTION OF {0} TO {2} IN {1}", new java.lang.Object native[] { this, TransactionManager.getInstance().getCurrentLog(), Long.valueOf(newExpiry) });
    $expiry = newExpiry;
  }

  /**
   * @param time
   *        the time we're checking validity against.
   * @return true iff the contract is valid at the given time in the current
   *       transaction context.
   */
  public boolean valid(long time) {
    boolean rtn = /*isActivated() &&*/ getExpiry() >= time;
    if (rtn)
      TransactionManager.getInstance().registerExpiryUse(getExpiry());
    return rtn;
  }

  /**
   * @return true iff the contract is valid at the given time in the current
   *         transaction context.
   */
  public boolean valid() {
    boolean rtn = /*isActivated() && */getExpiry() >= System.currentTimeMillis();
    if (rtn)
      TransactionManager.getInstance().registerExpiryUse(getExpiry());
    return rtn;
  }

  /**
   * @param time
   *            the time we're checking against.
   * @return true iff the contract is stale (no longer enforced) according to
   *         the local time.
   */
  public boolean stale(long time) {
    return /*isActivated() && */getExpiry() < time;
  }

  /**
   * @return true iff the contract is stale (no longer enforced) according to
   *         the local time.
   */
  public boolean stale() {
    return /*isActivated() && */getExpiry() < System.currentTimeMillis();
  }

  /**
   * @return The expiration time for this {@link Contract} (shifted to account
   *         for a constant "max" clock drift between the node that last set
   *         the expiration time and other nodes checking it.)
   */
  public long getExpiry() {
    TransactionManager.getInstance().resolveObservations();
    return $expiry - DRIFT_FACTOR;
  }

  /**
   * @return The expiration time for this {@link Contract} (shifted to account
   *         for a constant "max" clock drift between the node that last set
   *         the expiration time and other nodes checking it.)
   * NOTE: Purely intended for proxy contracts.
   */
  //protected long getRawExpiry() {
  //  return $expiry;
  //}

  /**
   * Update the state used to enforce this contract's expiration time (and
   * possibly update the expiration time) in response to a change in the value
   * of the current evidence ({@link Subject}s) used to enforce this
   * {@link Contract}. Revokes, extends, and updates the enforcement evidence
   * as needed.
   *
   * @return true iff the contract's expiration was retracted as a result of
   *         this operation.
   */
  public abstract boolean refresh(boolean asyncExtension);

  /*@Override*/
  public boolean handleUpdates() {
    //Logging.METRICS_LOGGER.log(Level.FINER, "CHECKING CONTRACT CHANGE");
    // Funny implication of this is that if something goes stale before it's
    // checked, it stays stale. Probably the right behavior?
    if (valid()) {
      // Check first that we aren't going to conflict with a reconfiguration.
      //this.lock.checkForRead();
      return refresh(false);
    }

    // Otherwise, we need to make sure we're not stuck observing anything.
    if (currentPolicy != null) {
      currentPolicy.unapply(this);
      currentPolicy = null;
      $associated = null;
      return true; // Might need to clear out parents.
    }

    //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INVALID");
    return false;
  }

  /**
   * Check if this implies another {@link Contract} being considered.
   *
   * @param otherMetric
   *        the {@link Metric} the other {@link Contract} would
   *        assert a bound on
   * @param otherRate
   *        the rate of the bound that would be used by the other
   *        {@link Contract}
   * @param otherBase
   *        the base of the bound that would be used by the other
   *        {@link Contract}
   * @return true iff this would imply (and therefore) can enforce another
   *       {@link Contract} with the given metric and bound.
   */
  public abstract boolean implies(Metric otherMetric, double otherRate, double otherBase);

  /**
   * Attempt to extend this {@link Contract}'s expiration time. (Invoked to
   * perform asynchronous extensions close to the current expiration time).
   */
  public void attemptExtension_remote(fabric.lang.security.Principal caller) {
    // Ugh, need to add _remote suffix because it's expected by remote call
    // messages and is added by the fabric compiler.
    this.attemptExtension();
  }

  /**
   * Attempt to extend this {@link Contract}'s expiration time. (Invoked to
   * perform asynchronous extensions close to the current expiration time).
   */
  public void attemptExtension() {
    static_attemptExtension(this);
  }

  private static void static_attemptExtension(Contract tmp) {
    Logging.METRICS_LOGGER.log(Level.FINE, "ASYNC EXTENSION OF " + tmp + " IN "
        + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.valid()) {
        // Check first that we aren't going to conflict with a
        // reconfiguration.
        //tmp.lock.checkForRead();
        tmp.refresh(true);
      } else if (tmp.currentPolicy != null) {
        // Otherwise, we need to make sure we're not stuck observing anything.
        tmp.currentPolicy.unapply(tmp);
        tmp.currentPolicy = null;
        tmp.$associated = null;
      }
    } else {
      atomic {
        if (tmp.valid()) {
          // Check first that we aren't going to conflict with a
          // reconfiguration.
          //tmp.lock.checkForRead();
          tmp.refresh(true);
        } else if (tmp.currentPolicy != null) {
          // Otherwise, we need to make sure we're not stuck observing anything.
          tmp.currentPolicy.unapply(tmp);
          tmp.currentPolicy = null;
          tmp.$associated = null;
        }
      }
    }
  }

  /**
   * Acquire reconfig locks starting from this contract.
   */
  public void acquireReconfigLocks() {
    //Logging.METRICS_LOGGER.finer("ACQUIRING LOCK AT " + this + " IN " +
    //    TransactionManager.getInstance().getCurrentLog());
    //this.lock.acquireOptimistic();
    //if (this.currentPolicy != null)
    //  this.currentPolicy.acquireReconfigLocks();
  }

  /**
   * Create a {@link ConjunctionContract} with this and another contract.
   */
  public Contract and(Contract other) {
    if (other instanceof ProxyContract)
      other = ((ProxyContract) other).target;
    return new ConjunctionContract().fabric$metrics$contracts$ConjunctionContract$(new Contract native[] { this, other });
  }

  /**
   * Create a proxy for this contract on the given store.
   */
  public Contract getProxyContract(final Store proxyStore) {
    return static_getProxyContract(this, proxyStore);
  }

  private static Contract static_getProxyContract(Contract tmp, final Store proxyStore) {
    Contract proxy = null;
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.$getStore().equals(proxyStore)) {
        proxy = tmp;
      } else if (tmp instanceof ProxyContract && ((ProxyContract) tmp).target.$getStore().equals(proxyStore)) {
        proxy = ((ProxyContract) tmp).target;
      } else {
        proxy = new ProxyContract@proxyStore().fabric$metrics$contracts$Contract$ProxyContract$(tmp);
        proxy.refresh(false);
      }
    } else {
      atomic {
        if (tmp.$getStore().equals(proxyStore)) {
          proxy = tmp;
        } else if (tmp instanceof ProxyContract && ((ProxyContract) tmp).target.$getStore().equals(proxyStore)) {
          proxy = ((ProxyContract) tmp).target;
        } else {
          proxy = new ProxyContract@proxyStore().fabric$metrics$contracts$Contract$ProxyContract$(tmp);
          proxy.refresh(false);
        }
      }
    }
    return proxy;
  }

  /**
   * A Contract which basically acts as a proxy for another Contract
   * to allow local access on another store while the contract is valid.
   *
   * Basically operates by using the original Contract as the only witness
   * of this metric contract.
   */
  protected static class ProxyContract extends Contract {

    // The Contract this acts as a proxy for.
    protected final Contract target;

    /**
     * @param target
     *        the {@link Contract} this proxies
     */
    public ProxyContract fabric$metrics$contracts$Contract$ProxyContract$(Contract target) {
      if (target instanceof ProxyContract) {
        this.target = ((ProxyContract) target).target;
      } else {
        this.target = target;
      }
      fabric$metrics$contracts$Contract$();
      this.currentPolicy = new WitnessPolicy().fabric$metrics$contracts$enforcement$WitnessPolicy$(new Contract native[] { this.target });
      this.$associated = ImmutableSet.emptySet().add(this.currentPolicy);
      return this;
    }

    /*@Override*/
    public boolean refresh(boolean asyncExtension) {
      // If we haven't activated yet, this is a bad operation.  Stop.
      //if (!isActivated()) {
      //  //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INACTIVE");
      //  return false;
      //}

      long currentTime = System.currentTimeMillis();
      if (currentPolicy != null) {
        currentPolicy.activate();
        long curExpiry = currentPolicy.expiry();
        boolean result = update(curExpiry, asyncExtension);
        if (curExpiry < currentTime) {
          currentPolicy.unapply(this);
          currentPolicy = null;
          $associated = null;
        } else {
          currentPolicy.apply(this);
        }
        return result;
      }

      // If we're not observing, the contract is dead.
      return false;
    }

    /*@Override*/
    public boolean implies(Metric otherMetric, double otherRate, double otherBase) {
      return target.implies(otherMetric, otherRate, otherBase);
    }

    /*@Override*/
    public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
      final Store local = Worker.getWorker().getLocalStore();
      if (currentPolicy == null)
        return ImmutableMetricsVector.emptyVector();
      return target.getLeafSubjects();
    }

    /*@Override*/
    public Contract and(Contract other) {
      return target.and(other);
    }

    /*@Override*/
    public String toString() {
      return "Proxy @ " + $getStore() + " for " + target + " until " + $expiry;
    }
  }
}

package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.contracts.warranties.WarrantyComp;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.metrics.util.ReconfigLock;
import fabric.metrics.util.Subject;
import fabric.util.Iterator;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A {@link Contract} represents an assertion that is enforced until an
 * expiration time, once {@link #activate()}d. If the current time is earlier
 * than the expiration time and the {@link Contract} {@link #isActivated()},
 * then the {@link Contract} is <i>valid</i>: the enforcement protocol
 * implemented by the API will ensure the assertion holds.
 * <p>
 * This class follows the {@link Subject}-{@link Observer} pattern. An instance
 * can be an observer of a {@link Metric} or other {@link Contract}s, and can be
 * observed by {@link WarrantyComp}s or other {@link Contract}s.
 * <p>
 * TODO: right now all the uses of expiry assume that the check is for a time
 * after the time the {@link Contract} was created. Some of these operations
 * will not be correct if the times being compared with are prior to creation.
 */
public abstract class Contract extends AbstractSubject implements Observer {

  // Lock to be acquired for reconfiguring after being activated.
  protected final ReconfigLock lock;

  /**
   * @param store
   *            the {@link Store} this {@link Contract} is stored at
   */
  protected Contract fabric$metrics$contracts$Contract$() {
    this.lock = new ReconfigLock().fabric$metrics$util$ReconfigLock$();
    fabric$metrics$util$AbstractSubject$();
    this.$expiry = -1;
    return this;
  }

  // The proportional amount of time an extension has to improve over the
  // current expiry for us to bother advertising it.
  // Note: larger value => less aggressive extensions => lower overhead
  // Note: smaller value => more aggressive extensions => less chance of a
  // warranty going stale unecessarily.
  public static final double MIN_EXTENSION_FACTOR = 1.05;
  // The drift tolerance factor we'll subtract from times we advertise to
  // others.
  public static final long DRIFT_FACTOR = 100;

  public static final long EXTENSION_WINDOW = 1000;

  /**
   * Extends the expiration time (queued to be extended later if the current
   * time is much earlier than the current expiration).
   *
   * @param newExpiry
   *        the new expiration time (computed at the current node) for
   *        this {@link Contract} given in milliseconds.
   */
  protected void extendTo(long newExpiry) {
    TransactionManager tm = TransactionManager.getInstance();
    long currentTime = System.currentTimeMillis();
    // Only bother advertising if it's better than our current expiry
    // by the buffer amount or if we're close to the current expiration.
    //if (newExpiry > currentTime
    //        + (MIN_EXTENSION_FACTOR * (getExpiry() - currentTime))
    //            || getExpiry() - currentTime <= EXTENSION_WINDOW) {
    if (getExpiry() - currentTime <= EXTENSION_WINDOW) {
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        Observer parent = (Observer) iter.next();
        if (parent instanceof MetricContract) {
          tm.registerDelayedExtension(parent,
              ((MetricContract) parent).$expiry);
        }
      }
      Logging.METRICS_LOGGER.log(Level.FINER, "SYNCH EXTENSION");
      $expiry = newExpiry;
    } else {
      // Wait until later to extend, we don't want to get too eager.
      Logging.METRICS_LOGGER.log(Level.FINER, "DELAYED EXTENSION");
      tm.registerDelayedExtension(this, this.$expiry);
    }
  }

  /**
   * Has the {@link Contract} been activated (the System has started enforcing
   * and maintaining the expiration time)?
   */
  private boolean activated = false;

  /**
   * @return true iff this contract has been activated (the System is
   *         enforcing it).
   */
  protected boolean isActivated() {
    return activated;
  }

  /**
   * Activate and start enforcing this {@link Contract} in the System.
   */
  protected void activate() {
    static_activate(this);
  }

  protected static void static_activate(Contract tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.activated) {
        Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT ACTIVATE");
        tmp.activated = true;
      }
    } else {
      atomic {
        if (!tmp.activated) {
          Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT ACTIVATE");
          tmp.activated = true;
        }
      }
    }
  }

  /**
   * {@inheritDoc}
   *
   * If there are no {@link Observer}s of this {@link Contract} left, mark as
   * stale (to avoid unnecessary enforcement overhead) and stop observing any
   * enforcement evidence.
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
    static_removeObserver(this, obs);
  }

  private static void static_removeObserver(Contract tmp, Observer obs) {
    if (TransactionManager.getInstance().inTxn()) {
      AbstractSubject.static_removeObserver(tmp, obs);
      if (!tmp.isObserved()) {
          tmp.$expiry = -1;
      }
    } else {
      atomic {
        AbstractSubject.static_removeObserver(tmp, obs);
        if (!tmp.isObserved()) {
            tmp.$expiry = -1;
        }
      }
    }
  }

  /**
   * Updates the expiration time of this contract, either extending or
   * retracting as needed.
   *
   * @param newExpiry
   *            the new expiration time that could be associated with this
   *            {@link Contract} (if it's past the current expiry, it may not
   *            be immediately used to avoid unnecessary extension overhead).
   * @return true iff the contract was retracted by this update.
   */
  public boolean update(long newExpiry) {
    Worker localW = Worker.getWorker();
    // Account for possible drift between current location and the store.
    if (!localW.getStore(localW.getName()).equals(getStore()))
      newExpiry = newExpiry - DRIFT_FACTOR;
    if (getExpiry() < newExpiry - DRIFT_FACTOR) {
      // Only extend if everyone will see something better.
      extendTo(newExpiry);
      //Logging.METRICS_LOGGER.finer("EXPIRY OF " + this + " IS NOW " + $expiry);
    } else if (getExpiry() > newExpiry) {
      // Revoke if doing worse than what anyone else would see.
      retract(newExpiry);
      //Logging.METRICS_LOGGER.finer("EXPIRY OF " + this + " IS NOW " + $expiry);
      return true;
    }
    return false;
  }

  /**
   * Called to retract this contract's expiry to an earlier time (applied in
   * the current transaction context).
   *
   * @param newExpiry
   *        time to set the expiry back to.
   */
  protected void retract(long newExpiry) {
    // Mark this as modified, which needs to be resolved in this
    // transaction.
    // TODO: Maybe indicate which contract's being retracted?
    Logging.METRICS_LOGGER.log(Level.FINE, "RETRACTION");
    $expiry = newExpiry;
  }

  /**
   * @param time
   *        the time we're checking validity against.
   * @return true iff the contract is valid at the given time in the current
   *       transaction context.
   */
  public boolean valid(long time) {
    boolean rtn = isActivated() && getExpiry() >= time;
    if (rtn)
      TransactionManager.getInstance().registerExpiryUse(getExpiry());
    return rtn;
  }

  /**
   * @return true iff the contract is valid at the given time in the current
   *         transaction context.
   */
  public boolean valid() {
    boolean rtn = isActivated() && getExpiry() >= System.currentTimeMillis();
    if (rtn)
      TransactionManager.getInstance().registerExpiryUse(getExpiry());
    return rtn;
  }

  /**
   * @param time
   *            the time we're checking against.
   * @return true iff the contract is stale (no longer enforced) according to
   *         the local time.
   */
  public boolean stale(long time) {
    return isActivated() && getExpiry() < time;
  }

  /**
   * @return true iff the contract is stale (no longer enforced) according to
   *         the local time.
   */
  public boolean stale() {
    return isActivated() && getExpiry() < System.currentTimeMillis();
  }

  /**
   * @return The expiration time for this {@link Contract} (shifted to account
   *         for a constant "max" clock drift between the node that last set
   *         the expiration time and other nodes checking it.)
   */
  public long getExpiry() {
    return $expiry - DRIFT_FACTOR;
  }

  /**
   * Update the state used to enforce this contract's expiration time (and
   * possibly update the expiration time) in response to a change in the value
   * of the current evidence ({@link Subject}s) used to enforce this
   * {@link Contract}. Revokes, extends, and updates the enforcement evidence
   * as needed.
   *
   * @return true iff the contract's expiration was retracted as a result of
   *         this operation.
   */
  protected abstract boolean refresh(boolean asyncExtension);

  /*@Override*/
  public boolean handleUpdates() {
    //Logging.METRICS_LOGGER.log(Level.FINER, "CHECKING CONTRACT CHANGE");
    // Check first that we aren't going to conflict with a reconfiguration.
    this.lock.checkForRead();

    // Funny implication of this is that if something goes stale before it's
    // checked, it stays stale. Probably the right behavior?
    if (valid())
      return refresh(false);
    //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INVALID");
    return false;
  }

  /**
   * Attempt to extend this {@link Contract}'s expiration time. (Invoked to
   * perform asynchronous extensions close to the current expiration time).
   */
  public void attemptExtension_remote(fabric.lang.security.Principal caller) {
    // Ugh, need to add _remote suffix because it's expected by remote call
    // messages and is added by the fabric compiler.
    this.attemptExtension();
  }

  /**
   * Attempt to extend this {@link Contract}'s expiration time. (Invoked to
   * perform asynchronous extensions close to the current expiration time).
   */
  public void attemptExtension() {
    static_attemptExtension(this);
  }

  private static void static_attemptExtension(Contract tmp) {
    Logging.METRICS_LOGGER.log(Level.FINER, "ASYNC EXTENSION OF " + tmp + " IN "
        + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      tmp.refresh(true);
    } else {
      atomic {
        tmp.refresh(true);
      }
    }
  }

  /**
   * Acquire reconfig locks starting from this contract.
   */
  public void acquireReconfigLocks() {
    this.lock.acquire();
  }
}

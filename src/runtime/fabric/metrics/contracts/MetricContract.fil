package fabric.metrics.contracts;

import fabric.util.Collections;
import fabric.util.Set;

import fabric.metrics.DerivedMetric;
import fabric.metrics.Metric;
import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.common.TransactionID;
import fabric.worker.Store;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A contract asserting that a {@link Metric}'s value is above or below a
 * vectorized boundary expression <code>r⃗ * (t - startTime) + b⃗</code> until
 * the associated expriation time.
 * <p>
 * This class follows the subject-observer pattern. An instance is an observer
 * of either a {@link Metric} or a set of {@link MetricContract}s and can be
 * observed by other {@link Contract}s.
 */
public class MetricContract extends Contract {

  protected final Metric metric;
  private final ImmutableMetricsVector leafMetrics;
  public final double rate;
  public final double base;

  /**
   * @param metric
   *        the {@link Metric} this contract asserts a bound on
   * @param rate
   *        the rate of the bound this {@link MetricContract} asserts on
   *        metric.
   * @param base
   *        the base of the bound this {@link MetricContract} asserts on
   *        metric.
   */
  public MetricContract fabric$metrics$contracts$MetricContract$(Metric metric, double rate, double base) {
    this.metric = metric;
    this.rate = rate;
    this.base = base;
    if (metric instanceof SampledMetric) {
      leafMetrics = ImmutableMetricsVector.createVector(new SampledMetric native[] { (SampledMetric) metric });
    } else if (metric instanceof DerivedMetric) {
      leafMetrics = ((DerivedMetric) metric).getLeafSubjects();
    } else {
      throw new IllegalStateException(
          "All metrics should be either sampled or derived!");
    }
    fabric$metrics$contracts$Contract$();
    return this;
  }

  /** @return the {@link Metric} that this contract observes. */
  public Metric getMetric() {
    return metric;
  }

  /**
   * @return the expected lifetime of this {@link MetricContract} given the
   *       associated {@link Metric}s current velocity.
   */
  public long getExpectedLifetime() {
    long time = System.currentTimeMillis();
    Metric m = getMetric();
    double adjustedRate = rate - m.velocity();
    return (long)
      (time + ((m.value() - Bound.value(rate, base, time)) / adjustedRate));
  }

  /**
   * @return a new policy to enforce this treaty.
   */
  /*@Override*/
  protected EnforcementPolicy getNewPolicy(StatsMap weakStats) {
    // Being deprecated.
    return null;
    //return this.metric.thresholdPolicy(this.rate, this.base, weakStats,
    //    this.$getStore());
  }

  /*@Override*/
  public boolean implies(Metric otherMetric, double otherRate, double otherBase) {
    if (!getMetric().equals(otherMetric)
        || this.rate < otherRate
        || this.base < otherBase)
      return false;
    return valid();
  }

  /*@Override*/
  public String toString() {
    // Changed to read relative to current time
    return getMetric().toString() + " >= " + rate + " * t + " + (base + (rate * System.currentTimeMillis())) + " until " + getExpiry();
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    return leafMetrics;
  }
}

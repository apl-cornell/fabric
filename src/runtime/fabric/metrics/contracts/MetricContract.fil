package fabric.metrics.contracts;

import fabric.util.Collections;
import fabric.util.Set;

import fabric.metrics.DerivedMetric;
import fabric.metrics.Metric;
import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.common.TransactionID;
import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A contract asserting that a {@link Metric}'s value is above or below a
 * vectorized boundary expression <code>r⃗ * (t - startTime) + b⃗</code> until
 * the associated expriation time.
 * <p>
 * This class follows the subject-observer pattern. An instance is an observer
 * of either a {@link Metric} or a set of {@link MetricContract}s and can be
 * observed by other {@link Contract}s.
 */
public class MetricContract extends Contract {

  protected final Metric metric;
  public final double rate;
  public final double base;
  protected EnforcementPolicy currentPolicy;

  /**
   * @param metric
   *        the {@link Metric} this contract asserts a bound on
   * @param rate
   *        the rate of the bound this {@link MetricContract} asserts on
   *        metric.
   * @param base
   *        the base of the bound this {@link MetricContract} asserts on
   *        metric.
   */
  public MetricContract fabric$metrics$contracts$MetricContract$(Metric metric, double rate, double base) {
    this.metric = metric;
    this.rate = rate;
    this.base = base;
    fabric$metrics$contracts$Contract$();
    return this;
  }

  /** @return the {@link Metric} that this contract observes. */
  public Metric getMetric() {
    return metric;
  }

  /**
   * @return the expected lifetime of this {@link MetricContract} given the
   *       associated {@link Metric}s current velocity.
   */
  public long getExpectedLifetime() {
    long time = System.currentTimeMillis();
    Metric m = getMetric();
    double adjustedRate = rate - m.velocity();
    return (long)
      (time + ((m.value() - Bound.value(rate, base, time)) / adjustedRate));
  }

  public void activate_remote(fabric.lang.security.Principal caller) {
    activate();
  }

  /*@Override*/
  public void activate() {
    static_activate(this);
  }

  private static void static_activate(MetricContract tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.isActivated())
        return;
    } else {
      atomic {
        if (tmp.isActivated())
          return;
      }
    }

    // Refresh the stats being used
    // Commented out for now.  If it's run here it's going to repeat work in
    // subcalls.
    //metric.refreshWeakEstimates();

    // Determine children
    //Logging.METRICS_LOGGER.finer("CREATING A POLICY FOR MC " + tmp);
    EnforcementPolicy startPol = null;
    if (TransactionManager.getInstance().inTxn()) {
      startPol = tmp.metric.policy(tmp.rate, tmp.base, true, tmp.$getStore());
    } else {
      atomic {
        startPol = tmp.metric.policy(tmp.rate, tmp.base, true, tmp.$getStore());
      }
    }

    // Activate new children
    //Logging.METRICS_LOGGER.finer("ACTIVATING POLICY FOR MC " + tmp);
    startPol.activate();

    // Set the expiry and free it up
    tmp.finishActivating(startPol);
  }

  public void finishActivating(EnforcementPolicy p) {
    static_finishActivating(this, p);
  }

  private static void static_finishActivating(MetricContract tmp, EnforcementPolicy p) {
    // Set the expiry and free it up
    //Logging.METRICS_LOGGER.finer("ACTIVATING MC " + tmp + " IN " +
    //    TransactionManager.getInstance().getCurrentLog());
    if (TransactionManager.getInstance().inTxn()) {
      tmp.currentPolicy = p;
      tmp.$expiry = tmp.currentPolicy.expiry();
      Contract.static_activate(tmp);
      if (tmp.$expiry >= System.currentTimeMillis()) {
        tmp.currentPolicy.apply(tmp);
        tmp.getMetric().addContract(tmp);
      }
    } else {
      atomic {
        tmp.currentPolicy = p;
        tmp.$expiry = tmp.currentPolicy.expiry();
        Contract.static_activate(tmp);
        if (tmp.$expiry >= System.currentTimeMillis()) {
          tmp.currentPolicy.apply(tmp);
          tmp.getMetric().addContract(tmp);
        }
      }
    }
    //Logging.METRICS_LOGGER.finer("ACTIVATED MC " + tmp + " IN " +
    //    TransactionManager.getInstance().getCurrentLog());
  }

  public void finishActivating_remote(fabric.lang.security.Principal caller, EnforcementPolicy p) {
    finishActivating(p);
  }

  /**
   * Update this contract's expiration time to stay valid in response to a
   * change in the value of the {@link Subject}s used for enforcing this
   * {@link Contract}. Revokes, extends, and updates the enforcement strategy
   * as needed.
   */
  /*@Override*/
  protected boolean refresh(boolean asyncExtension) {
    // If we haven't activated yet, this is a bad operation.  Stop.
    if (!isActivated()) {
      //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INACTIVE");
      return false;
    }

    long currentTime = System.currentTimeMillis();
    // Refresh the current policy and update to the new expiration time
    // if it's long enough.
    if (currentPolicy != null) {
      long curExpiry = currentPolicy.expiry();
      if (curExpiry >= currentTime) {
        boolean result = update(curExpiry);
        //Logging.METRICS_LOGGER.log(Level.FINER, "DEFENDING " + this + " WITH " +
        //    currentPolicy);
        return result;
      }
    }
    // Async extensions should only update to a new expiry using the existing
    // policy.
    if (asyncExtension)
      return false;

    // If we're moving to a new policy we need to be holding the reconfig locks.
    TransactionManager tm = TransactionManager.getInstance();
    if (!this.lock.held()) {
      // If we're not holding it, mark this as needing to be acquired and retry.
      tm.addContractToAcquire(this);
      TransactionID current = tm.getCurrentTid();
      if (current != null) {
        while (current.parent != null) current = current.parent;
        throw new TransactionRestartingException(
            new TransactionID(current.topTid));
      }
    }

    // Otherwise we're finding a new policy, so we're coordinating.
    //Logging.METRICS_LOGGER.log(Level.FINER, "COORDINATING FOR {0} IN {1}",
    //    new java.lang.Object native[] { this, tm.getCurrentTid() });
    tm.markCoordination();

    // Find a new policy now that we have the lock.
    EnforcementPolicy oldPolicy = currentPolicy;
    EnforcementPolicy newPolicy = metric.policy(this.rate, this.base, $getStore());

    // Wait to unapply so that metric is still tracked if this was
    // directly enforced previously
    if (oldPolicy != null && !oldPolicy.equals(newPolicy))
      oldPolicy.unapply(this);
    currentPolicy = newPolicy;
    currentPolicy.activate();
    // Don't apply if the new policy is already expired.
    long newExpiry = currentPolicy.expiry();
    boolean result = update(newExpiry);
    if (newExpiry >= currentTime)
      currentPolicy.apply(this);
    //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT TRUE");
    return result;
  }

  /**
   * Check if this implies another {@link MetricContract} being considered.
   *
   * @param otherMetric
   *        the {@link Metric} the other {@link MetricContract} would
   *        assert a bound on
   * @param otherRate
   *        the rate of the bound that would be used by the other
   *        {@link MetricContract}
   * @param otherBase
   *        the base of the bound that would be used by the other
   *        {@link MetricContract}
   * @return true iff this would imply (and therefore) can enforce another
   *       {@link MetricContract} with the given metric and bound.
   */
  public boolean implies(Metric otherMetric, double otherRate, double otherBase) {
    if (!getMetric().equals(otherMetric)
        || this.rate < otherRate
        || this.base < otherBase)
      return false;
    return valid();
  }

  /**
   * Check if this implies the other {@link MetricContract}.
   *
   * @param other
   *        the other {@link MetricContract} this is being compared with
   * @return true iff this would imply (and therefore) can enforce other for
   *       the entire duration of other.
   */
  public boolean implies(MetricContract other) {
    return valid(other.getExpiry())
        && implies(other.getMetric(), other.rate, other.base);
  }

  /**
   * Check if this enforces the <strong>same</strong> bound as another
   * {@link MetricContract} being considered. Attempts to refresh this
   * contract if it's gone stale and would otherwise enforce the bound.
   *
   * @param otherMetric
   *        the {@link Metric} the other {@link MetricContract} would
   *        assert a bound on
   * @param otherRate
   *        the rate of the bound that would be used by the other
   *        {@link MetricContract}
   * @param otherBase
   *        the base of the bound that would be used by the other
   *        {@link MetricContract}
   * @return true iff this enforces another {@link MetricContract} with the
   *       given parameters.
   */
  public boolean enforces(Metric otherMetric, double otherRate, double otherBase) {
    if (!getMetric().equals(otherMetric) || otherRate != rate || otherBase != base)
      return false;
    return valid();
  }

  /*@Override*/
  public String toString() {
    return getMetric().toString() + " >= " + rate + " * t + " + base + " until " + getExpiry();
  }

  /*@Override*/
  public SampledMetric[] getLeafSubjects() {
    Metric m = getMetric();
    if (m instanceof SampledMetric) {
      return new SampledMetric[0];
    } else if (m instanceof DerivedMetric) {
      return ((DerivedMetric) m).getLeafSubjects();
    } else {
      throw new IllegalStateException(
          "All metrics should be either sampled or derived!");
    }
  }

  /**
   * {@inheritDoc}
   *
   * Stops observing any evidence used by the current enforcement policy (by
   * unapplying the policy).
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
    static_removeObserver(this, obs);
  }

  private static void static_removeObserver(MetricContract tmp, Observer obs) {
    if (TransactionManager.getInstance().inTxn()) {
      Contract.static_removeObserver(tmp, obs);
      if (!tmp.isObserved()) {
        if (tmp.currentPolicy != null)
          tmp.currentPolicy.unapply(tmp);
      }
    } else {
      atomic {
        Contract.static_removeObserver(tmp, obs);
        if (!tmp.isObserved()) {
          if (tmp.currentPolicy != null)
            tmp.currentPolicy.unapply(tmp);
        }
      }
    }
  }

  /*@Override*/
  public void acquireReconfigLocks() {
    //Logging.METRICS_LOGGER.finer("ACQUIRING LOCK AT " + this + " IN " +
    //    TransactionManager.getInstance().getCurrentLog());
    this.lock.acquire();
    this.currentPolicy.acquireReconfigLocks();
  }

  /**
   * Create a proxy for this contract on the given store.
   */
  public ProxyMetricContract getProxyContract(final Store proxyStore) {
    return static_getProxyContract(this, proxyStore);
  }

  private static ProxyMetricContract static_getProxyContract(MetricContract tmp, final Store proxyStore) {
    ProxyMetricContract proxy = null;
    if (TransactionManager.getInstance().inTxn()) {
      proxy = new ProxyMetricContract@proxyStore().fabric$metrics$contracts$MetricContract$ProxyMetricContract$(tmp);
    } else {
      atomic {
        proxy = new ProxyMetricContract@proxyStore().fabric$metrics$contracts$MetricContract$ProxyMetricContract$(tmp);
      }
    }
    if (tmp.isActivated())
      proxy.activate();
    return proxy;
  }

  /**
   * A MetricContract which basically acts as a proxy for another MetricContract
   * to allow local access on another store while the contract is valid.
   *
   * Basically operates by using the original MetricContract as the only witness
   * of this metric contract.
   */
  protected static class ProxyMetricContract extends MetricContract {

    // The MetricContract this acts as a proxy for.
    protected final MetricContract target;

    /**
     * @param target
     *        the {@link MetricContract} this proxies
     */
    public ProxyMetricContract fabric$metrics$contracts$MetricContract$ProxyMetricContract$(MetricContract target) {
      this.target = target;
      fabric$metrics$contracts$MetricContract$(target.metric, target.rate, target.base);
      return this;
    }

    /*@Override*/
    public void activate() {
      static_activate(this);
    }

    private static void static_activate(ProxyMetricContract tmp) {
      if (TransactionManager.getInstance().inTxn()) {
        if (tmp.isActivated())
          return;
      } else {
        atomic {
          if (tmp.isActivated())
            return;
        }
      }

      // TODO: Should this watch the target or just mirror the target's policy.
      EnforcementPolicy targetPol = null;
      //Logging.METRICS_LOGGER.finer("CREATING POLICY FOR MC " + tmp);
      if (TransactionManager.getInstance().inTxn()) {
        final Store s = tmp.$getStore();
        targetPol = new WitnessPolicy@s().fabric$metrics$contracts$enforcement$WitnessPolicy$(new MetricContract native[] { tmp.target });
      } else {
        atomic {
          final Store s = tmp.$getStore();
          targetPol = new WitnessPolicy@s().fabric$metrics$contracts$enforcement$WitnessPolicy$(new MetricContract native[] { tmp.target });
        }
      }
      //Logging.METRICS_LOGGER.finer("ACTIVATING POLICY FOR MC " + tmp);
      targetPol.activate();

      //Logging.METRICS_LOGGER.finer("ACTIVATING MC " + tmp + " IN " +
      //    TransactionManager.getInstance().getCurrentLog());
      if (TransactionManager.getInstance().inTxn()) {
        final Store s = tmp.$getStore();
        tmp.currentPolicy = targetPol;
        tmp.$expiry = tmp.currentPolicy.expiry();
        Contract.static_activate(tmp);
        if (tmp.$expiry >= System.currentTimeMillis()) {
          tmp.currentPolicy.apply(tmp);
          // XXX: Do I need to do this?
          tmp.getMetric().addContract(tmp);
        }
      } else {
        atomic {
          final Store s = tmp.$getStore();
          tmp.currentPolicy = targetPol;
          tmp.$expiry = tmp.currentPolicy.expiry();
          Contract.static_activate(tmp);
          if (tmp.$expiry >= System.currentTimeMillis()) {
            tmp.currentPolicy.apply(tmp);
            // XXX: Do I need to do this?
            tmp.getMetric().addContract(tmp);
          }
        }
      }
      //Logging.METRICS_LOGGER.finer("ACTIVATED MC " + tmp + " IN " +
      //    TransactionManager.getInstance().getCurrentLog());
    }

    /*@Override*/
    protected boolean refresh(boolean asyncExtension) {
      // If we haven't activated yet, this is a bad operation.  Stop.
      if (!isActivated()) {
        //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INACTIVE");
        return false;
      }

      long currentTime = System.currentTimeMillis();
      // Refresh the current policy and update to the new expiration time
      // if it's long enough.
      if (currentPolicy != null) {
        long curExpiry = currentPolicy.expiry();
        boolean result = update(curExpiry);
        //Logging.METRICS_LOGGER.log(Level.FINER, "DEFENDING " + this + " WITH " +
        //    currentPolicy);
        return result;
      }

      // Proxy's don't switch policies if the above didn't work, it's dead and
      // keeps the current expiration.
      return false;
    }

    /*@Override*/
    public String toString() {
      return "Proxy @ " + $getStore() + " for " + target + " until " + $expiry;
    }

    /*@Override*/
    public ProxyMetricContract getProxyContract(final Store proxyStore) {
      return static_getProxyContract(this, proxyStore);
    }

    private static ProxyMetricContract static_getProxyContract(ProxyMetricContract tmp, final Store proxyStore) {
      ProxyMetricContract proxy = null;
      if (TransactionManager.getInstance().inTxn()) {
        proxy = new ProxyMetricContract@proxyStore().fabric$metrics$contracts$MetricContract$ProxyMetricContract$(tmp.target);
      } else {
        atomic {
          proxy = new ProxyMetricContract@proxyStore().fabric$metrics$contracts$MetricContract$ProxyMetricContract$(tmp.target);
        }
      }
      if (tmp.isActivated())
        proxy.activate();
      return proxy;
    }
  }
}

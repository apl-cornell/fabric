package fabric.metrics.contracts;

import fabric.util.Collections;
import fabric.util.Set;

import fabric.metrics.DerivedMetric;
import fabric.metrics.Metric;
import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.common.TransactionID;
import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A contract asserting that a {@link Metric}'s value is above or below a
 * vectorized boundary expression <code>r⃗ * (t - startTime) + b⃗</code> until
 * the associated expriation time.
 * <p>
 * This class follows the subject-observer pattern. An instance is an observer
 * of either a {@link Metric} or a set of {@link MetricEqualityContract}s and can be
 * observed by other {@link Contract}s.
 */
public class MetricEqualityContract extends Contract {

  protected final Metric metric;
  public final double value;

  /**
   * @param metric
   *        the {@link Metric} this contract asserts a bound on
   * @param value
   *        the value of the equality
   * @param base
   *        the base of the bound this {@link MetricEqualityContract} asserts on
   *        metric.
   */
  public MetricEqualityContract fabric$metrics$contracts$MetricEqualityContract$(Metric metric, double value) {
    this.metric = metric;
    this.value = value;
    fabric$metrics$contracts$Contract$();
    return this;
  }

  /** @return the {@link Metric} that this contract observes. */
  public Metric getMetric() {
    return metric;
  }

  /*@Override*/
  public void activate() {
    MetricEqualityContract.static_activate(this);
  }

  private static void static_activate(MetricEqualityContract tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.isActivated())
        return;
    } else {
      atomic {
        if (tmp.isActivated())
          return;
      }
    }

    // Refresh the stats being used
    // Commented out for now.  If it's run here it's going to repeat work in
    // subcalls.
    //metric.refreshWeakEstimates();

    // Determine children
    //Logging.METRICS_LOGGER.finer("CREATING A POLICY FOR MC " + tmp);
    if (TransactionManager.getInstance().inTxn()) {
      // Don't use a weak value if we're in a transaction already, this would
      // mean we're running a contract creation in a single transaction and at
      // that point, we're going to contend on the strongly consistent values
      // regardless.
      tmp.currentPolicy = tmp.metric.equalityPolicy(tmp.value, false, tmp.$getStore());
    } else {
      atomic {
        tmp.currentPolicy = tmp.metric.equalityPolicy(tmp.value, false, tmp.$getStore());
      }
    }

    // activate the policy here to avoid accidentally making it atomic below.
    tmp.currentPolicy.activate();

    // Set the expiry and free it up
    if (TransactionManager.getInstance().inTxn()) {
      Contract.static_activate(tmp);
      tmp.getMetric().addContract(tmp);
    } else {
      atomic {
        Contract.static_activate(tmp);
        tmp.getMetric().addContract(tmp);
      }
    }
  }

  /**
   * Update this contract's expiration time to stay valid in response to a
   * change in the value of the {@link Subject}s used for enforcing this
   * {@link Contract}. Revokes, extends, and updates the enforcement strategy
   * as needed.
   */
  /*@Override*/
  protected boolean refresh(boolean asyncExtension) {
    // If we haven't activated yet, this is a bad operation.  Stop.
    if (!isActivated()) {
      //Logging.METRICS_LOGGER.log(Level.FINER, "CONTRACT INACTIVE");
      return false;
    }

    long currentTime = System.currentTimeMillis();
    // Refresh the current policy and update to the new expiration time
    // if it's long enough.
    if (currentPolicy != null) {
      long curExpiry = currentPolicy.expiry();
      if (curExpiry >= currentTime) {
        //Logging.METRICS_LOGGER.log(Level.FINER, "DEFENDING " + this + " WITH " +
        //    currentPolicy);
        return update(curExpiry);
      }
    }
    // Async extensions should only update to a new expiry using the existing
    // policy.
    if (asyncExtension)
      return false;

    // If we're moving to a new policy we need to be holding the reconfig locks.
    TransactionManager tm = TransactionManager.getInstance();
    //this.lock.acquire();
    acquireReconfigLocks();

    // Otherwise we're finding a new policy, so we're coordinating.
    //Logging.METRICS_LOGGER.log(Level.FINER, "COORDINATING FOR {0} IN {1}",
    //    new java.lang.Object native[] { this, tm.getCurrentTid() });
    tm.markCoordination();

    // Find a new policy now that we have the lock.
    EnforcementPolicy oldPolicy = currentPolicy;
    EnforcementPolicy newPolicy = metric.equalityPolicy(this.value, $getStore());

    // Wait to unapply so that metric is still tracked if this was
    // directly enforced previously
    if (oldPolicy != null && !oldPolicy.equals(newPolicy))
      oldPolicy.unapply(this);
    newPolicy.activate();
    // Don't apply if the new policy is already expired.
    long newExpiry = newPolicy.expiry();
    boolean result = update(newExpiry);
    if (newExpiry >= currentTime) {
      currentPolicy = newPolicy;
      currentPolicy.apply(this);
    } else {
      currentPolicy = null;
    }
    return result;
  }

  /*@Override*/
  public boolean implies(Metric otherMetric, double otherRate, double otherBase) {
    if (!getMetric().equals(otherMetric) || !Bound.test(otherRate, otherBase,
          this.value, System.currentTimeMillis()))
      return false;
    return valid();
  }

  /*@Override*/
  public String toString() {
    return getMetric().toString() + " == " + value + " until " + getExpiry();
  }

  /*@Override*/
  public SampledMetric[] getLeafSubjects() {
    Metric m = getMetric();
    if (m instanceof SampledMetric) {
      final Store local = Worker.getWorker().getLocalStore();
      return new SampledMetric[] @local { (SampledMetric) m };
    } else if (m instanceof DerivedMetric) {
      return ((DerivedMetric) m).getLeafSubjects();
    } else {
      throw new IllegalStateException(
          "All metrics should be either sampled or derived!");
    }
  }
}

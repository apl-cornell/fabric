package fabric.metrics.contracts.enforcement;

import fabric.metrics.Metric;
import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.Contract;
import fabric.worker.transaction.TransactionManager;

//import fabric.common.Logging;

/**
 * An {@link EnforcementPolicy} for enforcing a {@link Contract}s by
 * checking every update to the associated {@link Metric}, using equality to a
 * given value.
 */
public class DirectEqualityPolicy implements EnforcementPolicy {

  /** The metric the associated contract bounds. */
  public final Metric metric;
  /** The rate of the bound enforced by the associated contract. */
  public final double value;
  /** The currently calculated expiration time to use for the contract. */
  private long expiry;
  /** Is this policy active and being enforced? */
  private boolean activated;

  /**
   * @param metric
   *            the Metric the associated contract is bounding.
   * @param rate
   *            the rate of the bound enforced by the associated contract.
   * @param base
   *            the base of the bound enforced by the associated contract.
   */
  public DirectEqualityPolicy fabric$metrics$contracts$enforcement$DirectEqualityPolicy$(Metric metric, double value) {
    this.metric = metric;
    this.value = value;
    fabric$lang$Object$();
    this.expiry = -1;
    this.activated = false;
    return this;
  }

  /*@Override*/
  public void activate() {
    static_activate(this);
  }

  private static void static_activate(DirectEqualityPolicy tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.activated)
        return;
      tmp.refresh();
    } else {
      atomic {
        if (tmp.activated)
          return;
        tmp.refresh();
      }
    }
  }

  /*@Override*/
  public void refresh() {
    static_refresh(this);
  }

  private static void static_refresh(DirectEqualityPolicy tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      // First check if we actually can enforce it in the current state.
      if (tmp.value != tmp.metric.value()) {
        tmp.expiry = 0;
      } else {
        tmp.expiry = Long.MAX_VALUE;
      }
      tmp.activated = true;
    } else {
      atomic {
        // First check if we actually can enforce it in the current state.
        if (tmp.value != tmp.metric.value()) {
          tmp.expiry = 0;
        } else {
          tmp.expiry = Long.MAX_VALUE;
        }
        tmp.activated = true;
      }
    }
  }

  /*@Override*/
  public long expiry() {
    refresh();
    return expiry;
  }

  /*@Override*/
  public void apply(Contract mc) {
    static_apply(this, mc);
  }

  private static void static_apply(DirectEqualityPolicy tmp, Contract mc) {
    // TODO: Should this be atomic?
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.activated)
        tmp.activate();
      tmp.metric.addObserver(mc);
    } else {
      atomic {
        if (!tmp.activated)
          tmp.activate();
        tmp.metric.addObserver(mc);
      }
    }
    //Logging.METRICS_LOGGER.finer("DEFENDING " + mc + " WITH " + tmp);
  }

  /*@Override*/
  public void unapply(Contract mc) {
    metric.removeObserver(mc);
  }

  /*@Override*/
  public String toString() {
    return "Directly watching " + metric + " == " + value;
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (!(other instanceof DirectEqualityPolicy))
      return false;
    DirectEqualityPolicy that = (DirectEqualityPolicy) other;
    return this.metric.equals(that.metric) && this.value == that.value;
  }

  /*@Override*/
  public void acquireReconfigLocks() {
  }
}

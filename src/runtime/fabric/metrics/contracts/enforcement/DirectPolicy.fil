package fabric.metrics.contracts.enforcement;

import fabric.metrics.Metric;
import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.Contract;
import fabric.worker.metrics.StatsMap;
import fabric.worker.transaction.TransactionManager;

//import fabric.common.Logging;

/**
 * An {@link EnforcementPolicy} for enforcing a {@link Contract}s by
 * checking every update to the associated {@link Metric}.
 */
public class DirectPolicy implements EnforcementPolicy {

  /** The metric the associated contract bounds. */
  public final Metric metric;
  /** The rate of the bound enforced by the associated contract. */
  public final double rate;
  /** The base of the bound enforced by the associated contract. */
  public final double base;
  /** The currently calculated expiration time to use for the contract. */
  private long expiry;
  /** Is this policy active and being enforced? */
  private boolean activated;

  /**
   * @param metric
   *            the Metric the associated contract is bounding.
   * @param rate
   *            the rate of the bound enforced by the associated contract.
   * @param base
   *            the base of the bound enforced by the associated contract.
   */
  public DirectPolicy fabric$metrics$contracts$enforcement$DirectPolicy$(Metric metric, double rate, double base) {
    this.metric = metric;
    this.rate = rate;
    this.base = base;
    fabric$lang$Object$();
    this.expiry = -1;
    this.activated = false;
    return this;
  }

  /*@Override*/
  public void activate(StatsMap weakStats) {
    static_activate(this, weakStats);
  }

  private static void static_activate(DirectPolicy tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.activated)
        return;
      // TODO: get and pass along stats map
      tmp.refresh(weakStats);
    } else {
      atomic {
        if (tmp.activated)
          return;
        // TODO: get and pass along stats map
        tmp.refresh(weakStats);
      }
    }
  }

  /*@Override*/
  public void refresh(StatsMap weakStats) {
    static_refresh(this, weakStats);
  }

  private static void static_refresh(DirectPolicy tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      // First check if we actually can enforce it in the current state.
      long currentTime = System.currentTimeMillis();
      long trueTime = Bound.trueExpiry(tmp.rate, tmp.base, tmp.metric.value(), currentTime);
      if (trueTime < currentTime && currentTime <= tmp.expiry) {
        tmp.expiry = 0;
      } else {
        long hedgedTime = tmp.hedged(currentTime, weakStats);
        if (tmp.expiry <= trueTime) {
          // Don't hedge below current expiry if we're not stuttering
          // (shifting down the expiry due to true expiry being lower than
          // advertised time).
          hedgedTime = Math.max(tmp.expiry, hedgedTime);
        }
        tmp.expiry = hedgedTime;
      }
      tmp.activated = true;
    } else {
      atomic {
        // First check if we actually can enforce it in the current state.
        long currentTime = System.currentTimeMillis();
        long trueTime = Bound.trueExpiry(tmp.rate, tmp.base, tmp.metric.value(), currentTime);
        if (trueTime < currentTime && currentTime <= tmp.expiry) {
          tmp.expiry = 0;
        } else {
          long hedgedTime = tmp.hedged(currentTime, weakStats);
          if (tmp.expiry <= trueTime) {
            // Don't hedge below current expiry if we're not stuttering
            // (shifting down the expiry due to true expiry being lower than
            // advertised time).
            hedgedTime = Math.max(tmp.expiry, hedgedTime);
          }
          tmp.expiry = hedgedTime;
        }
        tmp.activated = true;
      }
    }
  }

  // How many standard deviations to use for hedging calculations.
  // Note: larger value => less aggressive extensions => lower revocations
  // Note: smaller value => longer extensions => less chatter
  private static final double HEDGE_FACTOR = 3;

  /**
   * Using the associated {@link Metric's} statistics and some tuning
   * constants, figure out a time to advertise given the current time.
   *
   * @param time
   *        the current time we're calculating this hedged expiration at
   * @return an appropriately conservative (unlikely to be retracted again)
   *         time to advertise to other nodes in the system for this contract.
   */
  private long hedged(long time, StatsMap weakStats) {
    double r = rate;
    double b = Bound.value(rate, base, time);
    // Always use *correct* value for value
    double x = metric.value();
    // Use weak v and n, x is the only part that needs to be exact.
    double v = weakStats.containsKey(metric) ? weakStats.getVelocity(metric) : metric.velocity(weakStats);
    double n = weakStats.containsKey(metric) ? weakStats.getNoise(metric) : metric.noise(weakStats);

    // True expiry: time this would fail with no changes to the current
    // value. This is the latest time we can safely advertise as the
    // expiration.
    long hedgedResult = Bound.trueExpiry(rate, base, metric.value(), time);

    // Non-positive rate bounds don't need to be hedged, they should always
    // stay true in the absence of updates.
    if (r <= 0) {
      return hedgedResult;
    }

    // Account for the desired number of standard deviations and scale based
    // on how long trueExpiry is from here.
    n *= (HEDGE_FACTOR * HEDGE_FACTOR);
    if (hedgedResult < Long.MAX_VALUE) {
      // Use enough standard deviations that we actually might cross the
      // boundary, if the set amount wasn't enough.
      n = Math.max(n, 4 * (v - r) * (x - b));
    }

    // Solving for extremal point
    double minYs = 0.0;
    long min = -1;
    if (v > 0) {
      minYs = x - (n / (4 * v));
      min = Bound.trueExpiry(rate, base, minYs, time);

      // If the extremal point on the hedged curve is valid and below the
      // current point, use the time for that.
      if (minYs < x && Bound.test(rate, base, minYs, time)) {
        hedgedResult = Math.min(min, hedgedResult);
        // System.out.println("MIN HEDGE TO " + hedgedResult + " FOR " +
        // x + ", " + v + ", " + n + " AT " + time + " VS " + r + "t + "
        // + b);
        // Fast path, a min point will be earlier than an intersect, if
        // it exists and is above the bound.
        return hedgedResult;
      }
    }

    // Solving intersection by using rotated parametric formula
    double mb = x - b;
    double vr = v - r;
    long intersect = -1;
    if (vr != 0) {
      // Intersection calculation found in notes.
      double factor = 1.0 / (2.0 * vr * vr);
      double constant = n - 2 * mb * vr;
      double discriminant = Math.sqrt(n) * Math.sqrt(n - 4.0 * mb * vr);

      if (!Double.isNaN(discriminant)) {
        double first = factor * (constant + discriminant) + time;
        double second = factor * (constant - discriminant) + time;
        if (first > 0 || second > 0) {
          if (first < 0) {
            intersect = (long) second;
          } else if (second < 0) {
            intersect = (long) first;
          } else {
            intersect = (long) Math.min(first, second);
          }
          // System.out.println("INTERSECT HEDGE TO " + hedgedResult
          // + " FOR " + x + ", " + v + ", " + n + " AT " + time
          // + " VS " + r + "t + " + b);
          hedgedResult = Math.min(intersect, hedgedResult);
        }
      }
    } else if (n > 0) {
      // Intersection found in notes.
      hedgedResult = Math.min(hedgedResult, ((long) (mb * mb / n)));
    }

    return hedgedResult;
  }

  /**
   * Using the associated {@link Metric's} statistics and some tuning
   * constants, figure out a time to advertise given the current time.
   *
   * @param metric
   *        The metric being bounded
   * @param rate
   *        The adaptive multiplier for the bound
   * @param base
   *        The base value for the bound (relative to t = 0)
   * @param time
   *        the current time we're calculating this hedged expiration at
   * @return an appropriately conservative (unlikely to be retracted again)
   *         time to advertise to other nodes in the system for this contract.
   */
  public static long hedgedEstimate(Metric metric, double rate, double base, long time, StatsMap weakStats) {
    double r = rate;
    double b = Bound.value(rate, base, time);
    double x = weakStats.containsKey(metric) ? weakStats.getValue(metric) : metric.value(weakStats);
    // Use weak v and n, x is the only part that needs to be exact.
    double v = weakStats.containsKey(metric) ? weakStats.getVelocity(metric) : metric.velocity(weakStats);
    double n = weakStats.containsKey(metric) ? weakStats.getNoise(metric) : metric.noise(weakStats);

    // True expiry: time this would fail with no changes to the current
    // value. This is the latest time we can safely advertise as the
    // expiration.
    long hedgedResult = Bound.trueExpiry(rate, base, x, time);

    // Account for the desired number of standard deviations and scale based
    // on how long trueExpiry is from here.
    n *= (HEDGE_FACTOR * HEDGE_FACTOR);
    if (hedgedResult < Long.MAX_VALUE) {
      // Use enough standard deviations that we actually might cross the
      // boundary, if the set amount wasn't enough.
      n = Math.max(n, 4 * (v - r) * (x - b));
    }

    // Solving for extremal point
    double minYs = 0.0;
    long min = -1;
    if (v > 0) {
      minYs = x - (n / (4 * v));
      min = Bound.trueExpiry(rate, base, minYs, time);

      // If the extremal point on the hedged curve is valid and below the
      // current point, use the time for that.
      if (minYs < x && Bound.test(rate, base, minYs, time)) {
        hedgedResult = Math.min(min, hedgedResult);
        // System.out.println("MIN HEDGE TO " + hedgedResult + " FOR " +
        // x + ", " + v + ", " + n + " AT " + time + " VS " + r + "t + "
        // + b);
        // Fast path, a min point will be earlier than an intersect, if
        // it exists and is above the bound.
        return hedgedResult;
      }
    }

    // Solving intersection by using rotated parametric formula
    double mb = x - b;
    double vr = v - r;
    long intersect = -1;
    if (vr != 0) {
      // Intersection calculation found in notes.
      double factor = 1.0 / (2.0 * vr * vr);
      double constant = n - 2 * mb * vr;
      double discriminant = Math.sqrt(n) * Math.sqrt(n - 4.0 * mb * vr);

      if (!Double.isNaN(discriminant)) {
        double first = factor * (constant + discriminant) + time;
        double second = factor * (constant - discriminant) + time;
        if (first > 0 || second > 0) {
          if (first < 0) {
            intersect = (long) second;
          } else if (second < 0) {
            intersect = (long) first;
          } else {
            intersect = (long) Math.min(first, second);
          }
          // System.out.println("INTERSECT HEDGE TO " + hedgedResult
          // + " FOR " + x + ", " + v + ", " + n + " AT " + time
          // + " VS " + r + "t + " + b);
          hedgedResult = Math.min(intersect, hedgedResult);
        }
      }
    } else if (n > 0) {
      // Intersection found in notes.
      hedgedResult = Math.min(hedgedResult, ((long) (mb * mb / n)));
    }

    return hedgedResult;
  }

  /*@Override*/
  public long expiry(StatsMap weakStats) {
    // TODO get and pass along stats map
    refresh(weakStats);
    return expiry;
  }

  /*@Override*/
  public void apply(Contract mc) {
    static_apply(this, mc);
  }

  private static void static_apply(DirectPolicy tmp, Contract mc) {
    // TODO: Should this be atomic?
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.activated)
        tmp.activate(StatsMap.emptyStats());
      tmp.metric.addObserver(mc);
    } else {
      atomic {
        if (!tmp.activated)
          tmp.activate(StatsMap.emptyStats());
        tmp.metric.addObserver(mc);
      }
    }
    //Logging.METRICS_LOGGER.finer("DEFENDING " + mc + " WITH " + tmp);
  }

  /*@Override*/
  public void unapply(Contract mc) {
    metric.removeObserver(mc);
  }

  /*@Override*/
  public String toString() {
    return "Directly watching " + metric + " >= " + rate + " * t + " + base;
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (!(other instanceof DirectPolicy))
      return false;
    DirectPolicy that = (DirectPolicy) other;
    return this.metric.equals(that.metric) && this.rate == that.rate &&
      this.base == that.base;
  }

  /*@Override*/
  public void acquireReconfigLocks() {
  }
}

package fabric.metrics.contracts.enforcement;

import fabric.metrics.Metric;
import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;

/**
 * An {@link EnforcementPolicy} for enforcing a {@link MetricContract}s by
 * checking every update to the associated {@link Metric}.
 */
public class DirectPolicy extends EnforcementPolicy {

  /** The metric the associated contract bounds. */
  public final Metric metric;
  /** The bound enforced by the associated contract. */
  public final Bound bound;
  /** The currently calculated expiration time to use for the contract. */
  private long expiry;
  /** Is this policy active and being enforced? */
  private boolean activated;

  /**
   * @param metric
   *            the Metric the associated contract is bounding.
   * @param bound
   *            the bound enforced by the associated contract.
   */
  public DirectPolicy fabric$metrics$contracts$enforcement$DirectPolicy$(Metric metric, Bound bound) {
    this.metric = metric;
    this.bound = bound;
    fabric$metrics$contracts$enforcement$EnforcementPolicy$();
    this.expiry = -1;
    this.activated = false;
    return this;
  }

  /*@Override*/
  public void activate() {
    atomic {
      if (activated)
        return;
    }
  }

  /*@Override*/
  public void refresh() {
    atomic {
      // First check if we actually can enforce it in the current state.
      long currentTime = System.currentTimeMillis();
      long trueTime = bound.trueExpiry(metric, currentTime);
      if (trueTime < currentTime && currentTime <= expiry) {
        expiry = 0;
      } else {
        long hedgedTime = hedged(currentTime);
        if (expiry <= trueTime) {
          // Don't hedge below current expiry if we're not stuttering
          // (shifting down the expiry due to true expiry being lower than
          // advertised time).
          hedgedTime = Math.max(expiry, hedgedTime);
        }
        expiry = hedgedTime;
      }
      activated = true;
    }
  }

  // How many standard deviations to use for hedging calculations.
  // Note: larger value => less aggressive extensions => lower revocations
  // Note: smaller value => longer extensions => less chatter
  private static final double HEDGE_FACTOR = 3;

  /**
   * Using the associated {@link Metric's} statistics and some tuning
   * constants, figure out a time to advertise given the current time.
   *
   * @param time
   *        the current time we're calculating this hedged expiration at
   * @return an appropriately conservative (unlikely to be retracted again)
   *         time to advertise to other nodes in the system for this contract.
   */
  private long hedged(long time) {
    double r = bound.rate;
    double b = bound.value(time);
    double x = metric.value();
    // Use weak v and n, x is the only part that needs to be exact.
    double v = metric.velocity(true);
    double n = metric.noise(true);

    // True expiry: time this would fail with no changes to the current
    // value. This is the latest time we can safely advertise as the
    // expiration.
    long hedgedResult = bound.trueExpiry(metric, time);

    // Non-positive rate bounds don't need to be hedged, they should always
    // stay true in the absence of updates.
    if (r <= 0) {
      return hedgedResult;
    }

    // Account for the desired number of standard deviations and scale based
    // on how long trueExpiry is from here.
    n *= (HEDGE_FACTOR * HEDGE_FACTOR);
    if (hedgedResult < Long.MAX_VALUE) {
      // Use enough standard deviations that we actually might cross the
      // boundary, if the set amount wasn't enough.
      n = Math.max(n, 4 * (v - r) * (x - b));
    }

    // Solving for extremal point
    double minYs = 0.0;
    long min = -1;
    if (v > 0) {
      minYs = x - (n / (4 * v));
      min = bound.trueExpiry(minYs, time);

      // If the extremal point on the hedged curve is valid and below the
      // current point, use the time for that.
      if (minYs < x && bound.test(minYs, time)) {
        hedgedResult = Math.min(min, hedgedResult);
        // System.out.println("MIN HEDGE TO " + hedgedResult + " FOR " +
        // x + ", " + v + ", " + n + " AT " + time + " VS " + r + "t + "
        // + b);
        // Fast path, a min point will be earlier than an intersect, if
        // it exists and is above the bound.
        return hedgedResult;
      }
    }

    // Solving intersection by using rotated parametric formula
    double mb = x - b;
    double vr = v - r;
    long intersect = -1;
    if (vr != 0) {
      // Intersection calculation found in notes.
      double factor = 1.0 / (2.0 * vr * vr);
      double constant = n - 2 * mb * vr;
      double discriminant = Math.sqrt(n) * Math.sqrt(n - 4.0 * mb * vr);

      if (!Double.isNaN(discriminant)) {
        double first = factor * (constant + discriminant) + time;
        double second = factor * (constant - discriminant) + time;
        if (first > 0 || second > 0) {
          if (first < 0) {
            intersect = (long) second;
          } else if (second < 0) {
            intersect = (long) first;
          } else {
            intersect = (long) Math.min(first, second);
          }
          // System.out.println("INTERSECT HEDGE TO " + hedgedResult
          // + " FOR " + x + ", " + v + ", " + n + " AT " + time
          // + " VS " + r + "t + " + b);
          hedgedResult = Math.min(intersect, hedgedResult);
        }
      }
    } else if (n > 0) {
      // Intersection found in notes.
      hedgedResult = Math.min(hedgedResult, ((long) (mb * mb / n)));
    }

    return hedgedResult;
  }

  /*@Override*/
  public long expiry() {
    refresh();
    return expiry;
  }

  /*@Override*/
  public void apply(MetricContract mc) {
    // TODO: Should this be atomic?
    atomic {
      if (!activated)
        activate();
      metric.addObserver(mc);
    }
    fabric.common.Logging.METRICS_LOGGER.finer("DEFENDING " + mc + " WITH " + this);
  }

  /*@Override*/
  public void unapply(MetricContract mc) {
    metric.removeObserver(mc);
  }

  /*@Override*/
  public String toString() {
    return "Directly watching " + metric + " " + bound;
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (!(other instanceof DirectPolicy))
      return false;
    DirectPolicy that = (DirectPolicy) other;
    return this.metric.equals(that.metric) && this.bound.equals(that.bound);
  }
}

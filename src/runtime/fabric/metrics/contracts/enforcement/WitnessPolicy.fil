package fabric.metrics.contracts.enforcement;

import java.util.Arrays;

import fabric.metrics.contracts.Contract;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.metrics.ImmutableContractsVector;
import fabric.worker.metrics.StatsMap;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

import java.util.logging.Level;
import fabric.common.Logging;
import java.io.StringWriter;
import java.io.PrintWriter;

/**
 * An {@link EnforcementPolicy} which enforces a {@link Contract} by
 * relying on a set of <em>witnesses</em>, other {@link Contract}s that in
 * conjunction imply the enforced {@link Contract}.
 */
public class WitnessPolicy implements EnforcementPolicy {

  /** The set of {@link Contract}s used to enforce this policy. */
  public final ImmutableContractsVector witnesses;

  /** Is this currently actively enforced? */
  private boolean activated;

  /**
   * @param witnesses
   *        the array of {@link Contract}s used to enforce this
   *        policy. If any of the witnesses weren't already active, they
   *        are {@link Contract#activate() activated} here.
   */
  public WitnessPolicy fabric$metrics$contracts$enforcement$WitnessPolicy$(Contract native[] witnesses) {
    this.witnesses = ImmutableContractsVector.createVector(witnesses);
    fabric$lang$Object$();
    this.activated = false;
    return this;
  }

  /*@Override*/
  public void activate(StatsMap weakStats) {
    static_activate(this, weakStats);
  }

  private static void static_activate(WitnessPolicy tmp, StatsMap weakStats) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.activated)
        return;
    } else {
      atomic {
        if (tmp.activated)
          return;
      }
    }
    if (TransactionManager.getInstance().getCurrentLog() != null) {
      for (int i = 0; i < tmp.witnesses.length(); i++) {
        tmp.witnesses.get(i).refresh(false, weakStats);
      }
    } else {
      Future native[] futures = new Future native[tmp.witnesses.length() - 1];
      // First, refresh the subterm stats.
      for (int i = 1; i < tmp.witnesses.length(); i++) {
          // TODO: Add remote worker to call
          final Contract w = tmp.witnesses.get(i);
          Callable c = null;
          atomic {
            c = new Activator().fabric$metrics$contracts$enforcement$WitnessPolicy$Activator$(w, weakStats);
          }
          //Logging.METRICS_LOGGER.finer("SUBMITTING CHILD " + w +
          //    " IN PARALLEL IN " + Thread.currentThread());
          futures[i - 1] = service.submit(c);
      }
      // Run first witness in this thread.
      Contract w = tmp.witnesses.get(0);
      if (!(w.$getStore().name().equals(Worker.getWorkerName()))) {
        RemoteWorker worker = Worker.getWorker().getWorker(w.$getStore().name());
        w.refresh_remote@worker(null, false, weakStats);
      } else {
        w.refresh(false, weakStats);
      }
      for (int i = 0; i < futures.length; i++) {
        try {
          futures[i].get();
        } catch (ExecutionException e) {
          StringWriter sw = new StringWriter();
          PrintWriter pw = new PrintWriter(sw);
          e.printStackTrace(pw);
          String sStackTrace = sw.toString();
          Logging.METRICS_LOGGER.warning("Failure of parallel activation child: " + e + " Stack\n" + sStackTrace);
        } catch (InterruptedException e) {
          StringWriter sw = new StringWriter();
          PrintWriter pw = new PrintWriter(sw);
          e.printStackTrace(pw);
          String sStackTrace = sw.toString();
          Logging.METRICS_LOGGER.warning("Failure of parallel activation child: " + e + " Stack\n" + sStackTrace);
        }
      }
    }
    if (TransactionManager.getInstance().inTxn()) {
      tmp.activated = true;
    } else {
      atomic {
        tmp.activated = true;
      }
    }
  }

  private static class Activator implements Callable {
    final Contract w;
    final StatsMap weakStats;

    public Activator fabric$metrics$contracts$enforcement$WitnessPolicy$Activator$(Contract w, StatsMap weakStats) {
      this.w = w;
      this.weakStats = weakStats;
      fabric$lang$Object$();
      return this;
    }

    public java.lang.Object call() {
      //Logging.METRICS_LOGGER.finer("ACTIVATING CHILD " + w + " IN PARALLEL IN "
      //    + Thread.currentThread());
      if (!(w.$getStore().name().equals(Worker.getWorkerName()))) {
        RemoteWorker worker = Worker.getWorker().getWorker(w.$getStore().name());
        w.refresh_remote@worker(null, false, weakStats);
      } else {
        w.refresh(false, weakStats);
      }
      return null;
    }
  }

  private static final int POOL_SIZE = 32;
  private static final ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);

  /*@Override*/
  public long expiry(StatsMap weakStats) {
    return static_expiry(this, weakStats);
  }

  private static long static_expiry(WitnessPolicy tmp, StatsMap weakStats) {
    if (!tmp.activated)
      tmp.activate(weakStats);
    long expiry = -1;
    boolean atLeastOnce = false;
    if (TransactionManager.getInstance().inTxn()) {
      for (int i = 0; i < tmp.witnesses.length(); i++) {
        if (!atLeastOnce || tmp.witnesses.get(i).getExpiry() < expiry) {
          atLeastOnce = true;
          expiry = tmp.witnesses.get(i).getExpiry();
        }
      }
    } else {
      atomic {
        for (int i = 0; i < tmp.witnesses.length(); i++) {
          if (!atLeastOnce || tmp.witnesses.get(i).getExpiry() < expiry) {
            atLeastOnce = true;
            expiry = tmp.witnesses.get(i).getExpiry();
          }
        }
      }
    }
    return expiry;
  }

  /*@Override*/
  public void apply(Contract mc) {
    if (!activated)
      activate(StatsMap.emptyStats());
    for (int i = 0; i < witnesses.length(); i++) {
      witnesses.get(i).addObserver(mc);
    }
    //Logging.METRICS_LOGGER.finer("DEFENDING " + mc + " WITH " + this);
  }

  /*@Override*/
  public void unapply(Contract mc) {
    for (int i = 0; i < witnesses.length(); i++) {
      witnesses.get(i).removeObserver(mc);
    }
  }

  /*@Override*/
  public String toString() {
    return Arrays.deepToString(witnesses.array());
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (!(other instanceof WitnessPolicy))
      return false;
    WitnessPolicy that = (WitnessPolicy) other;
    return this.witnesses.equals(that.witnesses);
  }

  /*@Override*/
  public void acquireReconfigLocks() {
    //for (int i = 0; i < witnesses.length(); i++) {
    //  witnesses.get(i).acquireReconfigLocks();
    //}
  }
}

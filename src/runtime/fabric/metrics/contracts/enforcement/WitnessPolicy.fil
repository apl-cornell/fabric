package fabric.metrics.contracts.enforcement;

import fabric.util.Arrays;

import fabric.metrics.contracts.Contract;
import fabric.metrics.contracts.MetricContract;
import fabric.worker.transaction.TransactionManager;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

//import fabric.common.Logging;

/**
 * An {@link EnforcementPolicy} which enforces a {@link MetricContract} by
 * relying on a set of <em>witnesses</em>, other {@link MetricContract}s that in
 * conjunction imply the enforced {@link MetricContract}.
 */
public class WitnessPolicy extends EnforcementPolicy {

  /** The set of {@link MetricContract}s used to enforce this policy. */
  public final MetricContract[] witnesses;

  /** Is this currently actively enforced? */
  private boolean activated;

  /**
   * @param witnesses
   *        the array of {@link MetricContract}s used to enforce this
   *        policy. If any of the witnesses weren't already active, they
   *        are {@link Contract#activate() activated} here.
   */
  public WitnessPolicy fabric$metrics$contracts$enforcement$WitnessPolicy$(MetricContract native[] witnesses) {
    fabric$metrics$contracts$enforcement$EnforcementPolicy$();
    this.witnesses = new MetricContract[witnesses.length];
    for (int i = 0; i < witnesses.length; i++)
      this.witnesses[i] = witnesses[i];
    this.activated = false;
    return this;
  }

  /*@Override*/
  public void activate() {
    static_activate(this);
  }

  private static void static_activate(WitnessPolicy tmp) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.activated)
        return;
    } else {
      atomic {
        if (tmp.activated)
          return;
      }
    }
    if (TransactionManager.getInstance().getCurrentLog() != null) {
      for (int i = 0; i < tmp.witnesses.length; i++) {
        tmp.witnesses[i].activate();
      }
    } else {
      Future native[] futures = new Future native[tmp.witnesses.length];
      // First, refresh the subterm stats.
      for (int i = 0; i < futures.length; i++) {
          // TODO: Add remote worker to call
          final MetricContract w = tmp.witnesses[i];
          Callable c = null;
          atomic {
            c = new Activator().fabric$metrics$contracts$enforcement$WitnessPolicy$Activator$(w);
          }
          //Logging.METRICS_LOGGER.finer("SUBMITTING CHILD " + w +
          //    " IN PARALLEL IN " + Thread.currentThread());
          futures[i] = service.submit(c);
      }
      for (int i = 0; i < futures.length; i++) {
        try {
          futures[i].get();
        } catch (ExecutionException e) {
          // TODO: Log this if it happens.
        } catch (InterruptedException e) {
          // TODO: Log this if it happens.
        }
      }
    }
    if (TransactionManager.getInstance().inTxn()) {
      tmp.activated = true;
    } else {
      atomic {
        tmp.activated = true;
      }
    }
  }

  private static class Activator implements Callable {
    final MetricContract w;

    public Activator fabric$metrics$contracts$enforcement$WitnessPolicy$Activator$(MetricContract w) {
      this.w = w;
      fabric$lang$Object$();
      return this;
    }

    public java.lang.Object call() {
      //Logging.METRICS_LOGGER.finer("ACTIVATING CHILD " + w + " IN PARALLEL IN "
      //    + Thread.currentThread());
      if (!(w.$getStore().name().equals(Worker.getWorkerName()))) {
        RemoteWorker worker = Worker.getWorker().getWorker(w.$getStore().name());
        w.activate_remote@worker(null);
      } else {
        w.activate();
      }
      return null;
    }
  }

  private static final int POOL_SIZE = 32;
  private static final ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);

  /*@Override*/
  public long expiry() {
    return static_expiry(this);
  }

  private static long static_expiry(WitnessPolicy tmp) {
    long expiry = -1;
    boolean atLeastOnce = false;
    if (TransactionManager.getInstance().inTxn()) {
      for (int i = 0; i < tmp.witnesses.length; i++) {
        if (!atLeastOnce || tmp.witnesses[i].getExpiry() < expiry) {
          atLeastOnce = true;
          expiry = tmp.witnesses[i].getExpiry();
        }
      }
    } else {
      atomic {
        for (int i = 0; i < tmp.witnesses.length; i++) {
          if (!atLeastOnce || tmp.witnesses[i].getExpiry() < expiry) {
            atLeastOnce = true;
            expiry = tmp.witnesses[i].getExpiry();
          }
        }
      }
    }
    return expiry;
  }

  /*@Override*/
  public void apply(MetricContract mc) {
    if (!activated)
      activate();
    for (int i = 0; i < witnesses.length; i++) {
      witnesses[i].addObserver((fabric.metrics.util.Observer) mc.fetch());
    }
    //Logging.METRICS_LOGGER.finer("DEFENDING " + mc + " WITH " + this);
  }

  /*@Override*/
  public void unapply(MetricContract mc) {
    for (int i = 0; i < witnesses.length; i++) {
      witnesses[i].removeObserver(mc);
    }
  }

  /*@Override*/
  public String toString() {
    return Arrays.deepToString(witnesses);
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (!(other instanceof WitnessPolicy))
      return false;
    WitnessPolicy that = (WitnessPolicy) other;
    return this.witnesses.equals(that.witnesses);
  }

  /*@Override*/
  public void acquireReconfigLocks() {
    for (int i = 0; i < witnesses.length; i++) {
      witnesses[i].acquireReconfigLocks();
    }
  }
}

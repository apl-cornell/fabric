package fabric.metrics.contracts.warranties;

import fabric.util.HashSet;
import fabric.util.Set;

import fabric.metrics.Metric;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.Observer;
import fabric.worker.transaction.TransactionManager;

//import java.util.logging.Level;
//import fabric.common.Logging;

/**
 * A computation that uses {@link Contract}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Contract}.
 * This helps to ensure that the {@link Contract} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  protected final WarrantyValue/*<T>*/ curVal;

  /**
   * Create a new updated result paired with a contract that would enforce it
   * after this call.
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyValue/*<T>*/ updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time) {
    return apply(time, true);
  }

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @param autoRetry
   *            flag indicating whether the computation should automatically
   *            retry if the contract goes stale before returning.
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time, boolean autoRetry) {
    return static_apply(this, time, autoRetry);
  }

  private static WarrantyValue/*T*/ static_apply(WarrantyComp tmp, long time, boolean autoRetry) {
    // TODO recompute but don't replace if current one is pending and we
    // compute the same value
    //Logging.METRICS_LOGGER.log(Level.FINER, "Starting " + tmp);
    boolean loop = false;
    if (TransactionManager.getInstance().inTxn()) {
      loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
    } else {
      atomic {
        loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
      }
    }
    //if (loop)
    //  Logging.METRICS_LOGGER.log(Level.FINER, "Recomputing " + tmp);
    //else
    //  Logging.METRICS_LOGGER.log(Level.FINER, "Reusing " + tmp);
    while (loop) {
      //Logging.METRICS_LOGGER.log(Level.FINER, "Iterating " + tmp);

      WarrantyValue newVal = tmp.updatedVal(System.currentTimeMillis());
      //Logging.METRICS_LOGGER.log(Level.FINER, "Updating " + tmp + " to " +
      //    newVal);

      // If newVal's contract is null, this indicates that the programmer
      // doesn't want to memoize the result with a treaty.
      if (newVal.contract == null)
        return newVal;

      /* Commented out because API now expectes updatedVal to have run
       * refreshWeakEstimates before returning.
       *
       * Estimated here so that we don't repeat work on activations of sub
       * treaties.
       */

      //Logging.METRICS_LOGGER.log(Level.FINER, "Activating " + newVal + " for " +
      //    tmp);
      if (TransactionManager.getInstance().getCurrentLog() == null && !(newVal.contract.$getStore().name().equals(Worker.getWorkerName()))) {
        RemoteWorker w = Worker.getWorker().getWorker(newVal.contract.$getStore().name());
        newVal.contract.activate_remote@w(null);
      } else {
        newVal.contract.activate();
      }

      //Logging.METRICS_LOGGER.log(Level.FINER, "Setting " + tmp + " to " + newVal
      //    + " and Observing");
      if (TransactionManager.getInstance().inTxn()) {
        // Need to double check we weren't scooped by another caller.  If we
        // were, don't bother with our new value and go with the existing value.
        if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
          tmp.curVal.value = newVal.value;
          if (tmp.curVal.contract != newVal.contract) {
            if (tmp.curVal.contract != null) {
              tmp.curVal.contract.removeObserver(tmp);
            }
            tmp.curVal.contract = newVal.contract;
            tmp.curVal.contract.addObserver(tmp);
          }
        }
      } else {
        atomic {
          // Need to double check we weren't scooped by another caller.  If we
          // were, don't bother with our new value and go with the existing value.
          if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
            tmp.curVal.value = newVal.value;
            if (tmp.curVal.contract != newVal.contract) {
              if (tmp.curVal.contract != null) {
                tmp.curVal.contract.removeObserver(tmp);
              }
              tmp.curVal.contract = newVal.contract;
              tmp.curVal.contract.addObserver(tmp);
            }
          }
        }
      }
      //Logging.METRICS_LOGGER.log(Level.FINER, "Updated to " + tmp.curVal);

      if (TransactionManager.getInstance().inTxn()) {
        // Only bother to retry if we're supposed to and we don't have a valid
        // contract.
        loop = tmp.curVal.contract == null || (autoRetry && !tmp.curVal.contract.valid());
      } else {
        atomic {
          // Only bother to retry if we're supposed to and we don't have a valid
          // contract.
          loop = tmp.curVal.contract == null || (autoRetry && !tmp.curVal.contract.valid());
        }
      }
    }
    //Logging.METRICS_LOGGER.log(Level.FINER, "Finished " + tmp + " with " +
    //    tmp.curVal);
    return tmp.curVal;
  }

  /*@Override*/
  public SampledMetric[] getLeafSubjects() {
    // TODO: Is this right?
    if (curVal.contract != null)
      return curVal.contract.getLeafSubjects();
    return new SampledMetric[0];
  }

  /*@Override*/
  public boolean handleUpdates() {
    // TODO: Is this right?
    long time = System.currentTimeMillis();
    if (curVal.contract == null) {
      // This shouldn't be possible
      return false;
    } else if (!curVal.contract.valid(time)) {
      curVal.contract.removeObserver(this);
      return true;
    }
    return false;
  }

  /**
   * Copy result for a proxy computation to use.
   *
   * Default is to just copy the reference.  Implementations should override
   * this to make and return copy on the proxyStore.
   */
  protected Object makeProxyResult(WarrantyValue val, final Store proxyStore) {
    return val.value;
  }

  /**
   * Make a warranty comp that resides on another store that can be used locally
   * at that store when a memoized result is available.
   */
  public ProxyComp makeProxy(final Store proxyStore) {
    return static_makeProxy(this, proxyStore);
  }

  private static ProxyComp static_makeProxy(WarrantyComp tmp, final Store proxyStore) {
    if (TransactionManager.getInstance().inTxn()) {
      return new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
    } else {
      ProxyComp rtn = null;
      atomic {
        rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
      }
      return rtn;
    }
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    fabric$lang$Object$();
    this.curVal = new WarrantyValue().fabric$metrics$contracts$warranties$WarrantyValue$(null, null);
    return this;
  }

  /**
   * A "Proxy" computation to allow for avoiding contacting a remote store for
   * memoized results.
   */
  protected static class ProxyComp extends WarrantyComp {
    // The computation this is proxying for.
    protected final WarrantyComp baseComputation;
    protected MetricContract oldBaseContract;

    protected ProxyComp fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(WarrantyComp baseComputation) {
      this.baseComputation = baseComputation;
      fabric$metrics$contracts$warranties$WarrantyComp$();
      return this;
    }

    /*@Override*/
    protected WarrantyValue/*<T>*/ updatedVal(long time) {
      // XXX: This shouldn't be called...
      return this.baseComputation.updatedVal(time);
    }

    /*@Override*/
    public WarrantyValue/*T*/ apply(long time, boolean autoRetry) {
      return static_apply(this, time, autoRetry);
    }

    /*@Override?*/
    private static WarrantyValue/*T*/ static_apply(ProxyComp tmp, long time, boolean autoRetry) {
      //Logging.METRICS_LOGGER.log(Level.FINER, "Starting proxy " + tmp);
      boolean loop = false;
      if (TransactionManager.getInstance().inTxn()) {
        loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
      } else {
        atomic {
          loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
        }
      }
      //if (loop)
      //  Logging.METRICS_LOGGER.log(Level.FINER, "Recomputing proxy " + tmp);
      //else
      //  Logging.METRICS_LOGGER.log(Level.FINER, "Reusing proxy " + tmp);
      while (loop) {
        //Logging.METRICS_LOGGER.log(Level.FINER, "Iterating proxy " + tmp);

        WarrantyValue newVal = tmp.baseComputation.apply(System.currentTimeMillis(), autoRetry);

        // If newVal's contract is null, this indicates that the programmer
        // doesn't want to memoize the result with a treaty.
        if (newVal.contract == null)
          return newVal;

        //Logging.METRICS_LOGGER.log(Level.FINER, "Setting proxy " + tmp + " to "
        //    + newVal + " and Observing");
        if (TransactionManager.getInstance().inTxn()) {
          // Need to double check we weren't scooped by another caller.  If we
          // were, don't bother with our new value and go with the existing value.
          if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
            tmp.curVal.value = tmp.baseComputation.makeProxyResult(newVal, tmp.$getStore());
            if (tmp.oldBaseContract != newVal.contract) {
              if (tmp.curVal.contract != null) {
                tmp.curVal.contract.removeObserver(tmp);
              }
              tmp.oldBaseContract = newVal.contract;
              tmp.curVal.contract = newVal.contract.getProxyContract(tmp.$getStore());
              tmp.curVal.contract.addObserver(tmp);
            }
          }
        } else {
          atomic {
            // Need to double check we weren't scooped by another caller.  If we
            // were, don't bother with our new value and go with the existing value.
            if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
              tmp.curVal.value = tmp.baseComputation.makeProxyResult(newVal, tmp.$getStore());
              if (tmp.oldBaseContract != newVal.contract) {
                if (tmp.curVal.contract != null) {
                  tmp.curVal.contract.removeObserver(tmp);
                }
                tmp.oldBaseContract = newVal.contract;
                tmp.curVal.contract = newVal.contract.getProxyContract(tmp.$getStore());
                tmp.curVal.contract.addObserver(tmp);
              }
            }
          }
        }
        //Logging.METRICS_LOGGER.log(Level.FINER, "Updated proxy to " +
        //    tmp.curVal);

        if (TransactionManager.getInstance().inTxn()) {
          // Only bother to retry if we're supposed to and we don't have a valid
          // contract.
          loop = tmp.curVal.contract == null || (autoRetry && !tmp.curVal.contract.valid());
        } else {
          atomic {
            // Only bother to retry if we're supposed to and we don't have a valid
            // contract.
            loop = tmp.curVal.contract == null || (autoRetry && !tmp.curVal.contract.valid());
          }
        }
      }
      //Logging.METRICS_LOGGER.log(Level.FINER, "Finished proxy " + tmp + " with "
      //    + tmp.curVal);
      return tmp.curVal;
    }

    /*@Override*/
    public ProxyComp makeProxy(final Store proxyStore) {
      return static_makeProxy(this, proxyStore);
    }

    private static ProxyComp static_makeProxy(ProxyComp tmp, final Store proxyStore) {
      if (TransactionManager.getInstance().inTxn()) {
        // Avoid unnecessary indirection.
        return new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp.baseComputation);
      } else {
        ProxyComp rtn = null;
        atomic {
          // Avoid unnecessary indirection.
          rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp.baseComputation);
        }
        return rtn;
      }
    }
  }
}

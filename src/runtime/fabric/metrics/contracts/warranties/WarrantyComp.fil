package fabric.metrics.contracts.warranties;

import fabric.util.ArrayList;

import fabric.metrics.Metric;
import fabric.metrics.contracts.Contract;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableSet;
import fabric.worker.transaction.TransactionManager;

/**
 * A computation that uses {@link Contract}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Contract}.
 * This helps to ensure that the {@link Contract} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ extends AbstractSubject implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  protected final WarrantyValue/*<T>*/ curVal;

  // TODO: Consider keeping a cache of per-store proxies?
  /** The set of proxy computations for this computation. */
  protected ImmutableSet/*<ProxyComp>*/ proxies;

  /**
   * Create a new updated result paired with a contract that would enforce it
   * after this call.
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyValue/*<T>*/ updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time) {
    return apply(time, true);
  }

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @param autoRetry
   *            flag indicating whether the computation should automatically
   *            retry if the contract goes stale before returning.
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time, boolean autoRetry) {
    return static_apply(this, time, autoRetry);
  }

  private static WarrantyValue/*T*/ static_apply(WarrantyComp tmp, long time, boolean autoRetry) {
    // TODO recompute but don't replace if current one is pending and we
    // compute the same value
    //Logging.METRICS_LOGGER.log(Level.FINER, "Starting " + tmp);
    boolean loop = false;
    if (TransactionManager.getInstance().inTxn()) {
      loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
    } else {
      atomic {
        loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
      }
    }
    //if (loop)
    //  Logging.METRICS_LOGGER.log(Level.FINER, "Recomputing " + tmp);
    //else
    //  Logging.METRICS_LOGGER.log(Level.FINER, "Reusing " + tmp);
    while (loop) {
      //Logging.METRICS_LOGGER.log(Level.FINER, "Iterating " + tmp);

      WarrantyValue newVal = tmp.updatedVal(System.currentTimeMillis());
      //Logging.METRICS_LOGGER.log(Level.FINER, "Updating " + tmp + " to " +
      //    newVal);

      // If newVal's contract is null, this indicates that the programmer
      // doesn't want to memoize the result with a treaty.
      if (newVal.contract == null)
        return newVal;

      /* Commented out because API now expectes updatedVal to have run
       * refreshWeakEstimates before returning.
       *
       * Estimated here so that we don't repeat work on activations of sub
       * treaties.
       */

      //Logging.METRICS_LOGGER.log(Level.FINER, "Activating " + newVal + " for " +
      //    tmp);
      if (TransactionManager.getInstance().getCurrentLog() == null && !(newVal.contract.$getStore().name().equals(Worker.getWorkerName()))) {
        RemoteWorker w = Worker.getWorker().getWorker(newVal.contract.$getStore().name());
        newVal.contract.activate_remote@w(null);
      } else {
        newVal.contract.activate();
      }

      //Logging.METRICS_LOGGER.log(Level.FINER, "Setting " + tmp + " to " + newVal
      //    + " and Observing");
      if (TransactionManager.getInstance().inTxn()) {
        // Need to double check we weren't scooped by another caller.  If we
        // were, don't bother with our new value and go with the existing value.
        if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
          tmp.curVal.value = newVal.value;
          if (tmp.curVal.contract != newVal.contract) {
            if (tmp.curVal.contract != null) {
              tmp.curVal.contract.removeObserver(tmp);
            }
            tmp.curVal.contract = newVal.contract;
            tmp.curVal.contract.addObserver(tmp);
            // New contract, so update proxies too.
            for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
              ProxyComp p = (ProxyComp) iter.next();
              // Stop monitoring the old value.
              if (p.curVal.contract != null) {
                p.curVal.contract.removeObserver(p);
              }
              p.curVal.value = newVal.value;
              p.curVal.contract = newVal.contract.getProxyContract(p.$getStore());
              p.curVal.contract.addObserver(p);
            }
          }
        }
      } else {
        atomic {
          // Need to double check we weren't scooped by another caller.  If we
          // were, don't bother with our new value and go with the existing value.
          if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
            tmp.curVal.value = newVal.value;
            if (tmp.curVal.contract != newVal.contract) {
              if (tmp.curVal.contract != null) {
                tmp.curVal.contract.removeObserver(tmp);
              }
              tmp.curVal.contract = newVal.contract;
              tmp.curVal.contract.addObserver(tmp);
              // New contract, so update proxies too.
              for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
                ProxyComp p = (ProxyComp) iter.next();
                // Stop monitoring the old value.
                if (p.curVal.contract != null) {
                  p.curVal.contract.removeObserver(p);
                }
                p.curVal.value = newVal.value;
                p.curVal.contract = newVal.contract.getProxyContract(p.$getStore());
                p.curVal.contract.addObserver(p);
              }
            }
          }
        }
      }
      //Logging.METRICS_LOGGER.log(Level.FINER, "Updated to " + tmp.curVal);

      if (TransactionManager.getInstance().inTxn()) {
        // Only bother to retry if we're supposed to and we don't have a valid
        // contract.
        loop = autoRetry && tmp.curVal.contract != null && !tmp.curVal.contract.valid();
      } else {
        atomic {
          // Only bother to retry if we're supposed to and we don't have a valid
          // contract.
          loop = autoRetry && tmp.curVal.contract != null && !tmp.curVal.contract.valid();
        }
      }
    }
    //Logging.METRICS_LOGGER.log(Level.FINER, "Finished " + tmp + " with " +
    //    tmp.curVal);
    return tmp.curVal;
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    // TODO: Is this right?
    if (curVal.contract != null)
      return curVal.contract.getLeafSubjects();
    return ImmutableMetricsVector.emptyVector();
  }

  /*@Override*/
  public boolean handleUpdates() {
    // TODO: Is this right?
    long time = System.currentTimeMillis();
    if (curVal.contract == null) {
      // This shouldn't be possible
      return false;
    } else if (!curVal.contract.valid(time)) {
      curVal.contract.removeObserver(this);
      // try to get a new value
      apply(System.currentTimeMillis(), false);
      return true;
    }
    return false;
  }

  /**
   * Copy result for a proxy computation to use.
   *
   * Default is to just copy the reference.  Implementations should override
   * this to make and return copy on the proxyStore.
   */
  protected Object makeProxyResult(WarrantyValue val, final Store proxyStore) {
    return val.value;
  }

  /**
   * Make a warranty comp that resides on another store that can be used locally
   * at that store when a memoized result is available.
   */
  public ProxyComp makeProxy(final Store proxyStore) {
    return static_makeProxy(this, proxyStore);
  }

  private static ProxyComp static_makeProxy(WarrantyComp tmp, final Store proxyStore) {
    if (TransactionManager.getInstance().inTxn()) {
      ProxyComp p = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
      tmp.proxies = tmp.proxies.add(p);
      return p;
    } else {
      ProxyComp rtn = null;
      atomic {
        rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
        tmp.proxies = tmp.proxies.add(rtn);
      }
      return rtn;
    }
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    // Default to assuming up to 4 proxies
    this.curVal = new WarrantyValue().fabric$metrics$contracts$warranties$WarrantyValue$(null, null);
    this.proxies = ImmutableSet.emptySet();
    fabric$metrics$util$AbstractSubject$();
    return this;
  }

  /**
   * A "Proxy" computation to allow for avoiding contacting a remote store for
   * memoized results.
   */
  protected static class ProxyComp extends WarrantyComp {
    // The computation this is proxying for.
    protected final WarrantyComp baseComputation;

    protected ProxyComp fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(WarrantyComp baseComputation) {
      this.baseComputation = baseComputation;
      fabric$metrics$contracts$warranties$WarrantyComp$();
      this.baseComputation.addObserver(this);
      return this;
    }

    /*@Override*/
    protected WarrantyValue/*<T>*/ updatedVal(long time) {
      // XXX: This should never be called, proxy always reverts back to the
      // primary.
      return this.baseComputation.updatedVal(time);
    }

    /*@Override*/
    public WarrantyValue/*T*/ apply(long time, boolean autoRetry) {
      return static_apply(this, time, autoRetry);
    }

    /*@Override?*/
    private static WarrantyValue/*T*/ static_apply(ProxyComp tmp, long time, boolean autoRetry) {
      // Proxy either has a cached result or it should return a new result from
      // the primary (which will update the proxy's cached result.
      if (tmp.curVal.contract != null && tmp.curVal.contract.valid()) {
        return tmp.curVal;
      }
      return tmp.baseComputation.apply(time, autoRetry);
    }

    /*@Override*/
    public ProxyComp makeProxy(final Store proxyStore) {
      return static_makeProxy(this, proxyStore);
    }

    private static ProxyComp static_makeProxy(ProxyComp tmp, final Store proxyStore) {
      if (TransactionManager.getInstance().inTxn()) {
        // Avoid unnecessary indirection.
        return tmp.baseComputation.makeProxy(proxyStore);
      } else {
        ProxyComp rtn = null;
        atomic {
          // Avoid unnecessary indirection.
          rtn = tmp.baseComputation.makeProxy(proxyStore);
        }
        return rtn;
      }
    }
  }
}

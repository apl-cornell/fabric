package fabric.metrics.contracts.warranties;

import fabric.metrics.Metric;
import fabric.metrics.treaties.Treaty;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.WarrantyProposal;
import fabric.worker.metrics.WarrantyValue;
import fabric.worker.metrics.proxies.ProxyMap;
import fabric.worker.transaction.TransactionManager;

import java.util.Iterator;
import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A computation that uses {@link Treaty}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Treaty}.
 * This helps to ensure that the {@link Treaty} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  protected /*T*/ Object curVal;

  /** The currently cached result. */
  protected Treaty curTreaty;

  // TODO: Consider keeping a cache of per-store proxies?
  /** The set of proxy computations for this computation. */
  protected ProxyMap/*<WarrantyComp>*/ proxies;

  /**
   * Flag determining if a new result should be immediately acquired when the
   * current one is invalidated.
   */
  protected final boolean recomputeOnInvalidation;

  /**
   * Flag to change behavior of proxy groups between being proactively updated
   * and lazily updated.  With proactive, all computations get updated when a
   * new treaty becomes available, otherwise each computation individually
   * updates when first called after a treaty becomes possible/available.
   */
  protected final boolean proactive;

  /**
   * Create a new updated proposed result (including a proposed {@link Metric}
   * and {@link TreatyStatement}).
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyProposal updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @return A {@link WarrantyValue} which holds the return value and the
   * treaty associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue apply(long time) {
    return apply(time, true);
  }

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @param autoRetry
   *            flag indicating whether the computation should automatically
   *            retry if the treaty goes stale before returning.
   * @return A {@link WarrantyValue} which holds the return value and the
   * treaty associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue apply(long time, boolean autoRetry) {
    return static_apply(this, time, autoRetry);
  }

  private static WarrantyValue static_apply(WarrantyComp tmp, long time, boolean autoRetry) {
    TransactionManager.getInstance().resolveObservations();
    int i = 0;
    boolean loop = static_dropOldValue(tmp);
    while (loop) {
      i++;
      Logging.METRICS_LOGGER.log(Level.FINE, "RUNNING ATTEMPT " + i + " OF " + tmp + " IN " + Thread.currentThread());
      if (!tmp.proactive) {
        for (java.util.Iterator iter = tmp.proxies.values().iterator(); iter.hasNext();) {
          // If any proxy has a good value, steal it
          WarrantyComp proxy = (WarrantyComp) iter.next();
          if (!static_dropOldValue(proxy)) {
            Object newVal = proxy.curVal;
            Treaty newTreaty = proxy.curTreaty;
            //Logging.METRICS_LOGGER.log(Level.INFO, "USING RESULT FROM " + proxy + " IN " + Thread.currentThread());
            // Try the value.  If we're handling updates, it's possible the proxy
            // value is not good, despite appearances, so don't consider it done
            // unless the result "sticks"
            static_setNewValue(tmp, newVal, newTreaty);
            if (!static_dropOldValue(tmp)) {
              break;
            }
          }
        }
      }

      if (tmp.curTreaty == null) {
        Logging.METRICS_LOGGER.log(Level.FINE, "GENERATING RESULT FOR " + tmp + " IN " + Thread.currentThread());
        // Nobody had the result memoized, do it the old fashioned way.
        WarrantyProposal computed = tmp.updatedVal(System.currentTimeMillis());

        // If newVal's treaty is null, tmp indicates that the programmer
        // doesn't want to memoize the result with a treaty.
        if (computed.metric == null) {
          TransactionManager.getInstance().stats.addMsg("Memoized: false");
          return WarrantyValue.newValue(computed.value, null);
        }

        // Otherwise, updatedVal doesn't return the treaty refreshed, so
        // refresh it now.
        Logging.METRICS_LOGGER.log(Level.FINE, "ACTIVATING RESULT FOR " + tmp + " IN " + Thread.currentThread());
        RemoteWorker w = Worker.getWorker().getWorker(computed.metric.$getStore().name());
        Treaty activatedTreaty = null;
        if (TransactionManager.getInstance().inTxn()) {
          activatedTreaty = computed.metric.createTreaty(computed.predicate, computed.weakStats);
        } else {
          activatedTreaty = computed.metric.createTreaty_remote@w(null, computed.predicate, computed.weakStats);
        }

        Logging.METRICS_LOGGER.log(Level.FINE, "SETTING RESULT FOR " + tmp + " IN " + Thread.currentThread());
        static_setNewValue(tmp, computed.value, activatedTreaty);
        if (tmp.proactive) {
          for (java.util.Iterator iter = tmp.proxies.values().iterator(); iter.hasNext();) {
            // Update proxies to new value
            WarrantyComp proxy = (WarrantyComp) iter.next();
            static_setNewValue(proxy, computed.value, activatedTreaty);
          }
        }
      }

      // Only bother to retry if we're supposed to and we don't have a valid
      // treaty.
      loop = autoRetry && static_dropOldValue(tmp);
      if (!loop)
        TransactionManager.getInstance().stats.addMsg("Memoized: true");
    }
    return WarrantyValue.newValue(tmp.curVal, tmp.curTreaty);
  }

  private static boolean static_dropOldValue(WarrantyComp tmp) {
    boolean rtn = false;
    if (TransactionManager.getInstance().inTxn()) {
      rtn = tmp.dropOldValue();
    } else {
      atomic {
        rtn = tmp.dropOldValue();
      }
    }
    return rtn;
  }

  private boolean dropOldValue() {
    if (this.curTreaty != null) {
      if (this.curTreaty == null || !this.curTreaty.valid()) {
        if (this.curTreaty != null) this.curTreaty.removeObserver(this);
        this.curTreaty = null;
      }
    }
    return this.curTreaty == null;
  }

  private static void static_setNewValue(WarrantyComp tmp, Object newVal, Treaty newTreaty) {
    if (TransactionManager.getInstance().inTxn()) {
      tmp.setNewValue(newVal, newTreaty);
    } else {
      atomic {
        tmp.setNewValue(newVal, newTreaty);
      }
    }
  }

  private void setNewValue(Object newVal, Treaty newTreaty) {
    if (this.dropOldValue() && newTreaty != null && newTreaty.valid()) {
      this.curVal = newVal;
      this.curTreaty = newTreaty.getProxy(this.$getStore());
      this.curTreaty.addObserver(this);
    }
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    if (curTreaty != null)
      return curTreaty.getLeafSubjects();
    return ImmutableMetricsVector.emptyVector();
  }

  /*@Override*/
  public ImmutableObserverSet handleUpdates() {
    ImmutableObserverSet affected = ImmutableObserverSet.emptySet();
    if (this.dropOldValue()) {
      // try to get a new value
      if (recomputeOnInvalidation)
        apply(System.currentTimeMillis(), false);
    }
    return affected;
  }

  /**
   * Copy result for a proxy computation to use.
   *
   * Default is to just copy the reference.  Implementations should override
   * this to make and return copy on the proxyStore.
   */
  protected Object makeProxyResult(WarrantyValue val, final Store proxyStore) {
    return val.value;
  }

  /**
   * Make a warranty comp that resides on another store that can be used locally
   * at that store when a memoized result is available.
   */
  public WarrantyComp makeProxy(final Store proxyStore) {
    return static_makeProxy(this, proxyStore);
  }

  private static WarrantyComp static_makeProxy(WarrantyComp tmp, final Store proxyStore) {
    WarrantyComp rtn = null;
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.$getStore().equals(proxyStore)) {
        rtn = tmp;
      } else {
        // See if we already have a proxy for that store.
        rtn = (WarrantyComp) tmp.proxies.get(proxyStore);
        if (rtn == null) {
          rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
          // Update proxies
          for (java.util.Iterator iter = tmp.proxies.values().iterator(); iter.hasNext();) {
            WarrantyComp proxy = (WarrantyComp) iter.next();
            proxy.proxies = proxy.proxies.put(rtn.$getStore(), rtn);
          }
          // Update the new proxy
          rtn.proxies = tmp.proxies.put(tmp.$getStore(), tmp);
          // Update tmp
          tmp.proxies = tmp.proxies.put(rtn.$getStore(), rtn);
        }
      }
    } else {
      atomic {
        if (tmp.$getStore().equals(proxyStore)) {
          rtn = tmp;
        } else {
          // See if we already have a proxy for that store.
          rtn = (WarrantyComp) tmp.proxies.get(proxyStore);
          if (rtn == null) {
            rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
            // Update proxies
            for (java.util.Iterator iter = tmp.proxies.values().iterator(); iter.hasNext();) {
              WarrantyComp proxy = (WarrantyComp) iter.next();
              proxy.proxies = proxy.proxies.put(rtn.$getStore(), rtn);
            }
            // Update the new proxy
            rtn.proxies = tmp.proxies.put(tmp.$getStore(), tmp);
            // Update tmp
            tmp.proxies = tmp.proxies.put(rtn.$getStore(), rtn);
          }
        }
      }
    }
    return rtn;
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$(boolean recomputeOnInvalidation, boolean proactive) {
    this.recomputeOnInvalidation = recomputeOnInvalidation;
    this.proactive = proactive;
    fabric$lang$Object$();
    this.proxies = ProxyMap.emptyMap();
    return this;
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$(boolean recomputeOnInvalidation) {
    return fabric$metrics$contracts$warranties$WarrantyComp$(recomputeOnInvalidation, true);
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    return fabric$metrics$contracts$warranties$WarrantyComp$(true, true);
  }

  /**
   * A "Proxy" computation to allow for avoiding contacting a remote store for
   * memoized results.
   */
  protected static class ProxyComp extends WarrantyComp {
    // The computation this is proxying for.
    protected final WarrantyComp baseComputation;

    protected ProxyComp fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(WarrantyComp baseComputation) {
      if (baseComputation instanceof ProxyComp) {
        this.baseComputation = ((ProxyComp) baseComputation).baseComputation;
      } else {
        this.baseComputation = baseComputation;
      }
      fabric$metrics$contracts$warranties$WarrantyComp$(baseComputation.recomputeOnInvalidation, baseComputation.proactive);
      return this;
    }

    /*@Override*/
    protected WarrantyProposal updatedVal(long time) {
      return this.baseComputation.updatedVal(time);
    }
  }
}

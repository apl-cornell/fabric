package fabric.metrics.contracts.warranties;

import fabric.util.ArrayList;

import fabric.metrics.Metric;
import fabric.metrics.contracts.Contract;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.WarrantyValue;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A computation that uses {@link Contract}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Contract}.
 * This helps to ensure that the {@link Contract} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ extends AbstractSubject implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  protected /*T*/ Object curVal;

  /** The currently cached result. */
  protected Contract curContract;

  // TODO: Consider keeping a cache of per-store proxies?
  /** The set of proxy computations for this computation. */
  protected ImmutableSet/*<WarrantyComp>*/ proxies;

  /**
   * Flag determining if a new result should be immediately acquired when the
   * current one is invalidated.
   */
  protected final boolean recomputeOnInvalidation;

  /**
   * Flag to change behavior of proxy groups between being proactively updated
   * and lazily updated.  With proactive, all computations get updated when a
   * new treaty becomes available, otherwise each computation individually
   * updates when first called after a treaty becomes possible/available.
   */
  protected final boolean proactive;

  /**
   * Create a new updated result paired with a contract that would enforce it
   * after this call.
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyValue updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue apply(long time) {
    return apply(time, true);
  }

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @param autoRetry
   *            flag indicating whether the computation should automatically
   *            retry if the contract goes stale before returning.
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue apply(long time, boolean autoRetry) {
    return static_apply(this, time, autoRetry);
  }

  private static WarrantyValue static_apply(WarrantyComp tmp, long time, boolean autoRetry) {
    TransactionManager.getInstance().resolveObservations();
    int i = 0;
    boolean loop = static_dropOldValue(tmp);
    while (loop) {
      i++;
      Logging.METRICS_LOGGER.log(Level.INFO, "RUNNING ATTEMPT " + i + " OF " + tmp + " IN " + Thread.currentThread());
      if (!tmp.proactive) {
        for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
          // If any proxy has a good value, steal it
          WarrantyComp proxy = (WarrantyComp) iter.next();
          if (!static_dropOldValue(proxy)) {
            Object newVal = proxy.curVal;
            Contract newContract = proxy.curContract;
            //Logging.METRICS_LOGGER.log(Level.INFO, "USING RESULT FROM " + proxy + " IN " + Thread.currentThread());
            // Try the value.  If we're handling updates, it's possible the proxy
            // value is not good, despite appearances, so don't consider it done
            // unless the result "sticks"
            static_setNewValue(tmp, newVal, newContract);
            if (!static_dropOldValue(tmp)) {
              break;
            }
          }
        }
      }

      if (tmp.curContract == null) {
        Logging.METRICS_LOGGER.log(Level.INFO, "GENERATING RESULT FOR " + tmp + " IN " + Thread.currentThread());
        // Nobody had the result memoized, do it the old fashioned way.
        WarrantyValue computed = tmp.updatedVal(System.currentTimeMillis());

        // If newVal's contract is null, tmp indicates that the programmer
        // doesn't want to memoize the result with a treaty.
        if (computed.contract == null) {
          TransactionManager.getInstance().stats.addMsg("Memoized: false");
          return computed;
        }

        // Otherwise, updatedVal doesn't return the contract refreshed, so
        // refresh it now.
        Logging.METRICS_LOGGER.log(Level.INFO, "ACTIVATING RESULT FOR " + tmp + " IN " + Thread.currentThread());
        String contractStoreName = computed.contract.$getStore().name();
        if (!TransactionManager.getInstance().inTxn() &&
            !(contractStoreName.equals(Worker.getWorkerName()))) {
          RemoteWorker w = Worker.getWorker().getWorker(contractStoreName);
          computed.contract.refresh_remote@w(null, false, computed.weakStats);
        } else {
          computed.contract.refresh(false, computed.weakStats);
        }

        Logging.METRICS_LOGGER.log(Level.INFO, "SETTING RESULT FOR " + tmp + " IN " + Thread.currentThread());
        static_setNewValue(tmp, computed.value, computed.contract);
        if (tmp.proactive) {
          for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
            // Update proxies to new value
            WarrantyComp proxy = (WarrantyComp) iter.next();
            static_setNewValue(proxy, computed.value, computed.contract);
          }
        }
      }

      // Only bother to retry if we're supposed to and we don't have a valid
      // contract.
      loop = autoRetry && static_dropOldValue(tmp);
      if (!loop)
        TransactionManager.getInstance().stats.addMsg("Memoized: true");
    }
    return WarrantyValue.newValue(tmp.curVal, tmp.curContract);
  }

  private static boolean static_dropOldValue(WarrantyComp tmp) {
    boolean rtn = false;
    if (TransactionManager.getInstance().inTxn()) {
      rtn = tmp.dropOldValue();
    } else {
      atomic {
        rtn = tmp.dropOldValue();
      }
    }
    return rtn;
  }

  private boolean dropOldValue() {
    Contract curContract = this.curContract;
    if (curContract != null && !curContract.valid()) {
      curContract.removeObserver(this);
      this.curContract = null;
      this.$associated = null;
    }
    return this.curContract == null;
  }

  private static void static_setNewValue(WarrantyComp tmp, Object newVal, Contract newContract) {
    if (TransactionManager.getInstance().inTxn()) {
      tmp.setNewValue(newVal, newContract);
    } else {
      atomic {
        tmp.setNewValue(newVal, newContract);
      }
    }
  }

  private void setNewValue(Object newVal, Contract newContract) {
    if (this.dropOldValue() && newContract != null && newContract.valid()) {
      this.curVal = newVal;
      this.curContract = newContract.getProxyContract(this.$getStore());
      this.curContract.addObserver(this);
      this.$associated = ImmutableSet.emptySet().add(this.curContract);
    }
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    if (curContract != null)
      return curContract.getLeafSubjects();
    return ImmutableMetricsVector.emptyVector();
  }

  /*@Override*/
  public boolean handleUpdates() {
    if (this.dropOldValue()) {
      // try to get a new value
      if (recomputeOnInvalidation)
        apply(System.currentTimeMillis(), false);
      return true;
    }
    return false;
  }

  /**
   * Copy result for a proxy computation to use.
   *
   * Default is to just copy the reference.  Implementations should override
   * this to make and return copy on the proxyStore.
   */
  protected Object makeProxyResult(WarrantyValue val, final Store proxyStore) {
    return val.value;
  }

  /**
   * Make a warranty comp that resides on another store that can be used locally
   * at that store when a memoized result is available.
   */
  public WarrantyComp makeProxy(final Store proxyStore) {
    return static_makeProxy(this, proxyStore);
  }

  private static WarrantyComp static_makeProxy(WarrantyComp tmp, final Store proxyStore) {
    WarrantyComp rtn = null;
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.$getStore().equals(proxyStore)) {
        rtn = tmp;
      } else {
        // See if we already have a proxy for that store.
        for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
          WarrantyComp proxy = (WarrantyComp) iter.next();
          if (proxy.$getStore().equals(proxyStore)) {
            rtn = proxy;
            break;
          }
        }
        if (rtn == null) {
          rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
          // Update proxies
          for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
            WarrantyComp proxy = (WarrantyComp) iter.next();
            proxy.proxies = proxy.proxies.add(rtn);
          }
          // Update the new proxy
          rtn.proxies = tmp.proxies.add(tmp);
          // Update tmp
          tmp.proxies = tmp.proxies.add(rtn);
        }
      }
    } else {
      atomic {
        if (tmp.$getStore().equals(proxyStore)) {
          rtn = tmp;
        } else {
          // See if we already have a proxy for that store.
          for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
            WarrantyComp proxy = (WarrantyComp) iter.next();
            if (proxy.$getStore().equals(proxyStore)) {
              rtn = proxy;
              break;
            }
          }
          if (rtn == null) {
            rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
            // Update proxies
            for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
              WarrantyComp proxy = (WarrantyComp) iter.next();
              proxy.proxies = proxy.proxies.add(rtn);
            }
            // Update the new proxy
            rtn.proxies = tmp.proxies.add(tmp);
            // Update tmp
            tmp.proxies = tmp.proxies.add(rtn);
          }
        }
      }
    }
    return rtn;
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$(boolean recomputeOnInvalidation, boolean proactive) {
    this.proxies = ImmutableSet.emptySet();
    this.recomputeOnInvalidation = recomputeOnInvalidation;
    this.proactive = proactive;
    fabric$metrics$util$AbstractSubject$();
    return this;
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$(boolean recomputeOnInvalidation) {
    return fabric$metrics$contracts$warranties$WarrantyComp$(recomputeOnInvalidation, true);
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    return fabric$metrics$contracts$warranties$WarrantyComp$(true, true);
  }

  /**
   * A "Proxy" computation to allow for avoiding contacting a remote store for
   * memoized results.
   */
  protected static class ProxyComp extends WarrantyComp {
    // The computation this is proxying for.
    protected final WarrantyComp baseComputation;

    protected ProxyComp fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(WarrantyComp baseComputation) {
      if (baseComputation instanceof ProxyComp) {
        this.baseComputation = ((ProxyComp) baseComputation).baseComputation;
      } else {
        this.baseComputation = baseComputation;
      }
      fabric$metrics$contracts$warranties$WarrantyComp$(baseComputation.recomputeOnInvalidation, baseComputation.proactive);
      return this;
    }

    /*@Override*/
    protected WarrantyValue updatedVal(long time) {
      return this.baseComputation.updatedVal(time);
    }
  }
}

package fabric.metrics.contracts.warranties;

import fabric.util.ArrayList;

import fabric.metrics.Metric;
import fabric.metrics.contracts.Contract;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableSet;
import fabric.worker.transaction.TransactionManager;

import java.util.logging.Level;
import fabric.common.Logging;

/**
 * A computation that uses {@link Contract}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Contract}.
 * This helps to ensure that the {@link Contract} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ extends AbstractSubject implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  protected final WarrantyValue/*<T>*/ curVal;

  // TODO: Consider keeping a cache of per-store proxies?
  /** The set of proxy computations for this computation. */
  protected ImmutableSet/*<WarrantyComp>*/ proxies;

  /**
   * Create a new updated result paired with a contract that would enforce it
   * after this call.
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyValue/*<T>*/ updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time) {
    return apply(time, true);
  }

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @param autoRetry
   *            flag indicating whether the computation should automatically
   *            retry if the contract goes stale before returning.
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time, boolean autoRetry) {
    return static_apply(this, time, autoRetry);
  }

  // Flag to change behavior of proxy groups between being proactively updated
  // and lazily updated.  With proactive, all computations get updated when a
  // new treaty becomes available, otherwise each computation individually
  // updates when first called after a treaty becomes possible/available.
  private static final boolean PROACTIVE = true;

  private static WarrantyValue/*T*/ static_apply(WarrantyComp tmp, long time, boolean autoRetry) {
    TransactionManager.getInstance().resolveObservations();
    int i = 0;
    boolean loop = tmp.dropOldValue();
    while (loop) {
      i++;
      //Logging.METRICS_LOGGER.log(Level.INFO, "RUNNING ATTEMPT " + i + " OF " + tmp + " IN " + Thread.currentThread());
      WarrantyValue newVal = null;

      if (!PROACTIVE) {
        for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
          // If any proxy has a good value, steal it
          WarrantyComp proxy = (WarrantyComp) iter.next();
          if (!proxy.dropOldValue()) {
            newVal = proxy.curVal;
            //Logging.METRICS_LOGGER.log(Level.INFO, "USING RESULT FROM " + proxy + " IN " + Thread.currentThread());
            // Try the value.  If we're handling updates, it's possible the proxy
            // value is not good, despite appearances, so don't consider it done
            // unless the result "sticks"
            tmp.setNewValue(newVal);
            if (!tmp.dropOldValue()) {
              break;
            } else {
              newVal = null;
            }
          }
        }
      }

      if (newVal == null) {
        //Logging.METRICS_LOGGER.log(Level.INFO, "GENERATING RESULT FROM IN " + Thread.currentThread());
        // Nobody had the result memoized, do it the old fashioned way.
        newVal = tmp.updatedVal(System.currentTimeMillis());

        // If newVal's contract is null, tmp indicates that the programmer
        // doesn't want to memoize the result with a treaty.
        if (newVal.contract == null) {
          TransactionManager.getInstance().stats.addMsg("Memoized: false");
          return newVal;
        }

        // Otherwise, updatedVal doesn't return the contract activated, so
        // activate it now.
        String contractStoreName = newVal.contract.$getStore().name();
        if (!TransactionManager.getInstance().inTxn() &&
            !(contractStoreName.equals(Worker.getWorkerName()))) {
          RemoteWorker w = Worker.getWorker().getWorker(contractStoreName);
          newVal.contract.activate_remote@w(null);
        } else {
          newVal.contract.activate();
        }

        tmp.setNewValue(newVal);
        if (PROACTIVE) {
          for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
            // Update proxies to new value
            WarrantyComp proxy = (WarrantyComp) iter.next();
            proxy.setNewValue(newVal);
          }
        }
      }

      // Only bother to retry if we're supposed to and we don't have a valid
      // contract.
      loop = autoRetry && tmp.dropOldValue();
      if (!loop)
        TransactionManager.getInstance().stats.addMsg("Memoized: true");
    }
    return tmp.curVal;
  }

  private boolean dropOldValue() {
    return static_dropOldValue(this);
  }

  private static boolean static_dropOldValue(WarrantyComp tmp) {
    boolean rtn = false;
    if (TransactionManager.getInstance().inTxn()) {
      rtn = inner_dropOldValue(tmp);
    } else {
      atomic {
        rtn = inner_dropOldValue(tmp);
      }
    }
    return rtn;
  }

  private static boolean inner_dropOldValue(WarrantyComp tmp) {
    Contract curContract = tmp.curVal.contract;
    if (curContract != null && !curContract.valid()) {
      curContract.removeObserver(tmp);
      tmp.curVal.contract = null;
    }
    return tmp.curVal.contract == null;
  }

  private void setNewValue(WarrantyValue newVal) {
    static_setNewValue(this, newVal);
  }

  private static void static_setNewValue(WarrantyComp tmp, WarrantyValue newVal) {
    if (TransactionManager.getInstance().inTxn()) {
      inner_setNewValue(tmp, newVal);
    } else {
      atomic {
        inner_setNewValue(tmp, newVal);
      }
    }
  }

  private static void inner_setNewValue(WarrantyComp tmp, WarrantyValue newVal) {
    if (inner_dropOldValue(tmp) && newVal.contract != null && newVal.contract.valid()) {
      tmp.curVal.value = newVal.value;
      tmp.curVal.contract = newVal.contract.getProxyContract(tmp.$getStore());
      //Logging.METRICS_LOGGER.log(Level.INFO, "SET CONTRACT FOR " + tmp + " TO " + tmp.curVal.contract + " BASED ON " + newVal + " IN " + Thread.currentThread());
      tmp.curVal.contract.addObserver(tmp);
    }
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    if (curVal.contract != null)
      return curVal.contract.getLeafSubjects();
    return ImmutableMetricsVector.emptyVector();
  }

  /*@Override*/
  public boolean handleUpdates() {
    if (this.dropOldValue()) {
      // try to get a new value
      apply(System.currentTimeMillis(), false);
      return true;
    }
    return false;
  }

  /**
   * Copy result for a proxy computation to use.
   *
   * Default is to just copy the reference.  Implementations should override
   * this to make and return copy on the proxyStore.
   */
  protected Object makeProxyResult(WarrantyValue val, final Store proxyStore) {
    return val.value;
  }

  /**
   * Make a warranty comp that resides on another store that can be used locally
   * at that store when a memoized result is available.
   */
  public WarrantyComp makeProxy(final Store proxyStore) {
    return static_makeProxy(this, proxyStore);
  }

  private static WarrantyComp static_makeProxy(WarrantyComp tmp, final Store proxyStore) {
    WarrantyComp rtn = null;
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.$getStore().equals(proxyStore)) {
        rtn = tmp;
      } else {
        // See if we already have a proxy for that store.
        for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
          WarrantyComp proxy = (WarrantyComp) iter.next();
          if (proxy.$getStore().equals(proxyStore)) {
            rtn = proxy;
            break;
          }
        }
        if (rtn == null) {
          rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
          // Update proxies
          for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
            WarrantyComp proxy = (WarrantyComp) iter.next();
            proxy.proxies = proxy.proxies.add(rtn);
          }
          // Update the new proxy
          rtn.proxies = tmp.proxies.add(tmp);
          // Update tmp
          tmp.proxies = tmp.proxies.add(rtn);
        }
      }
    } else {
      atomic {
        if (tmp.$getStore().equals(proxyStore)) {
          rtn = tmp;
        } else {
          // See if we already have a proxy for that store.
          for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
            WarrantyComp proxy = (WarrantyComp) iter.next();
            if (proxy.$getStore().equals(proxyStore)) {
              rtn = proxy;
              break;
            }
          }
          if (rtn == null) {
            rtn = new ProxyComp@proxyStore().fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(tmp);
            // Update proxies
            for (java.util.Iterator iter = tmp.proxies.iterator(); iter.hasNext();) {
              WarrantyComp proxy = (WarrantyComp) iter.next();
              proxy.proxies = proxy.proxies.add(rtn);
            }
            // Update the new proxy
            rtn.proxies = tmp.proxies.add(tmp);
            // Update tmp
            tmp.proxies = tmp.proxies.add(rtn);
          }
        }
      }
    }
    return rtn;
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    // Default to assuming up to 4 proxies
    this.curVal = new WarrantyValue().fabric$metrics$contracts$warranties$WarrantyValue$(null, null);
    this.proxies = ImmutableSet.emptySet();
    fabric$metrics$util$AbstractSubject$();
    return this;
  }

  /**
   * A "Proxy" computation to allow for avoiding contacting a remote store for
   * memoized results.
   */
  protected static class ProxyComp extends WarrantyComp {
    // The computation this is proxying for.
    protected final WarrantyComp baseComputation;

    protected ProxyComp fabric$metrics$contracts$warranties$WarrantyComp$ProxyComp$(WarrantyComp baseComputation) {
      if (baseComputation instanceof ProxyComp) {
        this.baseComputation = ((ProxyComp) baseComputation).baseComputation;
      } else {
        this.baseComputation = baseComputation;
      }
      fabric$metrics$contracts$warranties$WarrantyComp$();
      return this;
    }

    /*@Override*/
    protected WarrantyValue/*<T>*/ updatedVal(long time) {
      return this.baseComputation.updatedVal(time);
    }
  }
}

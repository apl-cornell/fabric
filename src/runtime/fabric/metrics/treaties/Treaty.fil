package fabric.metrics.treaties;

import java.util.Iterator;
import java.util.SortedSet;
import fabric.metrics.Metric;
import fabric.metrics.DerivedMetric;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObjectSet;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.enforcement.NoPolicy;
import fabric.worker.metrics.treaties.statements.TreatyStatement;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;
import fabric.common.Logging;

/**
 * Treaties allow for time-limited assertions of predicates over metrics and
 * time.
 */
public class Treaty extends AbstractSubject implements Observer {

  public final Metric metric;
  public final TreatyStatement predicate;
  protected EnforcementPolicy policy;

  /**
   * Create a new treaty with a given metric, predicate, and policy.
   *
   * Policy is assumed preactivated.
   */
  public Treaty fabric$metrics$treaties$Treaty$(Metric metric,
      TreatyStatement predicate, EnforcementPolicy policy, StatsMap weakStats) {
    this.metric = metric;
    this.predicate = predicate;
    fabric$metrics$util$AbstractSubject$();
    this.$associates = ImmutableObjectSet.emptySet().add(metric);
    this.policy = NoPolicy.singleton;
    this.$expiry = 0;

    // And activate immediately
    long policyExpiry = policy.calculateExpiry(this, weakStats);
    if (policyExpiry > System.currentTimeMillis()) {
      this.policy.shiftPolicies(this, policy);
      this.policy = policy;
      this.$expiry = policyExpiry;
    } else {
      // Garbage collect abandoned policy
      policy.unapply(this);
      deactivate();
    }
    return this;
  }

  /**
   * Perform a not-necessarily-atomic creation of an active treaty.
   */
  public static Treaty newTreaty(Metric metric, TreatyStatement predicate, StatsMap weakStats) {
    final Store s = metric.$getStore();

    EnforcementPolicy policy = Treaty.newActivatedPolicy(metric, predicate, weakStats);

    Treaty treaty = null;
    if (TransactionManager.getInstance().inTxn()) {
      treaty = new Treaty@s().fabric$metrics$treaties$Treaty$(metric, predicate, policy, weakStats);
    } else {
      atomic {
        treaty = new Treaty@s().fabric$metrics$treaties$Treaty$(metric, predicate, policy, weakStats);
      }
    }
    return treaty;
  }

  /**
   * Checks if the treaty is currently valid.
   *
   * Ensures that the transaction manager considers the expiry seen when
   * checking the commit time.
   */
  public boolean valid() {
    // TODO: Adjust for clock skew tolerance.
    TransactionManager tm = TransactionManager.getInstance();
    // Ensure expiry is consistent with updates so far.
    tm.resolveObservations();
    boolean result = this.$expiry >= System.currentTimeMillis();
    // Make sure time still works by the end of the current transaction.
    if (result) tm.registerExpiryUse(this.$expiry);
    return result;
  }

  /**
   * Checks if the treaty is currently invalid.
   *
   * Unlike valid, this doesn't register the check with the transaction manager,
   * so if the treaty is valid, it's not required to still be valid by commit
   * time.  This is primarily to allow for interactions with a treaty to kick
   * out early if they're already invalid.
   */
  public boolean invalid() {
    // TODO: Adjust for clock skew tolerance.
    return this.$expiry < System.currentTimeMillis();
  }

  /**
   * Perform a "deactivation," a forced retraction to 0 and no continued
   * enforcement.  Garbage collects observer relationships with old policy and
   * removes this treaty from the metric's set of available treaties.
   */
  protected void deactivate() {
    if (TransactionManager.getInstance().inTxn()) {
      this.policy.shiftPolicies(this, NoPolicy.singleton);
      this.policy = NoPolicy.singleton;
      this.$expiry = 0;
      this.metric.treatiesBox.remove(this);
    } else {
      this.policy.shiftPolicies(this, NoPolicy.singleton);
      atomic {
        this.policy = NoPolicy.singleton;
        this.$expiry = 0;
        this.metric.treatiesBox.remove(this);
      }
    }
  }

  /**
   * Create and activate a new enforcement policy.
   */
  protected static EnforcementPolicy newActivatedPolicy(Metric metric,
      TreatyStatement predicate, StatsMap weakStats) {
    EnforcementPolicy newPolicy = predicate.getNewPolicy(metric, weakStats);
    newPolicy.activate(weakStats);
    return newPolicy;
  }

  /**
   * Maximum time in milliseconds before the currently advertised expiry that an
   * extension should be applied within.
   *
   * TODO: Make this a configuration parameter to load in on program start?
   */
  public static final long UPDATE_THRESHOLD = 1000;

  /**
   * Run an update using the current expiry.  Factored out here since it's used
   * by both handleUpdates() and backgroundExtension().
   * @return true iff the current policy is still viable.
   */
  protected boolean updateWithCurPolicy() {
    long updatedCurExpiry = policy.updatedExpiry(this, StatsMap.emptyStats());
    if (updatedCurExpiry > System.currentTimeMillis()) {
      if (updatedCurExpiry < this.$expiry || this.$expiry -
          System.currentTimeMillis() <= UPDATE_THRESHOLD) {
        this.$expiry = updatedCurExpiry;
      } else if (updatedCurExpiry > this.$expiry) {
        // Mark for future extension.
        TransactionManager.getInstance().registerDelayedExtension(this);
      }
      return true;
    }
    return false;
  }

  /**
   * Register potentially enabled extensions for observers given the expiry
   * relative to the original (given) expiry.  Factored out here since it's used
   * by both handleUpdates() and backgroundExtension().
   */
  protected void registerPotentialExtensions(long oldExpiry) {
    if (this.$expiry > oldExpiry) {
      // Note possible triggered extensions.
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        java.lang.Object o = iter.next();
        if (o instanceof Treaty)
          TransactionManager.getInstance().registerDelayedExtension((Treaty) o, this);
      }
    }
  }

  /**
   * Handles an update to some dependency of the current policy for this treaty.
   *
   * @return the observers of this treaty if there was a retraction.
  /*@Override*/
  public ImmutableObserverSet handleUpdates() {
    // Note: This always happens within the context of a transaction.
    long oldExpiry = this.$expiry;

    if (!updateWithCurPolicy()) {
      // Try a new policy
      // XXX: It's worth considering if we should avoid activating new policy in
      // case we also ditch?
      EnforcementPolicy newPolicy = newActivatedPolicy(metric, predicate, StatsMap.emptyStats());
      long newPolicyExpiry = newPolicy.calculateExpiry(this, StatsMap.emptyStats());
      if (newPolicyExpiry > System.currentTimeMillis()) {
        this.policy.shiftPolicies(this, newPolicy);
        this.policy = newPolicy;
        this.$expiry = newPolicyExpiry;
      } else {
        // Garbage collect abandoned policy
        newPolicy.unapply(this);
        deactivate();
      }
    }

    if (this.$expiry < oldExpiry) {
      // Observers need to be handled
      return getObservers();
    }

    registerPotentialExtensions(oldExpiry);
    return ImmutableObserverSet.emptySet();
  }

  /**
   * Run a background extension.  This should only result in extending the
   * expiry using the existing policy or waiting further to extend.
   */
  public void backgroundExtension() {
    // Note: This always happens within the context of a transaction.
    long oldExpiry = this.$expiry;

    // Only bother with attempting using the current policy.
    boolean policyLive = updateWithCurPolicy();

    if (this.$expiry < oldExpiry) {
      // This shouldn't be possible.  Retractions should only be caused by an
      // update to some dependency of the policy and handled in the same
      // transaction.
      if (TransactionManager.getInstance().checkForStaleObjects()) retry;
      throw new InternalError("Somehow had a retraction during a background extension: " + oldExpiry + " to " + this.$expiry);
    }

    registerPotentialExtensions(oldExpiry);
  }

  /**
   * Force a shift to a new policy.
   */
  public void rebalance() {
    // TODO: this assumes we're in a transaction already.
    // TODO: Is this pontentially going to backslide?
    EnforcementPolicy newPolicy = newActivatedPolicy(metric, predicate, StatsMap.emptyStats());
    this.policy.shiftPolicies(this, newPolicy);
    this.policy = newPolicy;
    this.$expiry = newPolicy.calculateExpiry(this, StatsMap.emptyStats());
  }

  /**
   * Get a proxy for this treaty stored on the given store.
   */
  public Treaty getProxy(Store s) {
    if ($getStore().equals(s)) return this;
    return predicate.getProxy(metric, s);
  }

  /**
   * Remove an observer.  If this is the last remaining observer, go ahead and
   * retract it to avoid unnecessary monitoring overhead.
   */
  /*@Override*/
  public void removeObserver(Observer o) {
    // TODO: Should this be atomic?  Is this ever called outside a transaction?
    super.removeObserver(o);
    if (!isObserved()) deactivate();
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    if (metric instanceof DerivedMetric) {
      return ((DerivedMetric) metric).getLeafSubjects();
    } else if (metric instanceof SampledMetric) {
      return ImmutableMetricsVector.createVector(new Metric native[] { metric });
    }
    throw new InternalError("Unknown metric type: " + metric.getClass() + " " + metric);
  }

  /*@Override*/
  public String toString() {
    return "(" + $getStore().name() + "/" + $getOnum() + "): " + metric.toString() + " " + predicate + " until " + $expiry + " [" + policy + " and observed by " + getObservers() + "]";
  }
}

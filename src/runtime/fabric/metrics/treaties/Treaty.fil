package fabric.metrics.treaties;

import java.util.Iterator;
import java.util.SortedSet;
import fabric.metrics.Metric;
import fabric.metrics.DerivedMetric;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObjectSet;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.enforcement.NoPolicy;
import fabric.worker.metrics.treaties.statements.TreatyStatement;
import fabric.worker.transaction.TransactionManager;

/**
 * Treaties allow for time-limited assertions of predicates over metrics and
 * time.
 */
public class Treaty extends AbstractSubject implements Observer {

  public final Metric metric;
  public final TreatyStatement predicate;
  private EnforcementPolicy policy;

  /**
   * Create a new treaty with a given metric, predicate, and policy.
   *
   * Policy is assumed preactivated.
   */
  public Treaty fabric$metrics$treaties$Treaty$(Metric metric,
      TreatyStatement predicate, EnforcementPolicy policy, StatsMap weakStats) {
    this.metric = metric;
    this.predicate = predicate;
    fabric$metrics$util$AbstractSubject$();
    this.$expiry = policy.calculateExpiry(this, weakStats);
    if (valid()) {
      this.policy = policy;
      // Move to this from no policy
      policy.shiftPolicies(this, NoPolicy.singleton);
    } else {
      deactivate();
    }
    this.$associates = ImmutableObjectSet.emptySet().add(metric);
    return this;
  }

  /**
   * Perform a not-necessarily-atomic creation of an active treaty.
   *
   * TODO: maybe move this interface into Metric?
   */
  public static Treaty newTreaty(Metric metric, TreatyStatement predicate, StatsMap weakStats) {
    final Store s = metric.$getStore();

    EnforcementPolicy policy = Treaty.newActivatedPolicy(metric, predicate, weakStats);

    Treaty treaty = null;
    if (TransactionManager.getInstance().inTxn()) {
      treaty = new Treaty@s().fabric$metrics$treaties$Treaty$(metric, predicate, policy, weakStats);
    } else {
      atomic {
        treaty = new Treaty@s().fabric$metrics$treaties$Treaty$(metric, predicate, policy, weakStats);
      }
    }
    return treaty;
  }

  /**
   * Checks if the treaty is currently valid.
   *
   * Ensures that the transaction manager considers the expiry seen when
   * checking the commit time.
   */
  public boolean valid() {
    // TODO: Adjust for clock skew tolerance.
    TransactionManager tm = TransactionManager.getInstance();
    // Ensure expiry is consistent with updates so far.
    tm.resolveObservations();
    boolean result = this.$expiry >= System.currentTimeMillis();
    // Make sure time still works by the end of the current transaction.
    if (result) tm.registerExpiryUse(this.$expiry);
    return result;
  }

  /**
   * Checks if the treaty is currently invalid.
   *
   * Unlike valid, this doesn't register the check with the transaction manager,
   * so if the treaty is valid, it's not required to still be valid by commit
   * time.  This is primarily to allow for interactions with a treaty to kick
   * out early if they're already invalid.
   */
  public boolean invalid() {
    // TODO: Adjust for clock skew tolerance.
    return this.$expiry < System.currentTimeMillis();
  }

  /**
   * Create and activate a new enforcement policy.
   */
  private static EnforcementPolicy newActivatedPolicy(Metric metric,
      TreatyStatement predicate, StatsMap weakStats) {
    EnforcementPolicy newPolicy = predicate.getNewPolicy(metric, weakStats);
    newPolicy.activate(weakStats);
    return newPolicy;
  }

  /**
   * Maximum time in milliseconds before the currently advertised expiry that an
   * extension should be applied within.
   *
   * TODO: Make this a configuration parameter to load in on program start?
   */
  public static final long UPDATE_THRESHOLD = 1000;

  /**
   * Handles an update to some dependency of the current policy for this treaty.
   *
   * @return the observers of this treaty if there was a retraction.
  /*@Override*/
  public ImmutableObserverSet handleUpdates() {
    // Note: This always happens within the context of a transaction.
    long oldExpiry = this.$expiry;

    // Check old policy
    long updatedCurExpiry = policy.updatedExpiry(this, StatsMap.emptyStats());

    if (updatedCurExpiry > System.currentTimeMillis()) {
      // Keep current policy.
      if (updatedCurExpiry < oldExpiry || this.$expiry -
          System.currentTimeMillis() <= UPDATE_THRESHOLD) {
        // Update the expiry if this is a retraction or we're within the
        // extension window.
        this.$expiry = updatedCurExpiry;
      } else {
        // Don't extend eagerly outside update window, mark for future
        // extension.
        TransactionManager.getInstance().registerDelayedExtension(this);
      }
    } else {
      // Try a new policy
      EnforcementPolicy oldPolicy = this.policy;
      // Note: this activates a policy that we might ditch.  It's worth
      // considering if this should be avoided (this is what was done in the
      // pre-redesign version).
      EnforcementPolicy newPolicy = newActivatedPolicy(metric, predicate, StatsMap.emptyStats());

      long newPolicyExpiry = newPolicy.calculateExpiry(this, StatsMap.emptyStats());
      this.$expiry = newPolicyExpiry;
      if (valid()) {
        // Move to this from old policy.
        this.policy = newPolicy;
        newPolicy.shiftPolicies(this, oldPolicy);
      } else {
        deactivate();
      }
    }

    // Indicate if observers need to handle a retraction.
    if (this.$expiry < oldExpiry) {
      return getObservers();
    } else {
      // Register triggered possible extensions.
      if (this.$expiry > oldExpiry) {
        for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
          java.lang.Object o = iter.next();
          if (o instanceof Treaty)
            TransactionManager.getInstance().registerDelayedExtension((Treaty) iter.next(), this);
        }
      }
      return ImmutableObserverSet.emptySet();
    }
  }

  /**
   * Run a background extension.  This should only result in extending the
   * expiry using the existing policy or waiting further to extend.
   *
   * TODO: Should this be passed a weak read of relevant stats?
   */
  public void backgroundExtension() {
    // Note: This always happens within the context of a transaction.
    long oldExpiry = this.$expiry;

    // Check old policy
    long updatedCurExpiry = policy.updatedExpiry(this, StatsMap.emptyStats());

    if (updatedCurExpiry > System.currentTimeMillis()) {
      // Keep current policy.  Update time.
      if (updatedCurExpiry < oldExpiry) {
        // This shouldn't be possible.  Retractions should only be caused by an
        // update to some dependency of the policy and handled in the same
        // transaction.
        throw new InternalError("Somehow had a retraction during a background extension");
      } else if (updatedCurExpiry > oldExpiry && this.$expiry -
          System.currentTimeMillis() <= UPDATE_THRESHOLD) {
        // Update the expiry if we're within the extension window.
        this.$expiry = updatedCurExpiry;
      } else {
        // Don't extend eagerly outside update window, mark for future
        // extension.
        TransactionManager.getInstance().registerDelayedExtension(this);
      }
    }

    // Register triggered possible extensions.
    if (this.$expiry > oldExpiry) {
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        java.lang.Object o = iter.next();
        if (o instanceof Treaty)
          TransactionManager.getInstance().registerDelayedExtension((Treaty) iter.next(), this);
      }
    }
  }

  /**
   * Force a shift to a new policy.
   */
  public void rebalance() {
    // Note: this assumes we're in a transaction already.
    EnforcementPolicy oldPolicy = this.policy;
    EnforcementPolicy newPolicy = newActivatedPolicy(metric, predicate, StatsMap.emptyStats());
    this.$expiry = newPolicy.calculateExpiry(this, StatsMap.emptyStats());
    this.policy = newPolicy;
    newPolicy.shiftPolicies(this, oldPolicy);
  }

  /**
   * Perform a "deactivation," a forced retraction to 0 and no continued
   * enforcement.
   */
  private void deactivate() {
    // Set the expiry to 0 and ensure cleanup of underlying treaties, this
    // treaty is dead.
    EnforcementPolicy oldPolicy = this.policy;
    if (TransactionManager.getInstance().inTxn()) {
      this.$expiry = 0;
      this.policy = NoPolicy.singleton;
      oldPolicy.unapply(this);
      this.metric.treatiesBox.remove(this);
    } else {
      atomic {
        this.$expiry = 0;
        this.policy = NoPolicy.singleton;
      }
      oldPolicy.unapply(this);
      atomic {
        this.metric.treatiesBox.remove(this);
      }
    }
  }

  /**
   * Get a proxy for this treaty stored on the given store.
   */
  public Treaty getProxy(Store s) {
    if ($getStore().equals(s)) return this;
    return predicate.getProxy(metric, s);
  }

  /**
   * Remove an observer.  If this is the last remaining observer, go ahead and
   * retract it to avoid unnecessary monitoring overhead.
   */
  /*@Override*/
  public void removeObserver(Observer o) {
    // TODO: Should this be atomic?  Is this ever called outside a transaction?
    super.removeObserver(o);
    if (!isObserved()) deactivate();
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    if (metric instanceof DerivedMetric) {
      return ((DerivedMetric) metric).getLeafSubjects();
    } else if (metric instanceof SampledMetric) {
      return ImmutableMetricsVector.createVector(new Metric native[] { metric });
    }
    throw new InternalError("Unknown metric type: " + metric.getClass() + " " + metric);
  }
}

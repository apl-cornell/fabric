package fabric.metrics.treaties;

import java.util.Iterator;
import java.util.SortedSet;
import fabric.metrics.Metric;
import fabric.metrics.DerivedMetric;
import fabric.metrics.SampledMetric;
import fabric.metrics.SumMetric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObjectSet;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.enforcement.EnforcementPolicy;
import fabric.worker.metrics.treaties.enforcement.NoPolicy;
import fabric.worker.metrics.treaties.statements.TreatyStatement;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.Worker;
import java.util.logging.Level;
import fabric.common.Logging;

/**
 * Treaties allow for time-limited assertions of predicates over metrics and
 * time.
 */
public class Treaty extends AbstractSubject implements Observer {

  public final Metric metric;
  public final TreatyStatement predicate;
  protected EnforcementPolicy policy;

  /**
   * Create a new treaty with a given metric, predicate, and policy.
   *
   * Policy is assumed preactivated.
   */
  public Treaty fabric$metrics$treaties$Treaty$(Metric metric,
      TreatyStatement predicate, EnforcementPolicy policy, StatsMap weakStats) {
    this.metric = metric;
    this.predicate = predicate;
    fabric$metrics$util$AbstractSubject$();
    this.$associates = ImmutableObjectSet.emptySet().add(metric);
    this.policy = NoPolicy.singleton;
    this.$expiry = 0;

    // And activate immediately
    long policyExpiry = policy.calculateExpiry(this, weakStats);
    if (policyExpiry > System.currentTimeMillis()) {
      this.policy.shiftPolicies(this, policy);
      this.policy = policy;
      this.$expiry = policyExpiry;
    } else {
      // Garbage collect abandoned policy
      policy.unapply(this);
      deactivate();
    }
    return this;
  }

  /**
   * Perform a not-necessarily-atomic creation of an active treaty.
   */
  public static Treaty newTreaty(Metric metric, TreatyStatement predicate, StatsMap weakStats) {
    final Store s = metric.$getStore();

    EnforcementPolicy policy = Treaty.newActivatedPolicy(metric, predicate, weakStats);

    Treaty treaty = null;
    if (TransactionManager.getInstance().inTxn()) {
      treaty = new Treaty@s().fabric$metrics$treaties$Treaty$(metric, predicate, policy, weakStats);
    } else {
      atomic {
        treaty = new Treaty@s().fabric$metrics$treaties$Treaty$(metric, predicate, policy, weakStats);
      }
    }
    return treaty;
  }

  /**
   * Checks if the treaty is currently valid.
   *
   * Ensures that the transaction manager considers the expiry seen when
   * checking the commit time.
   */
  public boolean valid() {
    TransactionManager tm = TransactionManager.getInstance();
    // Ensure expiry is consistent with updates so far.
    tm.resolveObservations();
    boolean result = this.$expiry >= System.currentTimeMillis();
    // Make sure time still works by the end of the current transaction.
    if (result) tm.registerExpiryUse(this.$expiry);
    else this.$getExpiryStrict(); // Force strictness on invalid result.
    return result;
  }

  /**
   * Checks if the treaty is currently invalid.
   *
   * Unlike valid, this doesn't register the check with the transaction manager,
   * so if the treaty is valid, it's not required to still be valid by commit
   * time.  This is primarily to allow for interactions with a treaty to kick
   * out early if they're already invalid.
   */
  public boolean invalid() {
    // TODO: Adjust for clock skew tolerance.
    boolean result = this.$expiry < System.currentTimeMillis();
    // Strict here to ensure we're not seeing invalid due to some stale value.
    if (result) this.$getExpiryStrict();
    return result;
  }

  /**
   * Perform a "deactivation," a forced retraction to 0 and no continued
   * enforcement.  Garbage collects observer relationships with old policy and
   * removes this treaty from the metric's set of available treaties.
   */
  protected void deactivate() {
    if (TransactionManager.getInstance().inTxn()) {
      this.policy.shiftPolicies(this, NoPolicy.singleton);
      this.policy = NoPolicy.singleton;
      this.$expiry = 0;
      this.metric.treatiesBox.remove(this);
    } else {
      this.policy.shiftPolicies(this, NoPolicy.singleton);
      atomic {
        this.policy = NoPolicy.singleton;
        this.$expiry = 0;
        this.metric.treatiesBox.remove(this);
      }
    }
  }

  /**
   * Create and activate a new enforcement policy.
   */
  protected static EnforcementPolicy newActivatedPolicy(Metric metric,
      TreatyStatement predicate, StatsMap weakStats) {
    EnforcementPolicy newPolicy = predicate.getNewPolicy(metric, weakStats);
    newPolicy.activate(weakStats);
    return newPolicy;
  }

  /**
   * Create and activate a new enforcement policy.
   */
  protected static EnforcementPolicy newUnactivatedPolicy(Metric metric,
      TreatyStatement predicate, StatsMap weakStats) {
    EnforcementPolicy newPolicy = predicate.getNewPolicy(metric, weakStats);
    return newPolicy;
  }

  /**
   * Maximum time in milliseconds before the currently advertised expiry that an
   * extension should be applied within.
   *
   * TODO: Make this a configuration parameter to load in on program start?
   */
  public static final long UPDATE_THRESHOLD = 200;

  /**
   * Run an update using the current expiry.  Factored out here since it's used
   * by both handleUpdates() and backgroundExtension().
   * @return true iff the current policy is still viable.
   */
  protected boolean updateWithCurPolicy(boolean force) {
    long updatedCurExpiry = policy.updatedExpiry(this, StatsMap.emptyStats());
    if (updatedCurExpiry > System.currentTimeMillis()) {
      if (updatedCurExpiry < this.$expiry || (force || this.$expiry -
          System.currentTimeMillis() <= UPDATE_THRESHOLD)) {
        // Only perform the write if it's an actual change.
        if (this.$expiry != updatedCurExpiry) this.$expiry = updatedCurExpiry;
      } else if (updatedCurExpiry > this.$expiry) {
        // Mark for future extension.
        TransactionManager.getInstance().registerDelayedExtension(this);
      }
      return true;
    }
    return false;
  }

  /**
   * Register potentially enabled extensions for observers given the expiry
   * relative to the original (given) expiry.  Factored out here since it's used
   * by both handleUpdates() and backgroundExtension().
   */
  protected void registerPotentialExtensions(long oldExpiry) {
    if (this.$expiry > oldExpiry) {
      // Note possible triggered extensions.
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        java.lang.Object o = iter.next();
        if (o instanceof Treaty)
          TransactionManager.getInstance().registerDelayedExtension((Treaty) o, this);
      }
    }
  }

  /**
   * Handles an update to some dependency of the current policy for this treaty.
   *
   * @return the observers of this treaty if there was a retraction.
  /*@Override*/
  public ImmutableObserverSet handleUpdates() {
    // Note: This always happens within the context of a transaction.
    long oldExpiry = this.$expiry;

    if (!updateWithCurPolicy(false)) {
      // Try a new policy
      // XXX: It's worth considering if we should avoid activating new policy in
      // case we also ditch?
      //if (predicate.check(metric)) {
        EnforcementPolicy newPolicy = newUnactivatedPolicy(metric, predicate, StatsMap.emptyStats());
        if (newPolicy.equals(this.policy)) {
          deactivate();
        } else {
          newPolicy.activate(StatsMap.emptyStats());
          long newPolicyExpiry = newPolicy.calculateExpiry(this, StatsMap.emptyStats());
          if (newPolicyExpiry > System.currentTimeMillis()) {
            this.policy.shiftPolicies(this, newPolicy);
            this.policy = newPolicy;
            this.$expiry = newPolicyExpiry;
          } else {
            // Garbage collect abandoned policy
            newPolicy.unapply(this);
            deactivate();
          }
        }
      //} else {
      //  deactivate();
      //}
    } else if (TransactionManager.getInstance().shouldRebalance(this)) {
      rebalance(false);
    }

    if (this.$expiry < oldExpiry) {
      // Observers need to be handled
      return getObservers();
    }

    registerPotentialExtensions(oldExpiry);
    return ImmutableObserverSet.emptySet();
  }

  /**
   * Run a background extension.  This should only result in extending the
   * expiry using the existing policy or waiting further to extend.
   */
  public void backgroundExtension() {
    // Note: This always happens within the context of a transaction.
    long oldExpiry = this.$expiry;
    // Don't bother if this is a dead treaty.
    if (oldExpiry != 0) {

      // Only bother with attempting using the current policy.
      boolean policyLive = updateWithCurPolicy(true);

      if (this.$expiry < oldExpiry) {
        // This shouldn't be possible.  Retractions should only be caused by an
        // update to some dependency of the policy and handled in the same
        // transaction.
        retry;
      } else {
        if (TransactionManager.getInstance().shouldRebalance(this)) {
          rebalance(true);
        }
        registerPotentialExtensions(oldExpiry);
      }
    }
  }

  /**
   * Force a shift to a new policy.
   */
  public void rebalance(boolean force) {
    long oldExpiry = this.$expiry;
    // XXX: It's worth considering if we should avoid activating new policy in
    // case we also ditch?
    EnforcementPolicy newPolicy = newUnactivatedPolicy(metric, predicate, StatsMap.emptyStats());
    if (newPolicy.equals(this.policy)) return;
    newPolicy.activate(StatsMap.emptyStats());
    long newPolicyExpiry = newPolicy.calculateExpiry(this, StatsMap.emptyStats());
    if (newPolicyExpiry > oldExpiry) {
      if (force || oldExpiry - System.currentTimeMillis() <= UPDATE_THRESHOLD) {
        this.policy.shiftPolicies(this, newPolicy);
        this.policy = newPolicy;
        this.$expiry = newPolicyExpiry;
        registerPotentialExtensions(oldExpiry);
      } else {
        newPolicy.abandonPolicy(this, this.policy);
        TransactionManager.getInstance().registerDelayedExtension(this);
      }
    } else if (!this.policy.equals(newPolicy)) {
      // Garbage collect abandoned policy
      newPolicy.abandonPolicy(this, this.policy);
    }
  }

  /**
   * Force a shift to a new policy.
   */
  public static void rebalance_async(Treaty tmp) {
    atomic {
      if (!(tmp.metric instanceof SumMetric)) return;
    }
    // Collect stats
    StatsMap weakStats = StatsMap.emptyStats();
    if (tmp.metric.$getStore().name().equals(Worker.getWorkerName())) {
      weakStats = tmp.metric.refreshWeakEstimates(weakStats);
    } else {
      RemoteWorker w = Worker.getWorker().getWorker(tmp.metric.$getStore().name());
      weakStats = tmp.metric.refreshWeakEstimates_remote@w(null, weakStats);
    }

    // Form a plan
    EnforcementPolicy newPolicy = newUnactivatedPolicy(tmp.metric, tmp.predicate, weakStats);
    atomic {
      // Skip if this isn't a new plan anymore.
      if (newPolicy.equals(tmp.policy)) return;
    }
    newPolicy.activate(weakStats);

    // Switch to it, if it's better.
    atomic {
      long newPolicyExpiry = newPolicy.calculateExpiry(tmp, weakStats);
      if (newPolicyExpiry > tmp.$expiry) {
        tmp.policy.shiftPolicies(tmp, newPolicy);
        tmp.policy = newPolicy;
        tmp.$expiry = newPolicyExpiry;
        tmp.registerPotentialExtensions(tmp.$expiry);
      } else if (!tmp.policy.equals(newPolicy)) {
        // Garbage collect abandoned policy
        newPolicy.abandonPolicy(tmp, tmp.policy);
      }
    }
  }

  /**
   * Get a proxy for this treaty stored on the given store.
   */
  public Treaty getProxy(Store s) {
    if ($getStore().equals(s)) return this;
    return predicate.getProxy(metric, s);
  }

  /**
   * Remove an observer.  If this is the last remaining observer, go ahead and
   * retract it to avoid unnecessary monitoring overhead.
   */
  /*@Override*/
  public void removeObserver(Observer o) {
    // TODO: Should this be atomic?  Is this ever called outside a transaction?
    super.removeObserver(o);
    if (!isObserved()) deactivate();
  }

  /*@Override*/
  public ImmutableMetricsVector/*<SampledMetric>*/ getLeafSubjects() {
    if (metric instanceof DerivedMetric) {
      return ((DerivedMetric) metric).getLeafSubjects();
    } else if (metric instanceof SampledMetric) {
      return ImmutableMetricsVector.createVector(new Metric native[] { metric });
    }
    throw new InternalError("Unknown metric type: " + metric.getClass() + " " + metric);
  }

  /*@Override*/
  public String toString() {
    return "(" + $getStore().name() + "/" + $getOnum() + "): " + metric.toString() + " " + predicate + " until " + $expiry + " [" + policy + " and observed by " + getObservers() + "]";
  }
}

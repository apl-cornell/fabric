package fabric.metrics.util;

import fabric.util.Collection;
import fabric.util.Collections;
import fabric.util.Set;
import fabric.util.ArrayList;
import fabric.util.List;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.SortedSet;

import fabric.metrics.SampledMetric;

import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.Store;
import fabric.common.util.Triple;

import java.util.logging.Level;
import fabric.common.Logging;


/**
 * Base implementation of {@link Subject}
 */
public abstract class AbstractSubject implements Subject {

  private ImmutableObserverSet observers;

  // Ugh, avoid getting a surrogate's store.
  public Store getStore() {
    return $getStore();
  }

  protected AbstractSubject fabric$metrics$util$AbstractSubject$() {
    fabric$lang$Object$();
    this.observers = ImmutableObserverSet.emptySet();
    return this;
  }

  /*@Override*/
  public void addObserver(Observer o) {
    static_addObserver(this, o);
  }

  private static void static_addObserver(AbstractSubject tmp, Observer o) {
    //Logging.METRICS_LOGGER.finer("ADD OBSERVER " + o + " FOR " + tmp + " IN " +
    //    TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.observers.contains(o))
        tmp.observers = tmp.observers.add(o);
    } else {
      atomic {
        if (!tmp.observers.contains(o))
          tmp.observers = tmp.observers.add(o);
      }
    }
  }

  /*@Override*/
  public void addObserver(Observer o, long id) {
    static_addObserver(this, o, id);
  }

  private static void static_addObserver(AbstractSubject tmp, Observer o, long id) {
    //Logging.METRICS_LOGGER.finer("ADD OBSERVER " + o + " FOR " + tmp + " IN " +
    //    TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.observers.contains(o, id))
        tmp.observers = tmp.observers.add(o, id);
    } else {
      atomic {
        if (!tmp.observers.contains(o, id))
          tmp.observers = tmp.observers.add(o, id);
      }
    }
  }

  /*@Override*/
  public void removeObserver(Observer o) {
    static_removeObserver(this, o);
  }

  public static void static_removeObserver(AbstractSubject tmp, Observer o) {
    //Logging.METRICS_LOGGER.finer("REMOVE OBSERVER " + o + " FOR " + tmp + " IN "
    //    + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.observers.contains(o))
        tmp.observers = tmp.observers.remove(o);
    } else {
      atomic {
        if (tmp.observers.contains(o))
          tmp.observers = tmp.observers.remove(o);
      }
    }
  }

  /*@Override*/
  public void removeObserver(Observer o, long id) {
    static_removeObserver(this, o, id);
  }

  public static void static_removeObserver(AbstractSubject tmp, Observer o, long id) {
    //Logging.METRICS_LOGGER.finer("REMOVE OBSERVER " + o + " FOR " + tmp + " IN "
    //    + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.observers.contains(o, id))
        tmp.observers = tmp.observers.remove(o, id);
    } else {
      atomic {
        if (tmp.observers.contains(o, id))
          tmp.observers = tmp.observers.remove(o, id);
      }
    }
  }

  /*@Override*/
  public boolean observedBy(Observer o) {
    return observers.contains(o);
  }

  /*@Override*/
  public boolean isObserved() {
    return !observers.isEmpty();
  }

  /*@Override*/
  public ImmutableObserverSet getObservers() {
    return observers;
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   *
   * @param unobserved
   *            a {@link LinkedList} of {@link SampledMetric}s that have been
   *            updated and still need to have Observers compute the resulting
   *            effects for.
   */
  public static void processSamples(LinkedList unobserved) {
    LinkedList/*<Triple<Observer, Boolean, SortedSet<Long>>>*/ queue = new LinkedList/*<>*/();
    // Items that should be handled and need to be checked again later after
    // other children are processed.
    LinkedList/*<Triple<Observer, Boolean, SortedSet<Long>>>*/ delayed = new LinkedList/*<>*/();
    while (!unobserved.isEmpty()) {
      SampledMetric sm = (SampledMetric) unobserved.poll();
      //Logging.METRICS_LOGGER.log(Level.FINER, "HANDLING OBSERVATION OF " + sm);
      ImmutableObserverSet obs = sm.getObservers();
      for (Iterator iter = obs.iterator(); iter.hasNext();) {
        queue.add(iter.next());
      }

      while (!queue.isEmpty()) {
        Triple/*<Observer, Boolean, SortedSet<Long>>*/ unhandled = (Triple/*<Observer, Boolean, SortedSet<Long>>*/) queue.poll();
        // We're handling a delayed item, mark it as not delayed for
        // now. We'll delay it again if it's still not ready.
        delayed.remove(unhandled);

        boolean needToWait = false;
        ImmutableMetricsVector/*<SampledMetric>*/ leaves = ((Observer) unhandled.first).getLeafSubjects();
        for (int i = 0; i < leaves.length(); i++) {
          if (unobserved.contains(leaves.get(i))) {
            needToWait = true;
            break;
          }
        }
        // If this has no other pending sampled events, process it.
        if (!needToWait) {
          Logging.METRICS_LOGGER.log(Level.FINE, "HANDLING OBSERVER {0} IN {1}", new java.lang.Object native [] {unhandled, TransactionManager.getInstance().getCurrentTid()});
          ImmutableObserverSet parentsToCheck = ((Observer) unhandled.first).handleUpdates(((Boolean) unhandled.second).booleanValue(), ((SortedSet/*<Long>*/) unhandled.third));
          for (Iterator iter = parentsToCheck.iterator(); iter.hasNext();) {
            queue.add(iter.next());
          }
        } else {
          // mark as delayed for later processing
          Logging.METRICS_LOGGER.log(Level.FINE, "DELAYED HANDLING OBSERVER {0} IN {1}", new java.lang.Object native [] {unhandled, TransactionManager.getInstance().getCurrentTid()});
          delayed.add(unhandled);
        }
        // If there's nothing more, let's get back to delayed items that
        // are now worth looking at before moving on.
        if (queue.isEmpty()) {
          Iterator delayedIter = delayed.iterator();
          while (delayedIter.hasNext()) {
            Triple/*<Observer, Boolean, SortedSet<Long>>*/ withheld = (Triple/*<Observer, Boolean, SortedSet<Long>>*/) delayedIter.next();

            boolean doneWaiting = true;
            ImmutableMetricsVector/*<SampledMetric>*/ withheldLeaves = ((Observer) withheld.first).getLeafSubjects();
            for (int i = 0; i < withheldLeaves.length(); i++) {
              if (unobserved.contains(withheldLeaves.get(i))) {
                doneWaiting = false;
                break;
              }
            }
            if (doneWaiting) {
              queue.add(withheld);
            }
          }
        }
      }
    }
  }
}

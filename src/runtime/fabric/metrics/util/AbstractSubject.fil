package fabric.metrics.util;

import fabric.util.Collection;
import fabric.util.Collections;
import java.util.LinkedList;
import fabric.util.Set;
import fabric.util.ArrayList;
import fabric.util.List;
import fabric.util.Iterator;

import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.Contract;

import fabric.worker.transaction.TransactionManager;
import fabric.worker.Store;

//import java.util.logging.Level;
//import fabric.common.Logging;


/**
 * Base implementation of {@link Subject}
 */
public abstract class AbstractSubject implements Subject {

  // Ugh, avoid getting a surrogate's store.
  public Store getStore() {
    return $getStore();
  }

  protected AbstractSubject fabric$metrics$util$AbstractSubject$() {
    this.observers = new ArrayList/*<>*/().fabric$util$ArrayList$();
    fabric$lang$Object$();
    return this;
  }

  // Using a weak map as the backing for this set so that observers aren't
  // pinned by their subjects.
  private final ArrayList/*<Observer>*/ observers;

  /*@Override*/
  public void addObserver(Observer o) {
    static_addObserver(this, o);
  }

  private static void static_addObserver(AbstractSubject tmp, Observer o) {
    //Logging.METRICS_LOGGER.finer("ADD OBSERVER " + o + " FOR " + tmp + " IN " +
    //    TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.observers.contains(o))
        tmp.observers.add(o);
    } else {
      atomic {
        if (!tmp.observers.contains(o))
          tmp.observers.add(o);
      }
    }
  }

  /*@Override*/
  public void removeObserver(Observer o) {
    static_removeObserver(this, o);
  }

  public static void static_removeObserver(AbstractSubject tmp, Observer o) {
    //Logging.METRICS_LOGGER.finer("REMOVE OBSERVER " + o + " FOR " + tmp + " IN "
    //    + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      tmp.observers.remove(o);
    } else {
      atomic {
        tmp.observers.remove(o);
      }
    }
  }

  /*@Override*/
  public boolean observedBy(Observer o) {
    return observers.contains(o);
  }

  /*@Override*/
  public boolean isObserved() {
    return !observers.isEmpty();
  }

  /*@Override*/
  public List/*<Observer>*/ getObservers() {
    return observers;
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   *
   * @param unobserved
   *            a {@link LinkedList} of {@link SampledMetric}s that have been
   *            updated and still need to have Observers compute the resulting
   *            effects for.
   */
  public static void processSamples(LinkedList unobserved) {
    LinkedList/*<Observer>*/ queue = new LinkedList/*<>*/();
    // Items that should be handled and need to be checked again later after
    // other children are processed.
    LinkedList/*<Observer>*/ delayed = new LinkedList/*<>*/();
    while (!unobserved.isEmpty()) {
      SampledMetric sm = (SampledMetric) unobserved.poll();
      //Logging.METRICS_LOGGER.log(Level.FINER, "HANDLING OBSERVATION OF " + sm);
      List obs = sm.getObservers();
      int size = obs.size();
      for (int i = 0; i < size; i++) {
        queue.add(obs.get(i));
      }

      while (!queue.isEmpty()) {
        Observer unhandled = (Observer) queue.poll();
        // We're handling a delayed item, mark it as not delayed for
        // now. We'll delay it again if it's still not ready.
        delayed.remove(unhandled);

        boolean needToWait = false;
        SampledMetric[] leaves = unhandled.getLeafSubjects();
        for (int i = 0; i < leaves.length; i++) {
          if (unobserved.contains(leaves[i])) {
            needToWait = true;
            break;
          }
        }
        // If this has no other pending sampled events, process it.
        if (!needToWait) {
          //Logging.METRICS_LOGGER.log(Level.FINER, "HANDLING OBSERVER " +
          //    unhandled);
          boolean modified = unhandled.handleUpdates();
          if (unhandled instanceof Subject && modified) {
            //Logging.METRICS_LOGGER.log(Level.FINER,
            //    "QUEUING PARENTS OF OBSERVER " + unhandled);
            List parents = ((Subject) unhandled).getObservers();
            int pSize = parents.size();
            for (int i = 0; i < pSize; i++) {
              queue.add(parents.get(i));
            }
          }
        } else {
          // mark as delayed for later processing
          //Logging.METRICS_LOGGER.log(Level.FINER, "DELAYING OBSERVER " +
          //    unhandled);
          delayed.add(unhandled);
        }
        // If there's nothing more, let's get back to delayed items that
        // are now worth looking at before moving on.
        if (queue.isEmpty()) {
          java.util.Iterator delayedIter = delayed.iterator();
          while (delayedIter.hasNext()) {
            Observer withheld = (Observer) delayedIter.next();

            boolean doneWaiting = true;
            SampledMetric[] withheldLeaves = withheld.getLeafSubjects();
            for (int i = 0; i < withheldLeaves.length; i++) {
              if (unobserved.contains(withheldLeaves[i])) {
                doneWaiting = false;
                break;
              }
            }
            if (doneWaiting) {
              queue.add(withheld);
            }
          }
        }
      }
    }
  }
}

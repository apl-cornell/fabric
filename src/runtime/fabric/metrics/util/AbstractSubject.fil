package fabric.metrics.util;

import fabric.util.Collection;
import fabric.util.Collections;
import fabric.util.Set;
import fabric.util.ArrayList;
import fabric.util.List;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.SortedSet;

import fabric.metrics.SampledMetric;

import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.Store;
import fabric.common.util.Triple;

import java.util.logging.Level;
import fabric.common.Logging;


/**
 * Base implementation of {@link Subject}
 */
public abstract class AbstractSubject implements Subject {

  private final ObserversBox observers;

  // Ugh, avoid getting a surrogate's store.
  public Store getStore() {
    return $getStore();
  }

  protected AbstractSubject fabric$metrics$util$AbstractSubject$() {
    fabric$lang$Object$();
    this.observers = new ObserversBox().fabric$metrics$util$ObserversBox$(this);
    return this;
  }

  /*@Override*/
  public void addObserver(Observer o) {
    static_addObserver(this, o);
  }

  private static void static_addObserver(AbstractSubject tmp, Observer o) {
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.observers.contains(o))
        tmp.observers.add(o);
    } else {
      atomic {
        if (!tmp.observers.contains(o))
          tmp.observers.add(o);
      }
    }
  }

  /*@Override*/
  public void removeObserver(Observer o) {
    static_removeObserver(this, o);
  }

  public static void static_removeObserver(AbstractSubject tmp, Observer o) {
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.observers.contains(o))
        tmp.observers.remove(o);
    } else {
      atomic {
        if (tmp.observers.contains(o))
          tmp.observers.remove(o);
      }
    }
  }

  /*@Override*/
  public boolean observedBy(Observer o) {
    return observers.contains(o);
  }

  /*@Override*/
  public boolean isObserved() {
    return !observers.isEmpty();
  }

  /*@Override*/
  public ImmutableObserverSet getObservers() {
    return observers.getObservers();
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   *
   * @param unobserved
   *            a {@link LinkedList} of {@link SampledMetric}s that have been
   *            updated and still need to have Observers compute the resulting
   *            effects for.
   */
  public static void processSamples(LinkedList unobserved) {
    LinkedList/*<Observer>*/ queue = new LinkedList/*<>*/();
    // Items that should be handled and need to be checked again later after
    // other children are processed.
    LinkedList/*<Observer>*/ delayed = new LinkedList/*<>*/();

    while (!unobserved.isEmpty()) {
      SampledMetric sm = (SampledMetric) unobserved.poll();
      ImmutableObserverSet obs = sm.getObservers();
      for (Iterator iter = obs.iterator(); iter.hasNext();) {
        queue.add(iter.next());
      }

      while (!queue.isEmpty()) {
        Observer unhandled = (Observer) queue.poll();
        // We're handling a delayed item, mark it as not delayed for
        // now. We'll delay it again if it's still not ready.
        delayed.remove(unhandled);

        boolean needToWait = false;
        ImmutableMetricsVector/*<SampledMetric>*/ leaves = unhandled.getLeafSubjects();
        for (int i = 0; i < leaves.length(); i++) {
          if (unobserved.contains(leaves.get(i))) {
            needToWait = true;
            break;
          }
        }

        if (!needToWait) {
          ImmutableObserverSet parentsToCheck = unhandled.handleUpdates();
          for (Iterator iter = parentsToCheck.iterator(); iter.hasNext();) {
            queue.add(iter.next());
          }
        } else {
          // mark as delayed for later processing
          delayed.add(unhandled);
        }

        if (queue.isEmpty()) {
          // See if any delayed items are now enabled.
          for (Iterator delayedIter = delayed.iterator(); delayedIter.hasNext();) {
            Observer withheld = (Observer) delayedIter.next();

            ImmutableMetricsVector/*<SampledMetric>*/ withheldLeaves = withheld.getLeafSubjects();
            boolean doneWaiting = true;
            for (int i = 0; i < withheldLeaves.length(); i++) {
              if (unobserved.contains(withheldLeaves.get(i))) {
                doneWaiting = false;
                break;
              }
            }

            if (doneWaiting) {
              queue.add(withheld);
            }
          }
        }
      }
    }
  }
}

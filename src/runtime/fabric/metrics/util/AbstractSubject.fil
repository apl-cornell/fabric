package fabric.metrics.util;

import fabric.util.Collection;
import fabric.util.Collections;
import java.util.LinkedList;
import fabric.util.Set;
import fabric.util.ArrayList;
import fabric.util.List;
import java.util.Iterator;

import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.Contract;

import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.Store;

//import java.util.logging.Level;
//import fabric.common.Logging;


/**
 * Base implementation of {@link Subject}
 */
public abstract class AbstractSubject implements Subject {

  // Ugh, avoid getting a surrogate's store.
  public Store getStore() {
    return $getStore();
  }

  protected AbstractSubject fabric$metrics$util$AbstractSubject$() {
    fabric$lang$Object$();
    this.$observers = ImmutableObserverSet.emptySet();
    return this;
  }

  /*@Override*/
  public void addObserver(Observer o) {
    static_addObserver(this, o);
  }

  private static void static_addObserver(AbstractSubject tmp, Observer o) {
    //Logging.METRICS_LOGGER.finer("ADD OBSERVER " + o + " FOR " + tmp + " IN " +
    //    TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (!tmp.$observers.contains(o))
        tmp.$observers = tmp.$observers.add(o);
    } else {
      atomic {
        if (!tmp.$observers.contains(o))
          tmp.$observers = tmp.$observers.add(o);
      }
    }
  }

  /*@Override*/
  public void removeObserver(Observer o) {
    static_removeObserver(this, o);
  }

  public static void static_removeObserver(AbstractSubject tmp, Observer o) {
    //Logging.METRICS_LOGGER.finer("REMOVE OBSERVER " + o + " FOR " + tmp + " IN "
    //    + TransactionManager.getInstance().getCurrentTid());
    if (TransactionManager.getInstance().inTxn()) {
      if (tmp.$observers.contains(o))
        tmp.$observers = tmp.$observers.remove(o);
    } else {
      atomic {
        if (tmp.$observers.contains(o))
          tmp.$observers = tmp.$observers.remove(o);
      }
    }
  }

  /*@Override*/
  public boolean observedBy(Observer o) {
    return $observers.contains(o);
  }

  /*@Override*/
  public boolean isObserved() {
    return !$observers.isEmpty();
  }

  /*@Override*/
  public ImmutableObserverSet getObservers() {
    return $observers;
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   *
   * @param unobserved
   *            a {@link LinkedList} of {@link SampledMetric}s that have been
   *            updated and still need to have Observers compute the resulting
   *            effects for.
   */
  public static void processSamples(LinkedList unobserved) {
    LinkedList/*<Observer>*/ queue = new LinkedList/*<>*/();
    // Items that should be handled and need to be checked again later after
    // other children are processed.
    LinkedList/*<Observer>*/ delayed = new LinkedList/*<>*/();
    while (!unobserved.isEmpty()) {
      SampledMetric sm = (SampledMetric) unobserved.poll();
      //Logging.METRICS_LOGGER.log(Level.FINER, "HANDLING OBSERVATION OF " + sm);
      ImmutableObserverSet obs = sm.getObservers();
      for (Iterator iter = obs.iterator(); iter.hasNext();) {
        queue.add(iter.next());
      }

      while (!queue.isEmpty()) {
        Observer unhandled = (Observer) queue.poll();
        // We're handling a delayed item, mark it as not delayed for
        // now. We'll delay it again if it's still not ready.
        delayed.remove(unhandled);

        boolean needToWait = false;
        ImmutableMetricsVector/*<SampledMetric>*/ leaves = unhandled.getLeafSubjects();
        for (int i = 0; i < leaves.length(); i++) {
          if (unobserved.contains(leaves.get(i))) {
            needToWait = true;
            break;
          }
        }
        // If this has no other pending sampled events, process it.
        if (!needToWait) {
          //Logging.METRICS_LOGGER.log(Level.FINE, "HANDLING OBSERVER {0}",
          //    unhandled);
          ImmutableObserverSet parentsToCheck = unhandled.handleUpdates();
          for (Iterator iter = parentsToCheck.iterator(); iter.hasNext();) {
            queue.add(iter.next());
          }
        } else {
          // mark as delayed for later processing
          //Logging.METRICS_LOGGER.log(Level.FINER, "DELAYING OBSERVER " +
          //    unhandled);
          delayed.add(unhandled);
        }
        // If there's nothing more, let's get back to delayed items that
        // are now worth looking at before moving on.
        if (queue.isEmpty()) {
          Iterator delayedIter = delayed.iterator();
          while (delayedIter.hasNext()) {
            Observer withheld = (Observer) delayedIter.next();

            boolean doneWaiting = true;
            ImmutableMetricsVector/*<SampledMetric>*/ withheldLeaves = withheld.getLeafSubjects();
            for (int i = 0; i < withheldLeaves.length(); i++) {
              if (unobserved.contains(withheldLeaves.get(i))) {
                doneWaiting = false;
                break;
              }
            }
            if (doneWaiting) {
              queue.add(withheld);
            }
          }
        }
      }
    }
  }
}

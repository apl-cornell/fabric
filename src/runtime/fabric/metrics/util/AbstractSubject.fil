package fabric.metrics.util;

import fabric.util.Collection;
import fabric.util.Collections;
//import fabric.util.LinkedHashSet;
import java.util.LinkedList;
import fabric.util.Set;
//import fabric.util.HashSet;
import fabric.util.ArrayList;
import fabric.util.Iterator;

import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.Contract;

import fabric.worker.transaction.TransactionManager;
import fabric.worker.Store;

import java.util.logging.Level;


/**
 * Base implementation of {@link Subject}
 */
public abstract class AbstractSubject implements Subject {

  // Ugh, avoid getting a surrogate's store.
  public Store getStore() {
    return $getStore();
  }

  protected AbstractSubject fabric$metrics$util$AbstractSubject$() {
    //this.observers = new LinkedHashSet/*<>*/().fabric$util$LinkedHashSet$(64);
    //this.observers = new HashSet/*<>*/().fabric$util$HashSet$(64);
    this.observers = new ArrayList/*<>*/().fabric$util$ArrayList$();
    fabric$lang$Object$();
    return this;
  }

  // Using a weak map as the backing for this set so that observers aren't
  // pinned by their subjects.
  private final ArrayList/*<Observer>*/ observers;

  /*@Override*/
  public void addObserver(Observer o) {
    static_addObserver(this, o);
  }

  private static void static_addObserver(AbstractSubject tmp, Observer o) {
    if (TransactionManager.getInstance().inTxn()) {
      fabric.common.Logging.METRICS_LOGGER.finer("ADD OBSERVER " + o + " FOR " + tmp + " IN " + TransactionManager.getInstance().getCurrentTid());
      if (!tmp.observers.contains(o))
        tmp.observers.add(o);
    } else {
      atomic {
        fabric.common.Logging.METRICS_LOGGER.finer("ADD OBSERVER " + o + " FOR " + tmp + " IN " + TransactionManager.getInstance().getCurrentTid());
        if (!tmp.observers.contains(o))
          tmp.observers.add(o);
      }
    }
  }

  /*@Override*/
  public void removeObserver(Observer o) {
    static_removeObserver(this, o);
  }

  public static void static_removeObserver(AbstractSubject tmp, Observer o) {
    if (TransactionManager.getInstance().inTxn()) {
      fabric.common.Logging.METRICS_LOGGER.finer("REMOVE OBSERVER " + o + " FOR " + tmp + " IN " + TransactionManager.getInstance().getCurrentTid());
      tmp.observers.remove(o);
    } else {
      atomic {
        fabric.common.Logging.METRICS_LOGGER.finer("REMOVE OBSERVER " + o + " FOR " + tmp + " IN " + TransactionManager.getInstance().getCurrentTid());
        tmp.observers.remove(o);
      }
    }
  }

  /*@Override*/
  public boolean observedBy(Observer o) {
    return observers.contains(o);
  }

  /*@Override*/
  public boolean isObserved() {
    return !observers.isEmpty();
  }

  /*@Override*/
  public Collection/*<Observer>*/ getObservers() {
    return observers;
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   *
   * @param unobserved
   *            a {@link LinkedList} of {@link SampledMetric}s that have been
   *            updated and still need to have Observers compute the resulting
   *            effects for.
   */
  public static void processSamples(LinkedList unobserved) {
    // Ugh, don't wrap this in an atomic block because it causes a copy to be
    // made with the items being processed, so subtransactions of this don't see
    // the handling we're doing.
    // TL;DR: I'm not sure it's needed and it was messing things up due to the
    // way we manage unobservedSamples in Log.
    // TODO: Change this to grab the right copy of the queue *after* the
    // subtransaction starts.
    //atomic {
      LinkedList/*<Observer>*/ queue = new LinkedList/*<>*/();
      // Items that should be handled and need to be checked again later after
      // other children are processed.
      LinkedList/*<Observer>*/ delayed = new LinkedList/*<>*/();
      while (!unobserved.isEmpty()) {
        SampledMetric sm = (SampledMetric) unobserved.poll();
        fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "HANDLING OBSERVATION OF " + sm);
        Iterator obsIter = sm.getObservers().iterator();
        while (obsIter.hasNext()) {
          queue.add(obsIter.next());
        }

        while (!queue.isEmpty()) {
          Observer unhandled = (Observer) queue.poll();
          // We're handling a delayed item, mark it as not delayed for
          // now. We'll delay it again if it's still not ready.
          delayed.remove(unhandled);

          boolean needToWait = false;
          SampledMetric[] leaves = unhandled.getLeafSubjects();
          for (int i = 0; i < leaves.length; i++) {
            if (unobserved.contains(leaves[i])) {
              needToWait = true;
              break;
            }
          }
          // If this has no other pending sampled events, process it.
          if (!needToWait) {
            fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "HANDLING OBSERVER " + unhandled);
            boolean modified = unhandled.handleUpdates();
            if (unhandled instanceof Subject && modified) {
              fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "QUEUING PARENTS OF OBSERVER " + unhandled);
              //queue.addAll(parents);
              Iterator parentIter = ((Subject) unhandled).getObservers().iterator();
              while (parentIter.hasNext()) {
                queue.add(parentIter.next());
              }
            }
          } else {
            // mark as delayed for later processing
            fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "DELAYING OBSERVER " + unhandled);
            delayed.add(unhandled);
          }
          // If there's nothing more, let's get back to delayed items that
          // are now worth looking at before moving on.
          if (queue.isEmpty()) {
            java.util.Iterator delayedIter = delayed.iterator();
            while (delayedIter.hasNext()) {
              Observer withheld = (Observer) delayedIter.next();

              boolean doneWaiting = true;
              SampledMetric[] withheldLeaves = withheld.getLeafSubjects();
              for (int i = 0; i < withheldLeaves.length; i++) {
                if (unobserved.contains(withheldLeaves[i])) {
                  doneWaiting = false;
                  break;
                }
              }
              if (doneWaiting) {
                queue.add(withheld);
              }
            }
          }
        }
      }
    //}
  }
}

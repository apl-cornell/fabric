package fabric.metrics.util;

import fabric.common.TransactionID;
import fabric.worker.transaction.TransactionManager;
import fabric.worker.TransactionRestartingException;

import fabric.common.Logging;
import java.util.logging.Level;

/**
 * Utility class acting as a lock for Contracts to help with reconfigurations.
 */
public class ReconfigLock {

  private boolean currentlyHeld;

  /**
   * @param startValue
   *        initial guess for the mean of the value we're keeping
   *        statistics on.
   */
  public ReconfigLock fabric$metrics$util$ReconfigLock$() {
    fabric$lang$Object$();
    // Starts out held by the creating transaction (released at the end before
    // committing)
    this.currentlyHeld = true;
    TransactionManager tm = TransactionManager.getInstance();
    tm.registerLockCreate(this);
    return this;
  }

  /**
   * Check if we currently own the lock.
   */
  public boolean held() {
    return currentlyHeld && TransactionManager.getInstance().hasLock(this);
  }

  /**
   * Check that this item hasn't been locked by another process.
   */
  public void checkForRead() {
    TransactionManager tm = TransactionManager.getInstance();
    Logging.METRICS_LOGGER.log(Level.FINE, "CHECKING READ OF {0} IN {1}",
        new java.lang.Object native[] { this, tm.getCurrentTid() });
    if (currentlyHeld && !tm.hasLock(this)) {
      TransactionID current = tm.getCurrentTid();
      if (current != null) {
        while (current.parent != null) current = current.parent;
        Logging.METRICS_LOGGER.fine("ABORTING READ IN " + current +
            " FOR LOCK " + this);
        // XXX: Dumb hack to avoid issues with stale lock.
        tm.checkForStaleObjects();
        throw new TransactionRestartingException(
            new TransactionID(current.topTid));
      }
    }
  }

  /**
   * Acquire the lock.
   */
  public void acquire() {
    TransactionManager tm = TransactionManager.getInstance();
    Logging.METRICS_LOGGER.log(Level.FINE, "ATTEMPTING ACQUIRE OF {0} IN {1}",
        new java.lang.Object native[] { this, tm.getCurrentTid() });
    if (!tm.hasLock(this)) {
      if (!currentlyHeld) {
        tm.registerLockAcquire(this);
        currentlyHeld = true;
      } else {
        TransactionID current = tm.getCurrentTid();
        if (current != null) {
          while (current.parent != null) current = current.parent;
          Logging.METRICS_LOGGER.fine("ABORTING ACQUIRE " + current +
              " FOR LOCK " + this);
          // XXX: Dumb hack to avoid issues with stale lock.
          tm.checkForStaleObjects();
          throw new TransactionRestartingException(
              new TransactionID(current.topTid));
        }
      }
    }
  }

  /**
   * Release the lock.
   */
  public void release() {
    currentlyHeld = false;
    TransactionManager.getInstance().registerLockRelease(this);
  }
}

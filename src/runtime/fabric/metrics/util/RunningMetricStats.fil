package fabric.metrics.util;

/**
 * Utility class for tracking the sample mean and sample standard deviation of a
 * value that is updated periodically.
 * <p>
 * This was originally based on a post on John D. Cook's blog here:
 * https://www.johndcook.com/blog/standard_deviation/
 * <p>
 * That post assumed a stable distribution. This has since been modified to use
 * EWMA.
 */
public class RunningMetricStats {

  // The sensitivity parameter for computing exponentially weighted moving
  // averages.
  public static final double ALPHA = 0.001;

  private double value;
  private double meanDelta = 0.0;
  private double varDelta = 0.0;
  private double meanDeltaPrev = 0.0;
  private double varDeltaPrev = 0.0;
  private final double startDelta;
  private double meanInterval = 0.0;
  private double meanIntervalPrev = 0.0;
  private final double startInterval;
  private long lastUpdate;
  private long samples = 0;

  /*@Override*/
  public String toString() {
    return "[" +
      " value " + value +
      " samples " + samples +
      " meanDelta " + meanDelta +
      " varDelta " + varDelta +
      " meanInterval " + meanInterval +
      " velocity " + getVelocityEstimate() +
      " noise " + getNoiseEstimate() +
    " ]";
  }

  /**
   * @param startValue
   *        initial guess for the mean of the value we're keeping
   *        statistics on.
   */
  public RunningMetricStats fabric$metrics$util$RunningMetricStats$(double startValue, double startDelta, double startInterval) {
    this.value = startValue;
    this.startDelta = startDelta;
    this.startInterval = startInterval;
    fabric$lang$Object$();
    meanDeltaPrev = startDelta;
    meanDelta = startDelta;
    meanIntervalPrev = startInterval;
    meanInterval = startInterval;
    lastUpdate = System.currentTimeMillis() - 1;
    return this;
  }

  /**
   * Reset estimation to just the startValue.
   */
  public void reset() {
    meanIntervalPrev = startInterval;
    meanInterval = startInterval;
    meanDeltaPrev = startDelta;
    meanDelta = startDelta;
    varDeltaPrev = 0.0;
    varDelta = 0.0;
    samples = 0;
  }

  /**
   * @return the current value.
   */
  public double getValue() {
    return value;
  }

  /**
   * Compute an estimated velocity, assuming normal distribution of values and
   * exponential distribution of intervals.
   *
   * @return the current estimated velocity.
   */
  public double getVelocityEstimate() {
    // Account for time that's passed since last observation.
    if (samples == 0)
      return 0.0;
    long intervalSince = (System.currentTimeMillis() - lastUpdate);
    double curInterval = getMeanInterval();
    double curBias = getMeanDelta();
    double newInterval = curInterval;
    double newBias = curBias;
    if (intervalSince > 0) {
        double nextAlpha = getNextAlpha();
        newInterval = (curInterval + nextAlpha * (intervalSince - curInterval));
        newBias = (curBias * (1.0 - nextAlpha));
    }
    return newBias / newInterval;
  }

  /**
   * Compute an estimated noise, assuming normal distribution of values and
   * exponential distribution of intervals.
   *
   * @return the current estimated noise.
   */
  public double getNoiseEstimate() {
    // Assuming that there's 0 covariance between update intervals and update
    // values.
    // Account for time that's passed since last observation.
    if (samples <= 1)
      return 0.0;
    long intervalSince = (System.currentTimeMillis() - lastUpdate);
    double curInterval = getMeanInterval();
    double curBias = getMeanDelta();
    double curBiasVar = getVarDelta();
    double newInterval = curInterval;
    double newBias = curBias;
    double newBiasVar = curBiasVar;
    if (intervalSince > 0) {
      double nextAlpha = getNextAlpha();
      newInterval = (curInterval + nextAlpha * (intervalSince - curInterval));
      newBias = (curBias * (1.0 - nextAlpha));
      newBiasVar = (1.0 - nextAlpha) * curBiasVar + nextAlpha * (curBias * newBias);
    }
    double tSqrd = newInterval * newInterval;
    // We're assuming exponential distribution of the times and here we get
    // the variance of the product of independent poisson (1/exp) and
    // normally distributed variables.
    return (1 / newInterval + newBiasVar / tSqrd);
  }

  /**
   * @return the last update time.
   */
  public long getLastUpdate() {
    return lastUpdate;
  }

  /**
   * @return the number of samples taken.
   */
  public long getSamples() {
    return samples;
  }

  /**
   * @return the current estimated meanDelta.
   */
  public double getMeanDelta() {
    return (samples > 0) ? meanDelta : startDelta;
  }

  /**
   * @return the current estimated meanInterval.
   */
  public double getMeanInterval() {
    return (samples > 0) ? meanInterval : startInterval;
  }

  /**
   * @return the current estimated variance of the delta.
   */
  public double getVarDelta() {
    return (samples > 1) ?  varDelta : 0.0;
  }

  /**
   * Update with a new observation.
   *
   * @param val
   *        the newly observed value.
   */
  public void update(double newVal) {
    // TODO: Use later of creation and boot time for lastUpdate if this is the
    // first sample.
    // Update samples count
    samples++;
    long curTime = System.currentTimeMillis();
    double interval = curTime - lastUpdate;
    double val = newVal - value;
    lastUpdate = curTime;
    value = newVal;

    if (samples == 1) {
      // Update interval stats
      meanInterval = interval;
      meanIntervalPrev = interval;

      // Update delta stats
      meanDelta = val;
      meanDeltaPrev = val;
      varDeltaPrev = 0.0;
    } else {
      double curAlpha = getCurAlpha();
      // Update interval stats
      meanInterval = meanIntervalPrev +
        curAlpha * (interval - meanIntervalPrev);
      meanIntervalPrev = meanInterval;

      // Update delta stats
      meanDelta = meanDeltaPrev +
        curAlpha * (val - meanDeltaPrev);
      varDelta = (1.0 - curAlpha) * varDeltaPrev
          + curAlpha * (val - meanDeltaPrev) * (val - meanDelta);

      meanDeltaPrev = meanDelta;
      varDeltaPrev = varDelta;
    }
  }

  private double getCurAlpha() {
    return Math.max(ALPHA, 1 / (samples - 1));
  }

  private double getNextAlpha() {
    return Math.max(ALPHA, 1 / samples);
  }
}

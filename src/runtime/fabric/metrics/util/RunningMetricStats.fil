package fabric.metrics.util;

import fabric.worker.metrics.PresetMetricStatistics;

/**
 * Utility class for tracking the sample mean and sample standard deviation of a
 * value that is updated periodically.
 * <p>
 * This was originally based on a post on John D. Cook's blog here:
 * https://www.johndcook.com/blog/standard_deviation/
 * <p>
 * That post assumed a stable distribution. This has since been modified to use
 * EWMA.
 */
public class RunningMetricStats {

  // The sensitivity parameter for computing exponentially weighted moving
  // averages.
  public static final double ALPHA = Worker.getWorker().config.alpha;
  // Window for binning poisson observations.
  public static final long POISSON_WINDOW = Worker.getWorker().config.window;

  private double value;
  private double meanDelta = 0.0;
  private double varDelta = 0.0;
  private final double startDelta;
  private double meanFreq = 0.0;
  private double varFreq = 0.0;
  private final double startInterval;
  private long lastUpdate;
  private long firstUpdate;
  private long samples = 0;
  // Samples that don't fall into the window of the last update or later.
  private long samplesPrior = 0;

  /*@Override*/
  public String toString() {
    return "[" +
      " value " + value +
      " samples " + samples +
      " meanDelta " + meanDelta +
      " varDelta " + varDelta +
      " meanFreq " + getMeanFreq(System.currentTimeMillis()) +
      " varFreq " + getVarFreq(System.currentTimeMillis()) +
      " velocity " + getVelocityEstimate() +
      " noise " + getNoiseEstimate() +
    " ]";
  }

  /**
   * @param startValue
   *        initial guess for the mean of the value we're keeping
   *        statistics on.
   */
  public RunningMetricStats fabric$metrics$util$RunningMetricStats$(double startValue, double startDelta, double startInterval) {
    this.value = startValue;
    this.startDelta = startDelta;
    this.startInterval = startInterval;
    fabric$lang$Object$();
    meanDelta = startDelta;
    meanFreq = 0.0;
    lastUpdate = System.currentTimeMillis() - 1;
    firstUpdate = lastUpdate;
    return this;
  }

  /**
   * Reset estimation to just the startValue.
   */
  public void reset() {
    meanFreq = 0.0;
    varFreq = 0.0;
    meanDelta = startDelta;
    varDelta = 0.0;
    samples = 0;
    samplesPrior = 0;
    lastUpdate = System.currentTimeMillis() - 1;
    firstUpdate = lastUpdate;
  }

  /**
   * @return the current value.
   */
  public double getValue() {
    return value;
  }

  /**
   * Compute an estimated velocity, assuming normal distribution of values and
   * exponential distribution of intervals.
   *
   * @return the current estimated velocity.
   */
  public double getVelocityEstimate() {
    // Account for time that's passed since last observation.
    if (samples == 0)
      return 0.0;
    double delta = getMeanDelta();
    double freq = getMeanFreq(System.currentTimeMillis());
    return delta * freq;
  }

  /**
   * Compute an estimated noise, assuming normal distribution of values and
   * exponential distribution of intervals.
   *
   * @return the current estimated noise.
   */
  public double getNoiseEstimate() {
    // Assuming that there's 0 covariance between update intervals and update
    // values.
    if (samples <= 1)
      return 0.0;
    double meanDelta = getMeanDelta();
    double varDelta = getVarDelta();
    long curTime = System.currentTimeMillis();
    double meanFreq = getMeanFreq(curTime);
    // Assuming poisson, variance _should_ be the same as the frequency
    double varFreq = getVarFreq(curTime);
    return (varFreq * varDelta + meanFreq * varDelta + varFreq * meanDelta);
  }

  /**
   * @return the last update time.
   */
  public long getLastUpdate() {
    return lastUpdate;
  }

  /**
   * @return the number of samples taken.
   */
  public long getSamples() {
    return samples;
  }

  /**
   * @return the current estimated meanDelta.
   */
  public double getMeanDelta() {
    return (samples > 0) ? meanDelta : startDelta;
  }

  /**
   * @return the current estimated variance of the delta.
   */
  public double getVarDelta() {
    return (samples > 1) ?  varDelta : 0.0;
  }

  /**
   * Update with a new observation.
   *
   * @param val
   *        the newly observed value.
   */
  public void update(double newVal) {
    // TODO: Use later of creation and boot time for lastUpdate if this is the
    // first sample.
    // Update samples count
    long curTime = System.currentTimeMillis();
    double val = newVal - value;
    value = newVal;

    if (samples == 0) {
      // Update delta stats
      meanDelta = val;

      // Update interval stats
      // XXX: Don't do much here, we haven't seen any updates beyond the
      // starting value.
      firstUpdate = curTime;
      lastUpdate = curTime;
    } else {
      // Update delta stats
      double curAlphaDelta = getCurAlphaDelta();
      double meanDeltaPrev = meanDelta;
      meanDelta = meanDeltaPrev + curAlphaDelta * (val - meanDeltaPrev);
      varDelta = (1.0 - curAlphaDelta) * varDelta +
        curAlphaDelta * (val - meanDeltaPrev) * (val - meanDelta);

      // Update freq stats
      updateFreq(curTime);
    }
    samples++;
  }

  private void updateFreq(long time) {
    if (samples == 0) {
      // Don't bother, we don't have enough data.
      return;
    }
    long oldWindows = (lastUpdate - firstUpdate) / POISSON_WINDOW;
    long windowsUnprocessed = getRecentWindows(time);
    for (long windowSince = 1; windowSince < windowsUnprocessed; windowSince++) {
      // At least alpha, at most 1.  Use 1 if this is the first ever window
      double alpha = Math.max(ALPHA, 1.0 / (oldWindows + windowSince));
      double meanFreqPrev = meanFreq;
      double varFreqPrev = varFreq;
      // Account for the unfinished data in the current window.
      double unfinishedWindow =
          (samples - samplesPrior) / ((double) POISSON_WINDOW);
      // Mark those samples as processed
      samplesPrior = samples;
      if (alpha == ALPHA) {
        // Speed up now that we're at steady state.  This runs the rest of the
        // remaining windows, since there are no samples past the first window.
        long windowsLeft = (windowsUnprocessed - windowSince) - 1;

        meanFreq = Math.pow(1.0 - alpha, windowsLeft) *
          ((1.0 - alpha) * meanFreqPrev + alpha * unfinishedWindow);

        varFreq = Math.pow(1.0 - alpha, windowsLeft) *
          (((1.0 - alpha) *
            (varFreqPrev +
             (alpha *
              ((unfinishedWindow - meanFreqPrev) *
               (unfinishedWindow - meanFreqPrev))))) +
           ((1.0 - Math.pow(1.0 - alpha, windowsLeft)) *
            (((1.0 - alpha) * meanFreqPrev - alpha * unfinishedWindow) *
             ((1.0 - alpha) * meanFreqPrev - alpha * unfinishedWindow))));
        // We just sped through the rest, let's stop.
        break;
      } else {
        // Slow path, we are changing alpha in this case and haven't solved this
        // version closed form...
        meanFreq = meanFreq + alpha * (unfinishedWindow - meanFreq);

        varFreq = (1.0 - alpha) * varFreq +
          alpha *
          (unfinishedWindow - meanFreqPrev) * (unfinishedWindow - meanFreq);
      }
    }
    lastUpdate = time;
  }

  /**
   * Calculate the mean frequency, accounting for empty windows since the last
   * update.
   */
  private double getVarFreq(long time) {
    // Use 0 frequency if we haven't seen an update.
    long totalWindows = (time - firstUpdate) / POISSON_WINDOW;
    if (totalWindows <= 1)
      return 0.0;
    updateFreq(time);
    // Now interpolate for the current window.
    long oldWindows = (lastUpdate - firstUpdate) / POISSON_WINDOW;
    double alpha = Math.max(ALPHA, 1.0 / (oldWindows + 1));
    long timeInCurWindow = time -
      (((long) (time / POISSON_WINDOW)) * POISSON_WINDOW);
    long timeLeftInCurWindow = POISSON_WINDOW - timeInCurWindow;
    double interpolatedWindow =
      (meanFreq * timeLeftInCurWindow + (samples - samplesPrior))
      / POISSON_WINDOW;
    double meanFreqNext = meanFreq + alpha * (interpolatedWindow - meanFreq);
    return (1.0 - alpha) * varFreq + alpha * (interpolatedWindow - meanFreq) *
      (interpolatedWindow - meanFreqNext);
  }

  /**
   * Calculate the mean frequency, accounting for empty windows since the last
   * update.
   */
  private double getMeanFreq(long time) {
    // Use 0 frequency if we haven't seen an update.
    long totalWindows = (time - firstUpdate) / POISSON_WINDOW;
    if (totalWindows == 0)
      return 0.0;
    updateFreq(time);
    // Now interpolate for the current window.
    long oldWindows = (lastUpdate - firstUpdate) / POISSON_WINDOW;
    double alpha = Math.max(ALPHA, 1.0 / (oldWindows + 1));
    long timeInCurWindow = time -
      (((long) (time / POISSON_WINDOW)) * POISSON_WINDOW);
    long timeLeftInCurWindow = POISSON_WINDOW - timeInCurWindow;
    double interpolatedWindow =
      (meanFreq * timeLeftInCurWindow + (samples - samplesPrior))
      / POISSON_WINDOW;
    return meanFreq + alpha * (interpolatedWindow - meanFreq);
  }

  /**
   * Return the total number of windows we've seen since the last update.
   */
  private long getRecentWindows(long time) {
    if (samples == 0) return 0;
    return Math.max(0, (time / POISSON_WINDOW) - (lastUpdate / POISSON_WINDOW));
  }

  private double getCurAlphaDelta() {
    return Math.max(ALPHA, 1.0 / samples);
  }

  private double getNextAlphaDelta() {
    return Math.max(ALPHA, 1.0 / (samples + 1));
  }

  /**
   * Support preloading based on a string key.
   *
   * Should be called right before the next update to ensure the lastUpdate
   * configuration is roughly accurate.
   */
  public void preload(String key) {
    // Only bother if this is a fresh slate
    if (samples == 0) {
      PresetMetricStatistics p = (PresetMetricStatistics) Worker.getWorker().config.presets.get(key);
      // If there's a preset, load it in.
      if (p != null) {
        samples = p.getSamples();
        samplesPrior = samples;
        meanDelta = p.getMeanDelta();
        varDelta = p.getVarDelta();
        meanFreq = p.getMeanFreq();
        varFreq = p.getVarFreq();
        lastUpdate = p.getLastUpdate();
        firstUpdate = p.getFirstUpdate();
      }
    }
  }
}

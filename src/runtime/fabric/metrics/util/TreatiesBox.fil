package fabric.metrics.util;

import fabric.metrics.Metric;
import fabric.metrics.treaties.Treaty;
import fabric.worker.metrics.ImmutableMetricsVector;
import fabric.worker.metrics.ImmutableObjectSet;
import fabric.worker.metrics.ImmutableObserverSet;
import fabric.worker.metrics.StatsMap;
import fabric.worker.metrics.treaties.TreatySet;
import fabric.worker.metrics.treaties.statements.TreatyStatement;
import java.util.Iterator;

/**
 * Utility to make treaties and observers exist outside of metrics for the
 * purposes of managing contention and conflicts between transactions.
 *
 * This acts as a proxy for the Metric's treaties and observers.
 * TODO: Should this still be a proxy?
 */
public class TreatiesBox implements Iterable/*<Treaty>*/ {

  public final Metric owner;

  private TreatySet treaties;

  public TreatiesBox fabric$metrics$util$TreatiesBox$(Metric m) {
    this.owner = m;
    fabric$lang$Object$();
    this.$associates = ImmutableObjectSet.emptySet().add(m);
    // TODO: add treaties as associates as they get added.
    this.treaties = TreatySet.emptySet(this);
    return this;
  }

  public int size() {
    return treaties.size();
  }

  public Iterator/*<Treaty>*/ iterator() {
    return treaties.iterator();
  }

  public void remove(Treaty treaty) {
    treaties.remove(treaty);
  }

  public Treaty get(TreatyStatement stmt) {
    return treaties.get(stmt);
  }

  public Treaty create(TreatyStatement stmt, StatsMap statsMap) {
    return treaties.create(stmt, statsMap);
  }
}

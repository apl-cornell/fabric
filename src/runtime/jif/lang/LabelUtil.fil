package jif.lang;

import jif.lang.Label;
import jif.lang.Principal;
import jif.lang.PrincipalUtil;
import fabric.client.Client;
import fabric.client.Core;
import fabric.util.*;

/**
 * A Label is the runtime representation of a Jif label. A Label consists of a
 * set of components, each of which is a jif.lang.Policy. This code is
 * mostly copied from Jif.
 */
public final class LabelUtil {
  private LabelUtil() {
  }

// ALL STATS-RELATED STUFF HAS BEEN DISABLED DUE TO BOOTSTRAPPING ISSUES.
// (How would we create the label of the Stats object?)  -MJL 
//  /*
//   * fields and class for collecting timing statistics. timing statistics are
//   * collected on a per-thread basis.
//   */
//  private static class Stats {
//    private long totalTime = 0;
//    private long enterStartTime = 0;
//    private int callStackCount = 0;
//    private int callCount = 0;
//    private int topCallCount = 0;
//  }
//
//  private static ThreadLocal statsPerThread = new ThreadLocal() {
//    protected Object initialValue() {
//      Core core = Client.getClient().getLocalCore();
//      return new Stats@core();
//    }
//  };
//  public static final boolean COUNT_TIME = false;

  public static final boolean USE_CACHING = true;
  
  public static final LocalCore localCore = Client.getClient().getLocalCore();

  // caches
  private static Set/* <Pair> */cacheTrueLabelRelabels = new HashSet/* <Pair> */();
  private static Set/* <Pair> */cacheFalseLabelRelabels = new HashSet/* <Pair> */();
  private static Map/* <DelegationPair, Set<Pair>> */cacheTrueLabelRelabelsDependencies =
      new HashMap/* <DelegationPair, Set<Pair>> */();
  private static Map/* <Pair, Set<DelegationPair>> */cacheTruePolicyRelabels =
      new HashMap/* <Pair, Set<DelegationPair>> */();
  private static Set/* <Pair> */cacheFalsePolicyRelabels =
      new HashSet/* <Pair> */();
  private static Map/* <DelegationPair, Set<Pair>> */cacheTruePolicyRelabelsDependencies =
      new HashMap/* <DelegationPair, Set<Pair>> */();
  private static Map/* <Pair, Label> */cacheLabelJoins =
      new HashMap/* <Pair, Label> */();
  private static Map/* <Pair, Label> */cacheLabelMeets =
      new HashMap/* <Pair, Label> */();
  private static Map/* <DelegationPair, Set<Pair>> */cacheLabelJoinDependencies =
      new HashMap/* <DelegationPair, Set<Pair>> */();
  private static Map/* <DelegationPair, Set<Pair>> */cacheLabelMeetDependencies =
      new HashMap/* <DelegationPair, Set<Pair>> */();

  /*
   * Record that we are entering a section of code that we want to record the
   * timing of.
   */
  static void enterTiming() {
//    if (COUNT_TIME) {
//      Stats stats = (Stats) statsPerThread.get();
//      stats.callCount++;
//      if (stats.callStackCount++ == 0) {
//        stats.topCallCount++;
//        stats.enterStartTime = System.currentTimeMillis();
//      }
//    }
  }

  /*
   * Record that we are exiting a section of code that we want to record the
   * timing of.
   */
  static void exitTiming() {
//    if (COUNT_TIME) {
//      Stats stats = (Stats) statsPerThread.get();
//      if ((--stats.callStackCount) == 0) {
//        stats.totalTime += (System.currentTimeMillis() - stats.enterStartTime);
//      }
//    }
  }

  /*
   * Return the total time spent by the current thread in code we recorded the
   * timing of, since the last time this method was called, and/or the thread
   * created (whichever was last). Also clears the total time recorded for this
   * thread.
   */
  public static long getAndClearTime() {
    long r = -1;
//    if (COUNT_TIME) {
//      Stats stats = (Stats) statsPerThread.get();
//      r = stats.totalTime;
//      stats.totalTime = 0;
//    }
    return r;
  }

  /*
   * Return the total count of calls to enterTiming() since the last time this
   * method was called, and/or the thread created (whichever was last). Also
   * clears the total time recorded for this thread.
   */
  public static int getAndClearCount() {
    int r = -1;
//    if (COUNT_TIME) {
//      Stats stats = (Stats) statsPerThread.get();
//      r = stats.callCount;
//      stats.callCount = 0;
//    }
    return r;
  }

  public static int getAndClearTopCount() {
    int r = -1;
//    if (COUNT_TIME) {
//      Stats stats = (Stats) statsPerThread.get();
//      r = stats.topCallCount;
//      stats.topCallCount = 0;
//    }
    return r;
  }

  public static Label noComponents() {
    return localCore.getEmptyLabel();
  }

  public static ConfPolicy bottomConf() {
    return localCore.getBottomConfidPolicy();
  }
  
  public static ConfPolicy topConf() {
    return localCore.getTopConfidPolicy();
  }

  public static IntegPolicy topInteg() {
    return localCore.getTopIntegPolicy();
  }

  public static ConfPolicy readerPolicy(Core core, Principal owner,
      Principal reader) {
    try {
      enterTiming();
      Label label = localCore.getPublicReadonlyLabel();
      return new ReaderPolicy~label@core(owner, reader);
    } finally {
      exitTiming();
    }
  }

  public static ConfPolicy readerPolicy(Core core, Principal owner,
      Collection/* <Principal> */readers) {
    try {
      enterTiming();
      return readerPolicy(core, owner,
          PrincipalUtil.disjunction(core, readers));
    } finally {
      exitTiming();
    }
  }

  /**
   * See the Jif signature for the explanation of lbl.
   */
  public static ConfPolicy readerPolicy(Core core, Label lbl,
      Principal owner, Principal[] readers) {
    try {
      enterTiming();
      if (readers == null)
        return readerPolicy(core, owner, Collections.EMPTY_SET);
      return readerPolicy(core, owner, Arrays.asList(readers));
    } finally {
      exitTiming();
    }
  }

  public static ConfPolicy readerPolicy(Core core, Principal owner,
      PrincipalSet writers) {
    try {
      enterTiming();
      return readerPolicy(core, owner, writers.getSet());
    } finally {
      exitTiming();
    }
  }

  public static Label readerPolicyLabel(Core core, Principal owner,
      Principal reader) {
    try {
      enterTiming();
      return toLabel(core, readerPolicy(core, owner, reader));
    } finally {
      exitTiming();
    }
  }

  public static Label readerPolicyLabel(Core core, Principal owner,
      Collection/* <Principal> */readers) {
    try {
      enterTiming();
      Label l =
          toLabel(core, readerPolicy(core, owner,
              PrincipalUtil.disjunction(core, readers)));
      return l;
    } finally {
      exitTiming();
    }
  }

  /**
   * See the Jif signature for the explanation of lbl.
   */
  public static Label readerPolicyLabel(Core core, Label lbl,
      Principal owner, Principal[] readers) {
    try {
      enterTiming();
      if (readers == null)
        return readerPolicyLabel(core, owner, Collections.EMPTY_SET);
      return readerPolicyLabel(core, owner, Arrays.asList(readers));
    } finally {
      exitTiming();
    }
  }

  public static Label readerPolicyLabel(Core core, Principal owner,
      PrincipalSet readers) {
    try {
      enterTiming();
      return readerPolicyLabel(core, owner, PrincipalUtil.disjunction(core,
          readers.getSet()));
    } finally {
      exitTiming();
    }
  }

  public static IntegPolicy writerPolicy(Core core, Principal owner, Principal writer) {
    try {
      enterTiming();
      Label label = localCore.getPublicReadonlyLabel();
      return new WriterPolicy~label@core(owner, writer);
    } finally {
      exitTiming();
    }
  }

  public static IntegPolicy writerPolicy(Core core, Principal owner,
      Collection/* <Principal> */writers) {
    try {
      enterTiming();
      return writerPolicy(core, owner, PrincipalUtil.disjunction(core, writers));
    } finally {
      exitTiming();
    }
  }

  public static Label writerPolicyLabel(Core core, Principal owner, Principal writer) {
    try {
      enterTiming();
      return toLabel(core, writerPolicy(core, owner, writer));
    } finally {
      exitTiming();
    }
  }

  public static Label writerPolicyLabel(Core core, Principal owner,
      Collection/* <Principal> */writers) {
    try {
      enterTiming();
      return toLabel(core, writerPolicy(core, owner,
          PrincipalUtil.disjunction(core, writers)));
    } finally {
      exitTiming();
    }
  }

  /**
   * See the Jif signature for the explanation of lbl.
   */
  public static Label writerPolicyLabel(Core core, Label lbl, Principal owner,
      Principal[] writers) {
    try {
      enterTiming();
      if (writers == null)
        return writerPolicyLabel(core, owner, Collections.EMPTY_SET);
      return writerPolicyLabel(core, owner, Arrays.asList(writers));
    } finally {
      exitTiming();
    }
  }

  /**
   * See the Jif signature for the explanation of lbl.
   */
  public static IntegPolicy writerPolicy(Core core, Label lbl, Principal owner,
      Principal[] writers) {
    try {
      enterTiming();
      if (writers == null)
        return writerPolicy(core, owner, Collections.EMPTY_SET);
      return writerPolicy(core, owner, Arrays.asList(writers));
    } finally {
      exitTiming();
    }
  }

  public static IntegPolicy writerPolicy(Core core, Principal owner,
      PrincipalSet writers) {
    try {
      enterTiming();
      return writerPolicy(core, owner, writers.getSet());
    } finally {
      exitTiming();
    }
  }

  public static Label toLabel(Core core, ConfPolicy cPolicy, IntegPolicy iPolicy) {
    try {
      enterTiming();
      if (cPolicy == null || iPolicy == null)
        throw new NullPointerException@localCore();
      return new PairLabel@core(cPolicy, iPolicy);
    } finally {
      exitTiming();
    }
  }

  public static Label toLabel(Core core, ConfPolicy policy) {
    try {
      enterTiming();
      return new PairLabel@core(policy, topInteg());
    } finally {
      exitTiming();
    }
  }

  public static Label toLabel(Core core, IntegPolicy policy) {
    try {
      enterTiming();
      return new PairLabel@core(bottomConf(), policy);
    } finally {
      exitTiming();
    }
  }

  public static Label join(Core core, Label l1, Label l2) {
    try {
      enterTiming();
      if (l1 == null) return l2;
      if (l2 == null) return l1;

      if (l1 instanceof PairLabel && l2 instanceof PairLabel) {
        Label result = null;
        Pair pair = new Pair(l1, l2);
        if (USE_CACHING) {
          result = (Label) cacheLabelJoins.get(pair);
        }
        if (result == null) {
          PairLabel pl1 = (PairLabel) l1;
          PairLabel pl2 = (PairLabel) l2;
          Set dependencies = new HashSet@core();
          result =
              new PairLabel@core(pl1.confPolicy().join(core, pl2.confPolicy(), dependencies),
                  pl1.integPolicy().join(core, pl2.integPolicy(), dependencies));
          if (USE_CACHING) {
            // add dependencies from delegations to the cache result
            // i.e., what dependencies does this result rely on?
            for (Iterator iter = dependencies.iterator(); iter.hasNext();) {
              PrincipalUtil.DelegationPair del =
                  (PrincipalUtil.DelegationPair) iter.next();
              Set/* <Pair> */deps = (Set) cacheLabelJoinDependencies.get(del);
              if (deps == null) {
                deps = new HashSet/* <Pair> */();
                cacheLabelJoinDependencies.put(del, deps);
              }
              deps.add(pair);
            }
            cacheLabelJoins.put(pair, result);
          }
        }
        return result;

      }
      // error! non pair labels!
      return null;
    } finally {
      exitTiming();
    }
  }

  public static Label meetLbl(Core core, Label l1, Label l2) {
    try {
      enterTiming();
      return meet(core, l1, l2);
    } finally {
      exitTiming();
    }
  }

  public static Label meet(Core core, Label l1, Label l2) {
    try {
      enterTiming();
      if (l1 == null) return l2;
      if (l2 == null) return l1;

      if (l1 instanceof PairLabel && l2 instanceof PairLabel) {
        Label result = null;
        Pair pair = new Pair(l1, l2);
        if (USE_CACHING) {
          result = (Label) cacheLabelMeets.get(pair);
        }
        if (result == null) {
          PairLabel pl1 = (PairLabel) l1;
          PairLabel pl2 = (PairLabel) l2;
          Set dependencies = new HashSet@core();
          result =
              new PairLabel@core(pl1.confPolicy().meet(core, pl2.confPolicy(), dependencies),
                  pl1.integPolicy().meet(core, pl2.integPolicy(), dependencies));
          if (USE_CACHING) {
            // add dependencies from delegations to the cache result
            // i.e., what dependencies does this result rely on?
            for (Iterator iter = dependencies.iterator(); iter.hasNext();) {
              PrincipalUtil.DelegationPair del =
                  (PrincipalUtil.DelegationPair) iter.next();
              Set/* <Pair> */deps = (Set) cacheLabelMeetDependencies.get(del);
              if (deps == null) {
                deps = new HashSet/* <Pair> */();
                cacheLabelMeetDependencies.put(del, deps);
              }
              deps.add(pair);
            }
            cacheLabelMeets.put(pair, result);
          }
        }
        return result;
      }

      // error! non pair labels!
      return null;
    } finally {
      exitTiming();
    }
  }

  public static ConfPolicy join(Core core, ConfPolicy p1, ConfPolicy p2) {
    try {
      enterTiming();
      return join(core, p1, p2, new HashSet/* <DelegationPair> */@core());
    } finally {
      exitTiming();
    }
  }

  protected static ConfPolicy join(Core core, ConfPolicy p1, ConfPolicy p2,
      Set/* <DelegationPair> */s) {
    try {
      enterTiming();
      Set/* <Policy> */comps = new LinkedHashSet/* <Policy> */@core();
      if (p1 instanceof JoinConfPolicy) {
        comps.addAll(((JoinConfPolicy) p1).joinComponents());
      } else {
        comps.add(p1);
      }
      if (p2 instanceof JoinConfPolicy) {
        comps.addAll(((JoinConfPolicy) p2).joinComponents());
      } else {
        comps.add(p2);
      }
      comps = simplifyJoin(comps, s);

      if (comps.size() == 1) {
        return (ConfPolicy) comps.iterator().next();
      }
      return new JoinConfPolicy@core(comps);
    } finally {
      exitTiming();
    }

  }

  public static IntegPolicy join(Core core, IntegPolicy p1, IntegPolicy p2) {
    try {
      enterTiming();
      return join(core, p1, p2, new HashSet/* <DelegationPair> */@core());
    } finally {
      exitTiming();
    }
  }

  static IntegPolicy join(Core core, IntegPolicy p1, IntegPolicy p2, Set/* <DelegationPair> */s) {
    try {
      enterTiming();
      Set/* <Policy> */comps = new LinkedHashSet/* <Policy> */@core();
      if (p1 instanceof JoinIntegPolicy) {
        comps.addAll(((JoinIntegPolicy) p1).joinComponents());
      } else {
        comps.add(p1);
      }
      if (p2 instanceof JoinIntegPolicy) {
        comps.addAll(((JoinIntegPolicy) p2).joinComponents());
      } else {
        comps.add(p2);
      }
      comps = simplifyJoin(comps, s);

      if (comps.size() == 1) {
        return (IntegPolicy) comps.iterator().next();
      }
      return new JoinIntegPolicy@core(comps);
    } finally {
      exitTiming();
    }

  }

  public static ConfPolicy meetPol(Core core, ConfPolicy p1, ConfPolicy p2) {
    try {
      enterTiming();
      return meet(core, p1, p2, new HashSet/* <DelegationPair> */@core());
    } finally {
      exitTiming();
    }
  }

  protected static ConfPolicy meet(Core core, ConfPolicy p1, ConfPolicy p2,
      Set/* <DelegationPair> */s) {
    try {
      enterTiming();
      Set/* <Policy> */comps = new LinkedHashSet/* <Policy> */@core();
      if (p1 instanceof MeetConfPolicy) {
        comps.addAll(((MeetConfPolicy) p1).meetComponents());
      } else {
        comps.add(p1);
      }
      if (p2 instanceof MeetConfPolicy) {
        comps.addAll(((MeetConfPolicy) p2).meetComponents());
      } else {
        comps.add(p2);
      }
      comps = simplifyMeet(comps, s);

      if (comps.size() == 1) {
        return (ConfPolicy) comps.iterator().next();
      }
      return new MeetConfPolicy@core(comps);
    } finally {
      exitTiming();
    }
  }

  public static IntegPolicy meetPol(Core core, IntegPolicy p1, IntegPolicy p2) {
    try {
      enterTiming();
      return meet(core, p1, p2, new HashSet/* <DelegationPair> */@core());
    } finally {
      exitTiming();
    }
  }

  static IntegPolicy meet(Core core, IntegPolicy p1, IntegPolicy p2, Set/* <DelegationPair> */s) {
    try {
      enterTiming();
      Set/* <Policy> */comps = new LinkedHashSet/* <Policy> */@core();
      if (p1 instanceof MeetIntegPolicy) {
        comps.addAll(((MeetIntegPolicy) p1).meetComponents());
      } else {
        comps.add(p1);
      }
      if (p2 instanceof MeetIntegPolicy) {
        comps.addAll(((MeetIntegPolicy) p2).meetComponents());
      } else {
        comps.add(p2);
      }
      comps = simplifyMeet(comps, s);

      if (comps.size() == 1) {
        return (IntegPolicy) comps.iterator().next();
      }
      return new MeetIntegPolicy@core(comps);
    } finally {
      exitTiming();
    }

  }

  public static boolean equivalentTo(Label l1, Label l2) {
    try {
      enterTiming();
      if (l1 == l2 || (l1 != null && l1.equals(l2))) return true;
      return relabelsTo(l1, l2) && relabelsTo(l2, l1);
    } finally {
      exitTiming();
    }
  }

  public static boolean isReadableBy(Label lbl, Principal p) {
    try {
      enterTiming();
      Label L = toLabel(localCore, PrincipalUtil.readableByPrinPolicy(localCore, p));
      return relabelsTo(lbl, L);
    } finally {
      exitTiming();
    }
  }
  
  public static boolean isWritableBy(Label lbl, Principal p) {
    try {
      enterTiming();
      Label L = toLabel(localCore, topConf(), writerPolicy(localCore, null, p));
      return relabelsTo(lbl, L);
    } finally {
      exitTiming();
    }
  }

  public static boolean relabelsTo(Label from, Label to) {
    try {
      enterTiming();
      if (from == null || to == null) return false;
      if (from == to || from.equals(to)) return true;
      Pair pair = new Pair(from, to);
      if (USE_CACHING) {
        if (cacheTrueLabelRelabels.contains(pair)) return true;
        if (cacheFalseLabelRelabels.contains(pair)) return false;
      }
      Set dependencies = new HashSet();
      boolean result = from != null && from.relabelsTo(to, dependencies);
      if (USE_CACHING) {
        if (!result) {
          cacheFalseLabelRelabels.add(pair);
        } else {
          cacheTrueLabelRelabels.add(pair);
          // add dependencies from delegations to the cache result
          // i.e., what dependencies does this result rely on?
          for (Iterator iter = dependencies.iterator(); iter.hasNext();) {
            PrincipalUtil.DelegationPair del =
                (PrincipalUtil.DelegationPair) iter.next();
            Set/* <Pair> */deps =
                (Set) cacheTrueLabelRelabelsDependencies.get(del);
            if (deps == null) {
              deps = new HashSet/* <Pair> */();
              cacheTrueLabelRelabelsDependencies.put(del, deps);
            }
            deps.add(pair);
          }
        }
      }
      return result;
    } finally {
      exitTiming();
    }
  }

  public static boolean relabelsTo(Policy from, Policy to) {
    try {
      enterTiming();
      return relabelsTo(from, to, new HashSet/* <DelegationPair> */());
    } finally {
      exitTiming();
    }
  }

  public static boolean relabelsTo(Policy from, Policy to, Set/* <DelegationPair> */s) {
    try {
      enterTiming();
      if (from == null || to == null) return false;
      if (from == to || from.equals(to)) return true;
      Pair pair = new Pair(from, to);
      if (USE_CACHING) {
        if (cacheTruePolicyRelabels.containsKey(pair)) {
          s.addAll((Collection) cacheTruePolicyRelabels.get(pair));
          return true;
        }
        if (cacheFalsePolicyRelabels.contains(pair)) return false;
      }
      Set/* <DelegationPair> */dependencies =
          new HashSet/* <DelegationPair> */();
      boolean result = from.relabelsTo(to, dependencies);
      if (USE_CACHING) {
        if (!result) {
          cacheFalsePolicyRelabels.add(pair);
        } else {
          cacheTruePolicyRelabels.put(pair, dependencies);
          // add dependencies from delegations to the cache result
          // i.e., what dependencies does this result rely on?
          for (Iterator/* <DelegationPair> */iter = dependencies.iterator(); iter
              .hasNext();) {
            PrincipalUtil.DelegationPair del =
                (PrincipalUtil.DelegationPair) iter.next();
            Set/* <Pair> */deps =
                (Set) cacheTruePolicyRelabelsDependencies.get(del);
            if (deps == null) {
              deps = new HashSet/* <Pair> */();
              cacheTruePolicyRelabelsDependencies.put(del, deps);
            }
            deps.add(pair);
          }
          s.addAll(dependencies);
        }
      }
      return result;
    } finally {
      exitTiming();
    }
  }

  public static String stringValue(Label lb) {
    try {
      enterTiming();
      if (lb == null) return "<null>";
      return lb.toString();
    } finally {
      exitTiming();
    }
  }

  public static String toString(Label lb) {
    try {
      enterTiming();
      return stringValue(lb);
    } finally {
      exitTiming();
    }
  }

  public static int hashCode(Label lb) {
    try {
      enterTiming();
      if (lb == null) return 0;
      return lb.hashCode();
    } finally {
      exitTiming();
    }
  }

  private static Set/* <Policy> */simplifyJoin(Set/* <Policy> */policies,
      Set/* <DelegationPair> */dependencies) {
    Set/* <Policy> */needed = new LinkedHashSet/* <Policy> */();
    for (Iterator/* <Policy> */i = policies.iterator(); i.hasNext();) {
      Policy ci = (Policy) i.next();

      boolean subsumed = (ci == null); // null components are always subsumed.
      for (Iterator/* <Policy> */j = needed.iterator(); !subsumed
          && j.hasNext();) {
        Policy cj = (Policy) j.next();
        if (relabelsTo(ci, cj, dependencies)) {
          subsumed = true;
          break;
        }

        if (relabelsTo(cj, ci, dependencies)) {
          j.remove();
        }
      }

      if (!subsumed) needed.add(ci);
    }

    return needed;
  }

  private static Set/* <Policy> */simplifyMeet(Set/* <Policy> */policies,
      Set/* <DelegationPair> */dependencies) {
    Set/* <Policy> */needed = new LinkedHashSet/* <Policy> */();
    for (Iterator/* <Policy> */i = policies.iterator(); i.hasNext();) {
      Policy ci = (Policy) i.next();

      boolean subsumed = (ci == null); // null components are always subsumed.
      for (Iterator/* <Policy> */j = needed.iterator(); !subsumed
          && j.hasNext();) {
        Policy cj = (Policy) j.next();
        if (relabelsTo(cj, ci, dependencies)) {
          subsumed = true;
          break;
        }

        if (relabelsTo(ci, cj, dependencies)) {
          j.remove();
        }
      }

      if (!subsumed) needed.add(ci);
    }

    return needed;
  }

  /**
   * Internal representation of a pair of objects, used for the caches
   */
  private static class Pair {
    final Object left; // must be non null
    final Object right; // must be non null

    public Pair(Object left, Object right) {
      this.left = left;
      this.right = right;
    }

    public int hashCode() {
      return left.hashCode() ^ right.hashCode();
    }

    public boolean equals(Object o) {
      if (o instanceof Pair) {
        Pair that = (Pair) o;
        return (this.left == that.left || this.left.equals(that.left))
            && (this.right == that.right || this.right.equals(that.right));
      }
      return false;
    }

    public String toString() {
      return left + "-" + right;
    }
  }

  static void notifyNewDelegation(Principal granter, Principal superior) {
    try {
      enterTiming();
      if (USE_CACHING) {
        // XXX for the moment, just clear out the caches.
        cacheFalseLabelRelabels.clear();
        cacheFalsePolicyRelabels.clear();

        // the label meets and joins can be soundly left, they just
        // may not be as simplified as they could be. However, to maintain
        // compatability with previous behavior, we will clear the caches
        cacheLabelJoins.clear();
        cacheLabelMeets.clear();
        cacheLabelJoinDependencies.clear();
        cacheLabelMeetDependencies.clear();
      }
    } finally {
      exitTiming();
    }
  }

  static void notifyRevokeDelegation(Principal granter, Principal superior) {
    try {
      enterTiming();
      if (USE_CACHING) {
        PrincipalUtil.DelegationPair del =
            new PrincipalUtil.DelegationPair(superior, granter);
        Set/* <Pair> */deps =
            (Set) cacheTrueLabelRelabelsDependencies.remove(del);
        if (deps != null) {
          for (Iterator/* <Pair> */iter = deps.iterator(); iter.hasNext();) {
            Pair afp = (Pair) iter.next();
            cacheTrueLabelRelabels.remove(afp);
          }
        }
        deps = (Set) cacheTruePolicyRelabelsDependencies.remove(del);
        if (deps != null) {
          for (Iterator/* <Pair> */iter = deps.iterator(); iter.hasNext();) {
            Pair afp = (Pair) iter.next();
            cacheTruePolicyRelabels.remove(afp);
          }
        }
        deps = (Set) cacheLabelJoinDependencies.remove(del);
        if (deps != null) {
          for (Iterator/* <Pair> */iter = deps.iterator(); iter.hasNext();) {
            Pair afp = (Pair) iter.next();
            cacheLabelJoins.remove(afp);
          }
        }
        deps = (Set) cacheLabelMeetDependencies.remove(del);
        if (deps != null) {
          for (Iterator/* <Pair> */iter = deps.iterator(); iter.hasNext();) {
            Pair afp = (Pair) iter.next();
            cacheLabelMeets.remove(afp);
          }
        }
      }
    } finally {
      exitTiming();
    }
  }
}
